<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VRChat Boothå•†å“ç®¡ç†</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1f2937;
            color: white;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            background-color: #374151;
            padding: 12px 16px;
            border-radius: 6px;
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 60px;
        }
        .header h1 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: white;
        }
        
        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
        @media (max-width: 1000px) {
            .header {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
                padding: 16px;
            }
        }
        
        @media (max-width: 600px) {
            .header {
                padding: 12px;
            }
            .header h1 {
                font-size: 16px;
            }
        }
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
            60% {
                transform: translateY(-5px);
            }
        }
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
            }
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
        }
        .list {
            display: grid;
            grid-template-columns: 1fr;
            gap: 3px;
        }
        @media (min-width: 1000px) {
            .list {
                grid-template-columns: 1fr 1fr;
                gap: 8px;
            }
        }
        .list-item {
            background-color: #374151;
            border-radius: 4px;
            padding: 6px;
            display: flex;
            align-items: flex-start;
            gap: 6px;
            min-height: 52px;
            position: relative;
        }
        .list-item .item-checkbox {
            position: absolute;
            top: 4px;
            left: 4px;
            width: 12px;
            height: 12px;
        }
        .list-item .item-thumbnail {
            width: 60px;
            height: 48px;
            background-color: #4b5563;
            border-radius: 4px;
            flex-shrink: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 10px;
            margin-top: 2px;
        }
        .list-item .item-content {
            flex: 1;
            min-width: 0;
        }
        .list-item .item-title {
            font-size: 14px;
            font-weight: bold;
            margin: 0 0 2px 0;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            line-height: 1.3;
            word-break: break-word;
        }
        .list-item .item-info {
            font-size: 12px;
            color: #9ca3af;
            margin: 0;
        }
        .list-item .item-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
            align-self: center;
        }
        .list-item .item-actions button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .card {
            background-color: #374151;
            border-radius: 6px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s;
            position: relative;
        }
        .card:hover {
            transform: translateY(-2px);
        }
        .card-image {
            width: 100%;
            height: 150px;
            background-color: #4b5563;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        .card-image img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .card-content {
            padding: 15px;
            background-color: #374151;
            height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .card-title {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
            line-height: 1.3;
            min-height: 36px;
            max-height: 52px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            word-break: break-word;
        }
        .buttons {
            display: flex;
            gap: 5px;
        }
        .btn {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: white;
            min-width: 50px;
        }
        .btn-blue { background-color: #2563eb; }
        .btn-yellow { background-color: #d97706; }
        .btn-red { background-color: #dc2626; }
        .btn:hover { opacity: 0.8; }
        .add-btn {
            background-color: #16a34a;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            overflow-y: auto;
        }
        .modal-content {
            position: relative;
            margin: 50px auto;
            background-color: #374151;
            padding: 20px;
            border-radius: 6px;
            width: 800px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #4b5563;
            border-radius: 4px;
            background-color: #4b5563;
            color: white !important;
            caret-color: white !important;
            box-sizing: border-box;
        }
        
        /* å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å¯è¦–æ€§ç¢ºä¿ */
        input[type="text"], input[type="url"], textarea {
            color: white !important;
            background-color: #374151 !important;
            caret-color: white !important;
            opacity: 1 !important;
            font-size: 14px !important;
            line-height: 1.4 !important;
        }
        
        /* ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆã®å¯è¦–æ€§ */
        input::placeholder, textarea::placeholder {
            color: #9ca3af !important;
            opacity: 0.7 !important;
        }
        .form-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .form-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .form-btn-cancel {
            background-color: #6b7280;
            color: white;
        }
        .form-btn-submit {
            background-color: #2563eb;
            color: white;
        }
        
        /* ã‚¹ãƒãƒ¼ãƒˆãƒãƒƒãƒãƒ³ã‚°UI */
        .smart-matching-modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
        }
        .smart-matching-content {
            position: relative;
            background-color: #1f2937;
            margin: 2% auto;
            padding: 20px;
            width: 95%;
            height: 90%;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
        }
        .matching-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #374151;
        }
        .matching-body {
            display: flex;
            flex: 1;
            gap: 20px;
            min-height: 0;
        }
        .matching-panel {
            flex: 1;
            background-color: #374151;
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
        }
        .panel-header {
            font-weight: bold;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #4b5563;
            border-radius: 6px;
            display: flex;
            justify-content: between;
            align-items: center;
        }
        .file-item, .purchase-item {
            background-color: #4b5563;
            margin: 10px 0;
            padding: 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        .file-item:hover, .purchase-item:hover {
            background-color: #6b7280;
            transform: translateY(-2px);
        }
        .file-item.selected, .purchase-item.selected {
            border-color: #3b82f6;
            background-color: #1e40af;
        }
        .file-item.matched, .purchase-item.matched {
            border-color: #10b981;
            background-color: #065f46;
        }
        .item-name {
            font-weight: bold;
            margin-bottom: 5px;
            word-break: break-word;
        }
        .item-details {
            font-size: 12px;
            color: #d1d5db;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .item-thumbnail {
            width: 48px;
            height: 48px;
            border-radius: 4px;
            object-fit: cover;
            margin-right: 10px;
            float: left;
        }
        .match-actions {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        .match-button {
            background-color: #10b981;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        .match-button:hover {
            background-color: #059669;
        }
        .match-button:disabled {
            background-color: #6b7280;
            cursor: not-allowed;
        }
        .progress-info {
            background-color: #374151;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" style="flex-wrap: wrap; gap: 15px;">
            <!-- ã‚¿ã‚¤ãƒˆãƒ«è¡Œ -->
            <div style="display: flex; align-items: center; gap: 10px; flex-shrink: 0;">
                <h1 style="font-size: clamp(1.2rem, 2.5vw, 1.5rem); white-space: nowrap;">VRChat Boothå•†å“ç®¡ç†</h1>
                <button onclick="showHelpModal()" style="width: 24px; height: 24px; border-radius: 50%; background-color: #6b7280; color: white; border: none; cursor: pointer; font-size: 14px; font-weight: bold; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s; flex-shrink: 0;" title="ä½¿ã„æ–¹ã‚’è¡¨ç¤º" onmouseover="this.style.backgroundColor='#4b5563'" onmouseout="this.style.backgroundColor='#6b7280'">?</button>
                <button onclick="showSettingsModal()" style="width: 24px; height: 24px; border-radius: 50%; background-color: #6b7280; color: white; border: none; cursor: pointer; font-size: 12px; font-weight: bold; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s; flex-shrink: 0;" title="è¨­å®š" onmouseover="this.style.backgroundColor='#4b5563'" onmouseout="this.style.backgroundColor='#6b7280'">âš™</button>
            </div>
            
            <!-- æ¤œç´¢ãƒ»æ“ä½œè¡Œ -->
            <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap; flex: 1; min-width: 0;">
                <div style="position: relative; flex: 1; min-width: 200px; max-width: 300px;">
                    <input type="text" id="searchInput" placeholder="å•†å“åãƒ»èª¬æ˜æ–‡ã§æ¤œç´¢..." onkeyup="searchProducts()" style="padding: 6px 12px; background-color: #4b5563; color: white; border: 1px solid #6b7280; border-radius: 4px; font-size: 13px; width: 100%; height: 32px; box-sizing: border-box;">
                    <button onclick="clearSearch()" style="position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: none; border: none; color: #9ca3af; cursor: pointer; font-size: 16px;">Ã—</button>
                </div>
                
                <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                    <button class="add-btn" onclick="importPurchaseHistory()" style="background-color: #10b981; font-size: 12px; padding: 6px 10px; white-space: nowrap;" title="è³¼å…¥å±¥æ­´ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ">ğŸ“¥ å±¥æ­´</button>
                    <button class="add-btn" onclick="clearPurchaseHistory()" style="background-color: #6b7280; font-size: 12px; padding: 6px 10px; display: none; white-space: nowrap;" id="clearHistoryBtn" title="è³¼å…¥å±¥æ­´ã‚’ã‚¯ãƒªã‚¢">ğŸ—‘ï¸ å±¥æ­´</button>
                    <button class="add-btn" onclick="clearBoothLibraryData()" style="background-color: #9333ea; font-size: 12px; padding: 6px 10px; display: none; white-space: nowrap;" id="clearLibraryBtn" title="Boothãƒ©ã‚¤ãƒ–ãƒ©ãƒªåé›†ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢">ğŸ“š åé›†</button>
                    <button class="add-btn" onclick="addProduct()" style="font-size: 12px; padding: 6px 10px; white-space: nowrap;">â• è¿½åŠ </button>
                </div>
            </div>
        </div>
        
        <div style="margin-bottom: 20px; display: flex; align-items: flex-start; gap: 25px; flex-wrap: wrap;">
            <div>
                <label style="color: white; font-weight: bold; display: block; margin-bottom: 6px;">è¡¨ç¤ºã‚«ãƒ†ã‚´ãƒª:</label>
                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                    <label style="display: flex; align-items: center; gap: 4px; color: white; cursor: pointer;">
                        <input type="checkbox" id="filter_avatar" value="ã‚¢ãƒã‚¿ãƒ¼æœ¬ä½“" onchange="filterProducts()" checked style="width: 14px; height: 14px;">
                        <span style="font-size: 13px;">ã‚¢ãƒã‚¿ãƒ¼æœ¬ä½“</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; color: white; cursor: pointer;">
                        <input type="checkbox" id="filter_costume" value="è¡£è£…" onchange="filterProducts()" checked style="width: 14px; height: 14px;">
                        <span style="font-size: 13px;">è¡£è£…</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; color: white; cursor: pointer;">
                        <input type="checkbox" id="filter_accessory" value="ã‚¢ã‚¯ã‚»ã‚µãƒªãƒ¼" onchange="filterProducts()" checked style="width: 14px; height: 14px;">
                        <span style="font-size: 13px;">ã‚¢ã‚¯ã‚»ã‚µãƒªãƒ¼</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; color: white; cursor: pointer;">
                        <input type="checkbox" id="filter_hair" value="é«ªå‹" onchange="filterProducts()" checked style="width: 14px; height: 14px;">
                        <span style="font-size: 13px;">é«ªå‹</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; color: white; cursor: pointer;">
                        <input type="checkbox" id="filter_tool" value="ãƒ„ãƒ¼ãƒ«" onchange="filterProducts()" checked style="width: 14px; height: 14px;">
                        <span style="font-size: 13px;">ãƒ„ãƒ¼ãƒ«</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; color: white; cursor: pointer;">
                        <input type="checkbox" id="filter_pose" value="ãƒãƒ¼ã‚º" onchange="filterProducts()" checked style="width: 14px; height: 14px;">
                        <span style="font-size: 13px;">ãƒãƒ¼ã‚º</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; color: white; cursor: pointer;">
                        <input type="checkbox" id="filter_world" value="ãƒ¯ãƒ¼ãƒ«ãƒ‰" onchange="filterProducts()" checked style="width: 14px; height: 14px;">
                        <span style="font-size: 13px;">ãƒ¯ãƒ¼ãƒ«ãƒ‰</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; color: white; cursor: pointer;">
                        <input type="checkbox" id="filter_other" value="ãã®ä»–" onchange="filterProducts()" checked style="width: 14px; height: 14px;">
                        <span style="font-size: 13px;">ãã®ä»–</span>
                    </label>
                </div>
            </div>
            <div style="display: flex; flex-wrap: wrap; justify-content: space-between; align-items: flex-start; gap: 12px; width: 100%;">
                <div style="display: flex; flex-wrap: wrap; gap: 12px; align-items: center; flex: 1; min-width: 0;">
                    <div style="display: flex; align-items: center; gap: 6px; min-width: fit-content;">
                        <label for="avatarSelect" style="color: white; font-size: 13px; font-weight: 500; white-space: nowrap;">å¯¾å¿œã‚¢ãƒã‚¿ãƒ¼:</label>
                        <select id="avatarSelect" onchange="filterProducts()" style="padding: 6px 10px; background-color: #374151; color: white; border: 1px solid #4b5563; border-radius: 4px; font-size: 13px; min-width: 120px; height: 32px;">
                            <option value="all">ã™ã¹ã¦</option>
                            <!-- ã‚¢ãƒã‚¿ãƒ¼ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒã“ã“ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
                        </select>
                    </div>
                    <div style="display: flex; align-items: center; gap: 6px; min-width: fit-content;">
                        <label for="tagSelect" style="color: white; font-size: 13px; font-weight: 500; white-space: nowrap;">ã‚¿ã‚°:</label>
                        <select id="tagSelect" onchange="filterProducts()" style="padding: 6px 10px; background-color: #374151; color: white; border: 1px solid #4b5563; border-radius: 4px; font-size: 13px; min-width: 120px; height: 32px;">
                            <option value="all">ã™ã¹ã¦</option>
                            <!-- ã‚¿ã‚°ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒã“ã“ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
                        </select>
                    </div>
                    <div style="display: flex; align-items: center; gap: 6px; min-width: fit-content;">
                        <label for="orderSelect" style="color: white; font-size: 13px; font-weight: 500; white-space: nowrap;">ä¸¦ã³é †:</label>
                        <select id="orderSelect" onchange="filterProducts()" style="padding: 6px 10px; background-color: #374151; color: white; border: 1px solid #4b5563; border-radius: 4px; font-size: 13px; min-width: 120px; height: 32px;">
                            <option value="created_desc">æ–°ã—ã„é †</option>
                            <option value="created_asc">å¤ã„é †</option>
                        </select>
                    </div>
                </div>
                <div style="display: flex; align-items: center; gap: 4px; flex-shrink: 0;">
                    <button id="gridViewBtn" onclick="switchToGridView()" style="padding: 6px; background-color: #4b5563; color: white; border: 1px solid #6b7280; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; width: 32px; height: 32px;" title="ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º">
                        <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                            <rect x="1" y="1" width="6" height="6" rx="1"/>
                            <rect x="9" y="1" width="6" height="6" rx="1"/>
                            <rect x="1" y="9" width="6" height="6" rx="1"/>
                            <rect x="9" y="9" width="6" height="6" rx="1"/>
                        </svg>
                    </button>
                    <button id="listViewBtn" onclick="switchToListView()" style="padding: 6px; background-color: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; width: 32px; height: 32px;" title="ãƒªã‚¹ãƒˆè¡¨ç¤º">
                        <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                            <rect x="2" y="3" width="2" height="2" rx="1"/>
                            <rect x="6" y="3" width="8" height="2" rx="1"/>
                            <rect x="2" y="7" width="2" height="2" rx="1"/>
                            <rect x="6" y="7" width="8" height="2" rx="1"/>
                            <rect x="2" y="11" width="2" height="2" rx="1"/>
                            <rect x="6" y="11" width="8" height="2" rx="1"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚¨ãƒªã‚¢ -->
        <div id="dropZone" style="border: 2px dashed #4b5563; border-radius: 6px; padding: 40px; text-align: center; margin-bottom: 20px; background-color: #374151; display: none; transition: all 0.3s ease;">
            <div style="font-size: 48px; margin-bottom: 16px;">â¬‡ï¸</div>
            <p style="color: #9ca3af; margin: 0; font-size: 18px; font-weight: 600;">ğŸ“¦ ã“ã“ã«ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¦å•†å“ã‚’ç™»éŒ²</p>
            <p style="color: #6b7280; margin: 8px 0 0 0; font-size: 14px;">.unitypackageãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ãƒ•ã‚©ãƒ«ãƒ€ã‚’ãƒ‰ãƒ­ãƒƒãƒ—</p>
        </div>

        <!-- ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ -->
        <div id="dragOverlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 9999; display: none; pointer-events: none;">
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white;">
                <div style="font-size: 80px; margin-bottom: 20px; animation: bounce 1s infinite;">ğŸ“¦</div>
                <h2 style="font-size: 28px; margin: 0 0 10px 0; color: #60a5fa;">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¦ç™»éŒ²</h2>
                <p style="font-size: 16px; margin: 0; color: #d1d5db;">.unitypackageãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ãƒ•ã‚©ãƒ«ãƒ€ã‚’é›¢ã—ã¦ãã ã•ã„</p>
            </div>
        </div>
        
        
        <!-- é¸æŠæ™‚ã®ã‚¿ã‚°ç·¨é›†ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆä¸‹éƒ¨å›ºå®šï¼‰ -->
        <div id="selectionBlock" style="opacity: 0; visibility: hidden; transform: translateY(100%); position: fixed; bottom: 0; left: 0; right: 0; background-color: #374151; padding: 12px; border-top: 2px solid #4b5563; box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.4); z-index: 100; transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out, visibility 0.3s;">
            <!-- ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œ -->
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                <span style="color: white; font-weight: 600; font-size: 13px;"><span id="selectedCount">0</span>å€‹é¸æŠä¸­</span>
                <div style="display: flex; gap: 6px;">
                    <button onclick="deleteSelectedProducts()" style="padding: 6px 12px; background-color: #dc2626; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; height: 32px; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#b91c1c'" onmouseout="this.style.backgroundColor='#dc2626'">é¸æŠã—ãŸã‚¢ã‚¤ãƒ†ãƒ ã‚’å‰Šé™¤</button>
                    <button onclick="clearSelection()" style="padding: 6px 12px; background-color: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; height: 32px; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#4b5563'" onmouseout="this.style.backgroundColor='#6b7280'">é¸æŠã‚’è§£é™¤</button>
                </div>
            </div>
            
            <!-- ã‚¿ã‚°ç·¨é›†ã‚¨ãƒªã‚¢ -->
            <div style="background-color: #4b5563; border-radius: 4px; padding: 8px;">
                <label style="color: #d1d5db; font-size: 11px; margin-bottom: 6px; display: block; font-weight: 500;">ã‚¿ã‚°ç·¨é›†</label>
                
                <!-- é¸æŠæ¸ˆã¿ã‚¿ã‚°è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
                <div id="selectedTagsArea" style="display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 8px; min-height: 20px; align-items: flex-start; background-color: #374151; border-radius: 3px; padding: 6px; border: 1px solid #6b7280;">
                </div>
                
                <!-- ã‚¿ã‚°å…¥åŠ›ã‚¨ãƒªã‚¢ -->
                <div style="display: flex; gap: 6px; align-items: center;">
                    <div style="position: relative; flex: 1; max-width: 250px;">
                        <input type="text" id="tagInput" placeholder="ã‚¿ã‚°ã‚’å…¥åŠ›ã—ã¦Enterã¾ãŸã¯+ãƒœã‚¿ãƒ³" style="width: 100%; padding: 6px 8px; background-color: #374151; color: white; border: 1px solid #6b7280; border-radius: 4px; font-size: 12px; box-sizing: border-box; transition: border-color 0.2s;" 
                               onkeydown="handleTagInput(event)" 
                               oninput="showTagSuggestions(this.value)"
                               onfocus="showTagSuggestions(this.value); this.style.borderColor='#059669'"
                               onblur="setTimeout(() => hideTagSuggestions(), 100); this.style.borderColor='#6b7280'">
                        
                        <!-- ã‚¿ã‚°å€™è£œãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ï¼ˆä¸Šå‘ãè¡¨ç¤ºï¼‰ -->
                        <div id="tagSuggestions" style="display: none; position: absolute; bottom: 100%; left: 0; right: 0; background-color: #374151; border: 1px solid #6b7280; border-radius: 4px; max-height: 150px; overflow-y: auto; z-index: 200; margin-bottom: 2px; box-shadow: 0 -4px 6px rgba(0, 0, 0, 0.3);">
                        </div>
                    </div>
                    
                    <!-- ã‚¿ã‚°è¿½åŠ ãƒœã‚¿ãƒ³ -->
                    <button onclick="this.blur(); addTagFromInput();" style="padding: 6px 12px; background-color: #0369a1; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 500; height: 32px; transition: background-color 0.2s; display: flex; align-items: center; gap: 2px;" onmouseover="this.style.backgroundColor='#0284c7'" onmouseout="this.style.backgroundColor='#0369a1'">
                        <span style="font-size: 14px; line-height: 1;">+</span>è¿½åŠ 
                    </button>
                    
                    <!-- é©ç”¨ãƒœã‚¿ãƒ³ -->
                    <button onclick="this.blur(); applyTagsToSelected();" style="padding: 6px 12px; background-color: #059669; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#047857'" onmouseout="this.style.backgroundColor='#059669'">
                        é¸æŠã—ãŸå•†å“ã«ã‚¿ã‚°ã‚’é©ç”¨
                    </button>
                </div>
            </div>
        </div>
        
        <div id="products" class="grid" style="padding-bottom: 20px;">
            <!-- å•†å“ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ -->
        </div>
    </div>

    <!-- å•†å“è¿½åŠ ãƒ»ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="productModal" class="modal">
        <div class="modal-content">
            <h2 id="modalTitle">å•†å“ã‚’è¿½åŠ </h2>
            <form id="productForm">
                <div class="form-group">
                    <label for="productName">å•†å“å *</label>
                    <input type="text" id="productName" name="name" required>
                </div>
                <div class="form-group">
                    <label for="productCategory">ã‚«ãƒ†ã‚´ãƒª</label>
                    <select id="productCategory" name="category" onchange="handleCategoryChange()">
                        <option value="ã‚¢ãƒã‚¿ãƒ¼æœ¬ä½“">ã‚¢ãƒã‚¿ãƒ¼æœ¬ä½“</option>
                        <option value="è¡£è£…">è¡£è£…</option>
                        <option value="ã‚¢ã‚¯ã‚»ã‚µãƒªãƒ¼">ã‚¢ã‚¯ã‚»ã‚µãƒªãƒ¼</option>
                        <option value="é«ªå‹">é«ªå‹</option>
                        <option value="ãƒ„ãƒ¼ãƒ«">ãƒ„ãƒ¼ãƒ«</option>
                        <option value="ãƒãƒ¼ã‚º">ãƒãƒ¼ã‚º</option>
                        <option value="ãƒ¯ãƒ¼ãƒ«ãƒ‰">ãƒ¯ãƒ¼ãƒ«ãƒ‰</option>
                        <option value="ãã®ä»–">ãã®ä»–</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="productBoothUrl">Booth URL</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="url" id="productBoothUrl" name="booth_url" placeholder="https://booth.pm/..." style="flex: 1;">
                        <button type="button" onclick="searchBoothForCurrentFile()" class="form-btn" style="background-color: #2563eb; color: white;">â‘ BOOTHæ¤œç´¢</button>
                        <button type="button" id="thumbnailFetchBtn" class="form-btn form-btn-submit">â‘¡ã‚µãƒ ãƒã‚¤ãƒ«å–å¾—</button>
                    </div>
                </div>
                <div class="form-group">
                    <label for="productThumbnailUrl">ã‚µãƒ ãƒã‚¤ãƒ« URL</label>
                    <input type="url" id="productThumbnailUrl" name="thumbnail_url" oninput="showThumbnailPreview(this.value)" onchange="showThumbnailPreview(this.value)">
                    <!-- ã‚µãƒ ãƒã‚¤ãƒ« ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ -->
                    <div id="thumbnailPreview" style="margin-top: 8px; display: none;">
                        <img id="thumbnailImage" style="max-width: 200px; max-height: 200px; border-radius: 4px; border: 1px solid #6b7280;" alt="ã‚µãƒ ãƒã‚¤ãƒ« ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼" draggable="false">
                    </div>
                </div>
                <div class="form-group">
                    <label for="productFilePath">ãƒ•ã‚¡ã‚¤ãƒ« <span id="selectedFileInfo" style="font-size: 11px; color: #9ca3af;"></span></label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="productFilePath" name="file_path" style="flex: 1;" readonly placeholder="ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼ˆè¤‡æ•°é¸æŠå¯ï¼‰">
                        <button type="button" onclick="selectMultipleFiles()" class="form-btn form-btn-submit" style="min-width: 120px;">
                            ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ
                        </button>
                    </div>
                    <!-- è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
                    <div id="multipleFilesArea" style="margin-top: 12px; display: none;">
                        <label style="font-size: 13px; color: #d1d5db; margin-bottom: 8px; display: block; font-weight: 500;">
                            ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ 
                            <span style="font-size: 11px; color: #9ca3af; font-weight: normal;">ï¼ˆå„ãƒ•ã‚¡ã‚¤ãƒ«ã®è¡¨ç¤ºåã‚’è‡ªç”±ã«ç·¨é›†ã§ãã¾ã™ï¼‰</span>
                        </label>
                        <div id="filesList" style="max-height: 150px; overflow-y: auto; border: 1px solid #6b7280; border-radius: 6px; padding: 8px; background-color: #374151;">
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <label for="productAvatars">å¯¾å¿œã‚¢ãƒã‚¿ãƒ¼</label>
                    <div id="avatarCheckboxes" style="max-height: 150px; overflow-y: auto; border: 1px solid #4b5563; border-radius: 4px; padding: 10px; background-color: #4b5563;">
                        <!-- ã‚¢ãƒã‚¿ãƒ¼ã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ -->
                    </div>
                </div>
                <div class="form-group">
                    <label for="productTags">ã‚¿ã‚°</label>
                    <div id="tagCheckboxes" style="max-height: 120px; overflow-y: auto; border: 1px solid #4b5563; border-radius: 4px; padding: 10px; background-color: #4b5563; margin-bottom: 10px;">
                        <!-- ã‚¿ã‚°ã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ -->
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="newTagInput" placeholder="æ–°ã—ã„ã‚¿ã‚°ã‚’è¿½åŠ " onkeypress="if(event.key==='Enter'){addNewTag();}" style="flex: 1; padding: 6px 8px; border: 1px solid #4b5563; border-radius: 4px; background-color: #4b5563; color: white; font-size: 12px;">
                        <button type="button" onclick="addNewTag()" style="padding: 6px 12px; background-color: #16a34a; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">è¿½åŠ </button>
                    </div>
                </div>
                <div class="form-group">
                    <label for="productDescription">èª¬æ˜</label>
                    <textarea id="productDescription" name="description" rows="3"></textarea>
                </div>
                <div class="form-buttons">
                    <button type="button" onclick="closeModal()" class="form-btn form-btn-cancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                    <button type="submit" class="form-btn form-btn-submit">ä¿å­˜</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        let products = [];
        let avatars = [];
        let currentSort = 'created_desc';
        let currentSortOrder = 'created_desc'; // ç¾åœ¨ã®ä¸¦ã³é †ã‚’ä¿æŒ
        let searchQuery = '';
        let isListView = false;
        let selectedProducts = new Set();

        // Electronã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        async function loadProducts() {
            try {
                if (window.electronAPI) {
                    const rawProducts = await window.electronAPI.database.getProducts();
                    products = rawProducts.map(cleanupInvalidAvatarIds);
                    avatars = await window.electronAPI.database.getAvatars();
                    
                    // ã‚¢ãƒã‚¿ãƒ¼ãƒ•ã‚£ãƒ«ã‚¿ã®é¸æŠè‚¢ã‚’æ›´æ–°
                    updateAvatarFilterOptions();
                    
                    filterProducts();
                    
                    // å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®åŸºæœ¬è¨­å®šã‚’é©ç”¨
                    setTimeout(() => {
                        const inputFields = document.querySelectorAll('input[type="text"], input[type="url"], textarea');
                        inputFields.forEach(field => {
                            field.style.pointerEvents = 'auto';
                            field.style.userSelect = 'text';
                            field.disabled = false;
                            field.readOnly = false;
                        });
                    }, 100);
                }
            } catch (error) {
                console.error('Failed to load products:', error);
            }
        }

        // å…¨ã‚¢ãƒã‚¿ãƒ¼ãƒªã‚¹ãƒˆã‚’å–å¾—
        function getAllAvatars() {
            console.log('getAllAvatars() å®Ÿè¡Œé–‹å§‹');
            // avatarsé…åˆ—ã¨ã€Œã‚¢ãƒã‚¿ãƒ¼æœ¬ä½“ã€ã‚«ãƒ†ã‚´ãƒªã®å•†å“ã‹ã‚‰ã‚¢ãƒã‚¿ãƒ¼ã‚’å–å¾—
            const allAvatars = [...avatars];
            console.log('avatarsé…åˆ—:', avatars);
            
            // ã€Œã‚¢ãƒã‚¿ãƒ¼æœ¬ä½“ã€ã‚«ãƒ†ã‚´ãƒªã®å•†å“ã‚’ã‚¢ãƒã‚¿ãƒ¼ã¨ã—ã¦è¿½åŠ 
            const avatarProducts = products.filter(product => product.category === 'ã‚¢ãƒã‚¿ãƒ¼æœ¬ä½“');
            console.log('ã‚¢ãƒã‚¿ãƒ¼æœ¬ä½“ã‚«ãƒ†ã‚´ãƒªã®å•†å“:', avatarProducts);
            
            avatarProducts.forEach(product => {
                // æ—¢ã«åŒã˜IDã¾ãŸã¯åŒã˜åå‰ã®ã‚¢ãƒã‚¿ãƒ¼ãŒå­˜åœ¨ã—ãªã„å ´åˆã®ã¿è¿½åŠ 
                if (!allAvatars.find(avatar => avatar.id === product.id || avatar.name === product.name)) {
                    allAvatars.push({
                        id: product.id,
                        name: product.name,
                        thumbnail_url: product.thumbnail_url
                    });
                    console.log('ã‚¢ãƒã‚¿ãƒ¼ã‚’è¿½åŠ :', product.name);
                }
            });
            
            console.log('getAllAvatars() çµæœ:', allAvatars);
            return allAvatars;
        }

        // ã‚¢ãƒã‚¿ãƒ¼ãƒ•ã‚£ãƒ«ã‚¿ã®é¸æŠè‚¢ã‚’æ›´æ–°
        function updateAvatarFilterOptions() {
            console.log('updateAvatarFilterOptions() å®Ÿè¡Œé–‹å§‹');
            const avatarSelect = document.getElementById('avatarSelect');
            if (!avatarSelect) {
                console.log('avatarSelectè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                return;
            }
            
            // ç¾åœ¨é¸æŠã•ã‚Œã¦ã„ã‚‹ã‚¢ãƒã‚¿ãƒ¼ã‚’ä¿æŒ
            const currentSelectedAvatar = avatarSelect.value;
            console.log('ç¾åœ¨é¸æŠã•ã‚Œã¦ã„ã‚‹ã‚¢ãƒã‚¿ãƒ¼:', currentSelectedAvatar);
            
            // ç¾åœ¨ã®é¸æŠè‚¢ã‚’ã‚¯ãƒªã‚¢ï¼ˆã€Œã™ã¹ã¦ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ä¿æŒï¼‰
            avatarSelect.innerHTML = '<option value="all">ã™ã¹ã¦</option>';
            
            // åˆ©ç”¨å¯èƒ½ãªã‚¢ãƒã‚¿ãƒ¼ã‚’å–å¾—
            const allAvatars = getAllAvatars();
            console.log('åˆ©ç”¨å¯èƒ½ãªã‚¢ãƒã‚¿ãƒ¼ä¸€è¦§:', allAvatars);
            
            // æ–°ã—ã„é¸æŠè‚¢ã‚’è¿½åŠ 
            allAvatars.forEach(avatar => {
                const option = document.createElement('option');
                option.value = avatar.id.toString();
                option.textContent = avatar.name;
                avatarSelect.appendChild(option);
            });
            
            // ä»¥å‰ã®é¸æŠã‚’å¾©å…ƒï¼ˆãã®ã‚¢ãƒã‚¿ãƒ¼ãŒã¾ã å­˜åœ¨ã™ã‚‹å ´åˆï¼‰
            const avatarExists = allAvatars.some(avatar => avatar.id.toString() === currentSelectedAvatar);
            console.log('ä»¥å‰é¸æŠã•ã‚Œã¦ã„ãŸã‚¢ãƒã‚¿ãƒ¼ãŒã¾ã å­˜åœ¨ã™ã‚‹ã‹:', avatarExists);
            if (avatarExists) {
                avatarSelect.value = currentSelectedAvatar;
                console.log('ä»¥å‰ã®é¸æŠã‚’å¾©å…ƒã—ã¾ã—ãŸ');
            } else {
                // å‰Šé™¤ã•ã‚ŒãŸã‚¢ãƒã‚¿ãƒ¼ãŒé¸æŠã•ã‚Œã¦ã„ãŸå ´åˆã¯ã€Œã™ã¹ã¦ã€ã«ãƒªã‚»ãƒƒãƒˆ
                avatarSelect.value = 'all';
                console.log('å‰Šé™¤ã•ã‚ŒãŸã‚¢ãƒã‚¿ãƒ¼ãŒé¸æŠã•ã‚Œã¦ã„ãŸãŸã‚ã€Œã™ã¹ã¦ã€ã«ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ');
            }
            
            console.log('updateAvatarFilterOptions() å®Ÿè¡Œå®Œäº†');
        }

        
        // æ¤œç´¢ãƒœãƒƒã‚¯ã‚¹ãƒ†ã‚¹ãƒˆç”¨
        function testInput() {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.style.border = '3px solid red';
                searchInput.focus();
                alert('ç”»é¢ä¸Šéƒ¨ã®æ¤œç´¢ãƒœãƒƒã‚¯ã‚¹ï¼ˆèµ¤æ ï¼‰ã§æ–‡å­—å…¥åŠ›ã‚’è©¦ã—ã¦ãã ã•ã„ã€‚å…¥åŠ›ã§ãã‚‹ã‹ç¢ºèªã—ã¦ã‹ã‚‰æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã«é€²ã¿ã¾ã™ã€‚');
                
                // 5ç§’å¾Œã«ãƒœãƒ¼ãƒ€ãƒ¼ã‚’å…ƒã«æˆ»ã™
                setTimeout(() => {
                    searchInput.style.border = '1px solid #6b7280';
                }, 5000);
            }
        }

        // ãƒ•ã‚¡ã‚¤ãƒ«åã‚’æ­£è¦åŒ–ã™ã‚‹çµ±ä¸€é–¢æ•°
        function normalizeFileName(fileName) {
            // æ‹¡å¼µå­ã‚’é™¤å»ï¼ˆ.unitypackage, .zip, .rar, .7z ãªã©ï¼‰
            let name = fileName.replace(/\.(unitypackage|zip|rar|7z|tar|gz)$/i, '');
            
            // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·ã€æ—¥ä»˜ã€ä¿®æ­£æƒ…å ±ã‚’é™¤å»
            name = name
                .replace(/_?v?\d+\.\d+.*$/i, '') // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç•ªå·
                .replace(/_?\d{8}.*$/i, '') // æ—¥ä»˜
                .replace(/_?(fix|final|update|patch).*$/i, '') // ä¿®æ­£ãƒ»æ›´æ–°æƒ…å ±
                .replace(/[\[\]()ï¼ˆï¼‰]/g, '') // æ‹¬å¼§é™¤å»
                .replace(/[_-]+/g, ' ') // ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã¨ãƒã‚¤ãƒ•ãƒ³ã‚’ã‚¹ãƒšãƒ¼ã‚¹ã«çµ±ä¸€
                .replace(/\s+/g, ' ') // é€£ç¶šã‚¹ãƒšãƒ¼ã‚¹ã‚’å˜ä¸€ã‚¹ãƒšãƒ¼ã‚¹ã«
                .trim(); // å‰å¾Œã®ç©ºç™½é™¤å»
                
            return name;
        }
        
        // æ¤œç´¢ç”¨ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æŠ½å‡ºã™ã‚‹é–¢æ•°
        function extractSearchKeywords(fileName) {
            const normalizedName = normalizeFileName(fileName);
            const keywords = normalizedName.split(/\s+/).filter(word => word.length > 1);
            return {
                normalizedName: normalizedName,
                keywords: keywords,
                originalFileName: fileName
            };
        }
        
        // ãƒ•ã‚¡ã‚¤ãƒ«åã®é¡ä¼¼åº¦ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°ï¼ˆã‚ã„ã¾ã„æ¤œç´¢ç”¨ï¼‰
        function calculateSimilarity(str1, str2) {
            // ä¸¡æ–¹ã‚’æ­£è¦åŒ–ã—ã¦æ¯”è¼ƒ
            const norm1 = normalizeFileName(str1).toLowerCase();
            const norm2 = normalizeFileName(str2).toLowerCase();
            
            // å®Œå…¨ä¸€è‡´
            if (norm1 === norm2) return 1.0;
            
            // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã®é¡ä¼¼åº¦è¨ˆç®—
            const words1 = norm1.split(/\s+/).filter(w => w.length > 1);
            const words2 = norm2.split(/\s+/).filter(w => w.length > 1);
            
            if (words1.length === 0 || words2.length === 0) return 0;
            
            let matchCount = 0;
            for (const word1 of words1) {
                for (const word2 of words2) {
                    // å®Œå…¨ä¸€è‡´ã¾ãŸã¯éƒ¨åˆ†ä¸€è‡´
                    if (word1.includes(word2) || word2.includes(word1)) {
                        matchCount++;
                        break;
                    }
                }
            }
            
            return matchCount / Math.max(words1.length, words2.length);
        }

        // ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æŠ½å‡ºã™ã‚‹é–¢æ•°
        function extractKeywords(text) {
            const keywords = [];
            
            // æ—¥æœ¬èªãƒ»è‹±èªãƒ»æ•°å­—ã‚’æŠ½å‡º
            const matches = text.match(/[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF\w]+/g) || [];
            
            for (const match of matches) {
                // 3æ–‡å­—ä»¥ä¸Šã§ã€æ•°å­—ã®ã¿ã§ãªã„ã‚‚ã®
                if (match.length >= 3 && !/^\d+$/.test(match)) {
                    keywords.push(match.toLowerCase());
                }
            }
            
            return keywords;
        }
        
        // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã¨ã®ã‚ã„ã¾ã„æ¤œç´¢ã‚’è¡Œã†é–¢æ•°
        async function searchWithFuzzyMatching(targetFileName) {
            try {
                // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®æ¤œç´¢æ©Ÿèƒ½ã‚’ä½¿ç”¨ï¼ˆæ—¢ã«ãƒ•ã‚¡ã‚¸ãƒ¼ãƒãƒƒãƒãƒ³ã‚°æ©Ÿèƒ½ãŒå®Ÿè£…æ¸ˆã¿ï¼‰
                const result = await window.electronAPI.booth.searchByFilename(targetFileName);
                return result;
                
            } catch (error) {
                return { success: false, results: [], error: error.message };
            }
        }

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ï¼ˆtagInputå€¤ä¿å­˜ç”¨ï¼‰
        function setupGlobalEventListeners() {
            document.addEventListener('input', function(e) {
                // tagInputã®å ´åˆã¯å€¤ã‚’ä¿å­˜ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ï¼‰
                if (e.target.id === 'tagInput') {
                    window.lastTagInputValue = e.target.value;
                    return;
                }
            }, true);
        }

        // å•†å“ã®ç„¡åŠ¹ãªã‚¢ãƒã‚¿ãƒ¼IDã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        function cleanupInvalidAvatarIds(product) {
            if (!product.avatar_ids || product.avatar_ids.trim() === '') return product;
            
            const validAvatarIds = getAllAvatars().map(avatar => avatar.id.toString());
            const currentAvatarIds = product.avatar_ids.split(',').map(id => id.trim()).filter(id => id);
            const cleanedAvatarIds = currentAvatarIds.filter(id => validAvatarIds.includes(id));
            
            return {
                ...product,
                avatar_ids: cleanedAvatarIds.join(',')
            };
        }

        // ã‚¢ãƒã‚¿ãƒ¼é¸æŠè‚¢ã‚’æ›´æ–°
        function updateAvatarSelects() {
            const allAvatars = getAllAvatars();
            
            // å•†å“ç™»éŒ²ãƒ•ã‚©ãƒ¼ãƒ å†…ã®ã‚¢ãƒã‚¿ãƒ¼ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’æ›´æ–°
            const avatarCheckboxes = document.getElementById('avatarCheckboxes');
            avatarCheckboxes.innerHTML = '';
            
            if (allAvatars.length === 0) {
                avatarCheckboxes.innerHTML = '<p style="color: #9ca3af; margin: 0;">ã‚¢ãƒã‚¿ãƒ¼ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“</p>';
            } else {
                allAvatars.forEach(avatar => {
                    const label = document.createElement('label');
                    label.style.display = 'flex';
                    label.style.alignItems = 'center';
                    label.style.gap = '8px';
                    label.style.color = 'white';
                    label.style.cursor = 'pointer';
                    label.style.marginBottom = '5px';
                    
                    label.innerHTML = `
                        <input type="checkbox" value="${avatar.id}" style="width: 16px; height: 16px;">
                        <span>${avatar.name}</span>
                    `;
                    
                    avatarCheckboxes.appendChild(label);
                });
            }
            
            updateTagCheckboxes();
            updateAvatarFilterSelect();
        }
        
        // ã‚«ãƒ†ã‚´ãƒªå¤‰æ›´æ™‚ã®å‡¦ç†
        function handleCategoryChange() {
            const categorySelect = document.getElementById('productCategory');
            const selectedCategory = categorySelect.value;
            
            // ã‚«ãƒ†ã‚´ãƒªãŒã‚¢ãƒã‚¿ãƒ¼æœ¬ä½“ã®å ´åˆã€ã‚¢ãƒã‚¿ãƒ¼ãƒªã‚¹ãƒˆã‚’æ›´æ–°ã—ã¦ãƒ¢ãƒ¼ãƒ€ãƒ«ã«åæ˜ 
            if (selectedCategory === 'ã‚¢ãƒã‚¿ãƒ¼æœ¬ä½“') {
                // ç¾åœ¨ç·¨é›†ä¸­ã®å•†å“æƒ…å ±ãŒã‚ã‚‹ã‹ç¢ºèª
                const productIdInput = document.querySelector('#productForm input[name="id"]');
                const currentProductId = productIdInput ? productIdInput.value : null;
                
                // å•†å“åã‚’å–å¾—
                const productNameInput = document.getElementById('productName');
                const productName = productNameInput ? productNameInput.value : '';
                
                if (productName && !currentProductId) {
                    // æ–°è¦ç™»éŒ²ã§ã‚¢ãƒã‚¿ãƒ¼æœ¬ä½“ã‚«ãƒ†ã‚´ãƒªã®å ´åˆã€ã‚¢ãƒã‚¿ãƒ¼ãƒã‚¹ã‚¿ãƒ¼ã«è¿½åŠ 
                    const newAvatar = {
                        id: Date.now(),
                        name: productName,
                        created_at: new Date().toISOString()
                    };
                    
                    // ãƒ­ãƒ¼ã‚«ãƒ«ã®ã‚¢ãƒã‚¿ãƒ¼é…åˆ—ã«è¿½åŠ 
                    if (!avatars.some(a => a.name === productName)) {
                        avatars.push(newAvatar);
                        
                        // ã‚¢ãƒã‚¿ãƒ¼ãƒã‚¹ã‚¿ãƒ¼ã«ç™»éŒ²ï¼ˆéåŒæœŸï¼‰
                        if (window.electronAPI && window.electronAPI.database) {
                            window.electronAPI.database.addAvatar(newAvatar).then(() => {
                                console.log('ã‚¢ãƒã‚¿ãƒ¼ãƒã‚¹ã‚¿ãƒ¼ã«è¿½åŠ :', productName);
                            }).catch(error => {
                                console.error('ã‚¢ãƒã‚¿ãƒ¼è¿½åŠ ã‚¨ãƒ©ãƒ¼:', error);
                            });
                        }
                    }
                }
                
                // ã‚¢ãƒã‚¿ãƒ¼ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’å³åº§ã«æ›´æ–°
                updateAvatarCheckboxesImmediate();
            }
        }
        
        // ã‚¢ãƒã‚¿ãƒ¼ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’å³åº§ã«æ›´æ–°ã™ã‚‹é–¢æ•°
        function updateAvatarCheckboxesImmediate() {
            const allAvatars = getAllAvatars();
            const avatarCheckboxes = document.getElementById('avatarCheckboxes');
            
            // ç¾åœ¨é¸æŠã•ã‚Œã¦ã„ã‚‹ã‚¢ãƒã‚¿ãƒ¼IDã‚’ä¿æŒ
            const selectedAvatarIds = [];
            const currentCheckboxes = document.querySelectorAll('#avatarCheckboxes input[type="checkbox"]:checked');
            currentCheckboxes.forEach(checkbox => {
                selectedAvatarIds.push(checkbox.value);
            });
            
            // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’å†æ§‹ç¯‰
            avatarCheckboxes.innerHTML = '';
            
            if (allAvatars.length === 0) {
                avatarCheckboxes.innerHTML = '<p style="color: #9ca3af; margin: 0;">ã‚¢ãƒã‚¿ãƒ¼ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“</p>';
            } else {
                allAvatars.forEach(avatar => {
                    const label = document.createElement('label');
                    label.style.display = 'flex';
                    label.style.alignItems = 'center';
                    label.style.gap = '8px';
                    label.style.color = 'white';
                    label.style.cursor = 'pointer';
                    label.style.marginBottom = '5px';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = avatar.id;
                    checkbox.style.width = '16px';
                    checkbox.style.height = '16px';
                    
                    // ä»¥å‰é¸æŠã•ã‚Œã¦ã„ãŸã‚‚ã®ã¯é¸æŠçŠ¶æ…‹ã‚’ç¶­æŒ
                    if (selectedAvatarIds.includes(avatar.id.toString())) {
                        checkbox.checked = true;
                    }
                    
                    const span = document.createElement('span');
                    span.textContent = avatar.name;
                    
                    label.appendChild(checkbox);
                    label.appendChild(span);
                    avatarCheckboxes.appendChild(label);
                });
            }
        }
        
        // ã‚¿ã‚°ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’æ›´æ–°
        function updateTagCheckboxes() {
            const allTags = getAllTags();
            
            // å•†å“ç™»éŒ²ãƒ•ã‚©ãƒ¼ãƒ å†…ã®ã‚¿ã‚°ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’æ›´æ–°
            const tagCheckboxes = document.getElementById('tagCheckboxes');
            tagCheckboxes.innerHTML = '';
            
            if (allTags.length === 0) {
                tagCheckboxes.innerHTML = '<p style="color: #9ca3af; margin: 0;">ã¾ã ã‚¿ã‚°ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“</p>';
            } else {
                allTags.forEach(tag => {
                    const label = document.createElement('label');
                    label.style.display = 'flex';
                    label.style.alignItems = 'center';
                    label.style.gap = '8px';
                    label.style.color = 'white';
                    label.style.cursor = 'pointer';
                    label.style.marginBottom = '5px';
                    
                    label.innerHTML = `
                        <input type="checkbox" value="${tag}" style="width: 16px; height: 16px;">
                        <span>${tag}</span>
                    `;
                    
                    tagCheckboxes.appendChild(label);
                });
            }
        }
        
        // ãƒ•ã‚£ãƒ«ã‚¿ç”¨ã®ã‚¢ãƒã‚¿ãƒ¼é¸æŠè‚¢ã®ã¿ã‚’æ›´æ–°
        function updateAvatarFilterSelect() {
            const allAvatars = getAllAvatars();
            
            // ãƒ•ã‚£ãƒ«ã‚¿ç”¨ã®ã‚¢ãƒã‚¿ãƒ¼é¸æŠè‚¢ã‚’æ›´æ–°
            const avatarSelect = document.getElementById('avatarSelect');
            const currentValue = avatarSelect.value; // ç¾åœ¨é¸æŠã•ã‚Œã¦ã„ã‚‹å€¤ã‚’ä¿æŒ
            avatarSelect.innerHTML = '<option value="all">ã™ã¹ã¦</option>';
            
            allAvatars.forEach(avatar => {
                const option = document.createElement('option');
                option.value = avatar.id;
                option.textContent = avatar.name;
                avatarSelect.appendChild(option);
            });
            
            // é¸æŠå€¤ã‚’å¾©å…ƒ
            if (currentValue) {
                avatarSelect.value = currentValue;
            }
        }
        
        // å…¨å•†å“ã‹ã‚‰ã‚¿ã‚°ãƒªã‚¹ãƒˆã‚’å–å¾—
        function getAllTags() {
            const allTags = new Set();
            
            products.forEach(product => {
                if (product.tags && product.tags.trim() !== '') {
                    const productTags = product.tags.split(',').map(tag => tag.trim()).filter(tag => tag);
                    productTags.forEach(tag => allTags.add(tag));
                }
            });
            
            return Array.from(allTags).sort();
        }
        
        // ã‚¿ã‚°ãƒ•ã‚£ãƒ«ã‚¿é¸æŠè‚¢ã‚’æ›´æ–°
        function updateTagFilterSelect() {
            const allTags = getAllTags();
            
            // ã‚¿ã‚°ãƒ•ã‚£ãƒ«ã‚¿ã®é¸æŠè‚¢ã‚’æ›´æ–°
            const tagSelect = document.getElementById('tagSelect');
            const currentValue = tagSelect.value; // ç¾åœ¨é¸æŠã•ã‚Œã¦ã„ã‚‹å€¤ã‚’ä¿æŒ
            tagSelect.innerHTML = '<option value="all">ã™ã¹ã¦</option>';
            
            allTags.forEach(tag => {
                const option = document.createElement('option');
                option.value = tag;
                option.textContent = tag;
                tagSelect.appendChild(option);
            });
            
            // é¸æŠå€¤ã‚’å¾©å…ƒ
            if (currentValue && allTags.includes(currentValue)) {
                tagSelect.value = currentValue;
            }
        }

        // ãƒ•ã‚£ãƒ«ã‚¿ãƒ»ã‚½ãƒ¼ãƒˆæ©Ÿèƒ½
        function filterProducts() {
            // ãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ã‚«ãƒ†ã‚´ãƒªã‚’å–å¾—
            const checkedCategories = [];
            const checkboxes = ['filter_avatar', 'filter_costume', 'filter_accessory', 'filter_hair', 'filter_other', 'filter_tool', 'filter_pose', 'filter_world', 'filter_zip_extracted'];
            
            checkboxes.forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox && checkbox.checked) {
                    checkedCategories.push(checkbox.value);
                }
            });
            
            
            // ã‚«ãƒ†ã‚´ãƒªãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            let filteredProducts = products.filter(product => {
                // ã‚«ãƒ†ã‚´ãƒªãŒç©ºã®å ´åˆã¯ã€Œãã®ä»–ã€ã¨ã—ã¦æ‰±ã†
                const productCategory = product.category || 'ãã®ä»–';
                const hasCategory = checkedCategories.includes(productCategory);
                if (!hasCategory && product.category === '') {
                }
                return hasCategory;
            });
            
            
            // æ¤œç´¢ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            if (searchQuery) {
                filteredProducts = filteredProducts.filter(product => {
                    const searchFields = [
                        product.name || '',
                        product.description || '',
                        product.tags || ''
                    ].join(' ').toLowerCase();
                    
                    return searchFields.includes(searchQuery);
                });
            }
            
            // ã‚¢ãƒã‚¿ãƒ¼ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            const selectedAvatar = document.getElementById('avatarSelect')?.value;
            if (selectedAvatar && selectedAvatar !== 'all') {
                const validAvatarIds = getAllAvatars().map(avatar => avatar.id.toString());
                filteredProducts = filteredProducts.filter(product => {
                    if (!product.avatar_ids || product.avatar_ids.trim() === '') return false;
                    const avatarIds = product.avatar_ids.split(',').map(id => id.trim()).filter(id => id && validAvatarIds.includes(id));
                    return avatarIds.includes(selectedAvatar);
                });
            }
            
            // ã‚¿ã‚°ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            const selectedTag = document.getElementById('tagSelect')?.value;
            if (selectedTag && selectedTag !== 'all') {
                filteredProducts = filteredProducts.filter(product => {
                    if (!product.tags || product.tags.trim() === '') return false;
                    const productTags = product.tags.split(',').map(tag => tag.trim()).filter(tag => tag);
                    return productTags.includes(selectedTag);
                });
            }
            
            // ä¸¦ã³é †é©ç”¨
            const orderSelect = document.getElementById('orderSelect');
            if (orderSelect) {
                currentSortOrder = orderSelect.value; // ç¾åœ¨ã®ä¸¦ã³é †ã‚’ä¿å­˜
            }
            const orderType = currentSortOrder || 'created_desc';
            
            filteredProducts.sort((a, b) => {
                switch (orderType) {
                    case 'created_desc':
                        return new Date(b.created_at) - new Date(a.created_at);
                    case 'created_asc':
                        return new Date(a.created_at) - new Date(b.created_at);
                    default:
                        return 0;
                }
            });
            
            renderProducts(filteredProducts);
            
            // ãƒ•ã‚£ãƒ«ã‚¿ç”¨ã®é¸æŠè‚¢ã¯å¸¸ã«æ›´æ–°
            updateAvatarFilterSelect();
            updateTagFilterSelect();
            
            // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ã¦ã„ãªã„å ´åˆã®ã¿ãƒ•ã‚©ãƒ¼ãƒ å†…ã®ã‚¢ãƒã‚¿ãƒ¼ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’æ›´æ–°
            const productModal = document.getElementById('productModal');
            if (!productModal || productModal.style.display !== 'block') {
                updateAvatarSelects();
            }
        }

        // å•†å“ä¸€è¦§ã‚’è¡¨ç¤º
        function renderProducts(productsToRender = products) {
            const container = document.getElementById('products');
            container.innerHTML = '';
            container.className = isListView ? 'list' : 'grid';
            
            productsToRender.forEach(product => {
                const item = document.createElement('div');
                item.className = isListView ? 'list-item' : 'card';
                item.setAttribute('data-product-id', product.id);
                
                if (isListView) {
                    item.innerHTML = `
                        <input type="checkbox" class="item-checkbox" ${selectedProducts.has(product.id) ? 'checked' : ''} readonly>
                        <div class="item-thumbnail" onclick="toggleProductSelection(${product.id})">
                            ${product.thumbnail_url ? 
                                `<img src="${product.thumbnail_url}" alt="${product.name}" style="width: 100%; height: 100%; object-fit: cover;" draggable="false">` : 
                                '<div style="display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; color: #9ca3af; font-size: 11px;">ç”»åƒãªã—</div>'
                            }
                        </div>
                        <div class="item-content" onclick="openProductDetail(${product.id})">
                            <div class="item-title" title="${product.name}">${product.name}</div>
                            <div class="item-info">ã‚«ãƒ†ã‚´ãƒª: ${product.category}</div>
                        </div>
                        <div class="item-actions">
                            ${product.file_path ? 
                                `<button class="btn btn-blue" onclick="openFile(event, '${product.file_path.replace(/\\/g, '\\\\')}', ${product.id})">Unity${product.file_paths && product.file_paths.includes('|') ? ' â–¼' : ''}</button>` : ''
                            }
                            <button class="btn btn-yellow" onclick="editProduct(event, ${product.id})">ç·¨é›†</button>
                            <button class="btn btn-red" onclick="deleteProduct(event, ${product.id})">å‰Šé™¤</button>
                        </div>
                    `;
                } else {
                    item.innerHTML = `
                        <input type="checkbox" class="item-checkbox" ${selectedProducts.has(product.id) ? 'checked' : ''} readonly style="position: absolute; top: 8px; left: 8px; width: 16px; height: 16px; z-index: 10;">
                        <div class="card-image" onclick="toggleProductSelection(${product.id})">
                            ${product.thumbnail_url ? 
                                `<img src="${product.thumbnail_url}" alt="${product.name}" draggable="false">` : 
                                '<span style="color: #9ca3af;">ç”»åƒãªã—</span>'
                            }
                        </div>
                        <div class="card-content" onclick="openProductDetail(${product.id})">
                            <div class="card-title" title="${product.name}">${product.name}</div>
                            <div class="buttons">
                                ${product.file_path ? 
                                    `<button class="btn btn-blue" onclick="openFile(event, '${product.file_path.replace(/\\/g, '\\\\')}', ${product.id})">Unity${product.file_paths && product.file_paths.includes('|') ? ' â–¼' : ''}</button>` : ''
                                }
                                <button class="btn btn-yellow" onclick="editProduct(event, ${product.id})">ç·¨é›†</button>
                                <button class="btn btn-red" onclick="deleteProduct(event, ${product.id})">å‰Šé™¤</button>
                            </div>
                        </div>
                    `;
                }
                
                container.appendChild(item);
            });
            
            updateSelectionBlock();
        }

        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
        async function openFile(event, filePath, productId) {
            if (event) event.stopPropagation();
            
            
            if (!filePath || filePath.trim() === '') {
                alert('ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            
            // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒã¤å•†å“ã®å ´åˆã€é¸æŠãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è¡¨ç¤º
            if (productId) {
                try {
                    const products = await window.electronAPI.database.getProducts();
                    const product = products.find(p => p.id === productId);
                    if (product && product.file_paths && product.file_paths.includes('|')) {
                        // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆã€é¸æŠãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è¡¨ç¤º
                        showFileSelectionMenu(event, product);
                        return;
                    }
                } catch (error) {
                    console.error('å•†å“ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
                }
            }
            
            if (window.electronAPI) {
                try {
                    
                    // ãƒ•ã‚¡ã‚¤ãƒ«å­˜åœ¨ç¢ºèª
                    const fileExists = await window.electronAPI.fs.exists(filePath);
                    
                    if (!fileExists) {
                        alert(`ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${filePath}`);
                        return;
                    }
                    
                    await window.electronAPI.shell.openFile(filePath);
                } catch (error) {
                    console.error('ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ¼ãƒ—ãƒ³ã‚¨ãƒ©ãƒ¼:', error);
                    console.error('Failed file path:', filePath);
                    
                    // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚ˆã‚Šåˆ†ã‹ã‚Šã‚„ã™ãè¡¨ç¤º
                    if (error.message && error.message.includes('Unity')) {
                        alert(error.message);
                    } else {
                        alert(`ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã‘ã¾ã›ã‚“ã§ã—ãŸ:\n${error.message || error}\n\nå¯¾å‡¦æ³•:\n1. Unity HubãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª\n2. Unityãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’é–‹ã„ã¦ã‹ã‚‰å†åº¦ãŠè©¦ã—ãã ã•ã„`);
                    }
                }
            } else {
                alert('Electron APIãŒåˆ©ç”¨ã§ãã¾ã›ã‚“');
            }
        }

        let currentEditingProductId = null;
        
        // æ–°ã—ã„ã‚¿ã‚°ã‚’è¿½åŠ 
        function addNewTag() {
            const newTagInput = document.getElementById('newTagInput');
            const newTag = newTagInput.value.trim();
            
            if (newTag === '') {
                alert('ã‚¿ã‚°åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            // æ—¢å­˜ã‚¿ã‚°ã¨ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
            const allTags = getAllTags();
            if (allTags.includes(newTag)) {
                alert('æ—¢ã«å­˜åœ¨ã™ã‚‹ã‚¿ã‚°ã§ã™');
                return;
            }
            
            // æ–°ã—ã„ã‚¿ã‚°ã‚’æ‰‹å‹•ã§ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãƒªã‚¹ãƒˆã«è¿½åŠ 
            const tagCheckboxes = document.getElementById('tagCheckboxes');
            
            // æ—¢å­˜ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‰Šé™¤
            if (tagCheckboxes.innerHTML.includes('ã¾ã ã‚¿ã‚°ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“')) {
                tagCheckboxes.innerHTML = '';
            }
            
            // æ–°ã—ã„ã‚¿ã‚°ã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’ä½œæˆ
            const label = document.createElement('label');
            label.style.display = 'flex';
            label.style.alignItems = 'center';
            label.style.gap = '8px';
            label.style.color = 'white';
            label.style.cursor = 'pointer';
            label.style.marginBottom = '5px';
            
            label.innerHTML = `
                <input type="checkbox" value="${newTag}" checked style="width: 16px; height: 16px;">
                <span>${newTag}</span>
            `;
            
            tagCheckboxes.appendChild(label);
            
            // å…¥åŠ›æ¬„ã‚’ã‚¯ãƒªã‚¢
            newTagInput.value = '';
            
        }
        
        // æ¤œç´¢æ©Ÿèƒ½
        function searchProducts() {
            searchQuery = document.getElementById('searchInput').value.toLowerCase().trim();
            filterProducts();
        }
        
        // æ¤œç´¢ã‚’ã‚¯ãƒªã‚¢
        function clearSearch() {
            document.getElementById('searchInput').value = '';
            searchQuery = '';
            filterProducts();
        }

        // è©³ç´°ç”»é¢ã‹ã‚‰ç·¨é›†
        function editProductFromDetail(event, productId) {
            event.stopPropagation();
            closeDetailModal(); // è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
            editProduct(event, productId);
        }

        // å•†å“ã‚’ç·¨é›†
        function editProduct(event, productId) {
            event.stopPropagation();
            const product = products.find(p => p.id === productId);
            if (product) {
                currentEditingProductId = productId;
                document.getElementById('modalTitle').textContent = 'å•†å“ã‚’ç·¨é›†';
                document.getElementById('productName').value = product.name || '';
                document.getElementById('productCategory').value = product.category || '';
                document.getElementById('productBoothUrl').value = product.booth_url || '';
                document.getElementById('productThumbnailUrl').value = product.thumbnail_url || '';
                showThumbnailPreview(product.thumbnail_url || '');
                document.getElementById('productFilePath').value = product.file_path || '';
                
                // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚‹å ´åˆã®è¡¨ç¤º
                
                if (product.file_paths && product.file_paths.includes('|')) {
                    const filePaths = product.file_paths.split('|').filter(path => path.trim());
                    const displayNames = product.display_names ? product.display_names.split('|').filter(name => name.trim()) : null;
                    displayMultipleFiles(filePaths, displayNames);
                } else if (product.file_paths && product.file_paths.trim()) {
                    // file_pathsãŒã‚ã‚‹ãŒåŒºåˆ‡ã‚Šæ–‡å­—ãŒãªã„å ´åˆï¼ˆå˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰
                    const filePaths = [product.file_paths.trim()];
                    const displayNames = product.display_names ? [product.display_names.trim()] : null;
                    displayMultipleFiles(filePaths, displayNames);
                } else {
                    // å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆã¯è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã‚¨ãƒªã‚¢ã‚’éè¡¨ç¤º
                    document.getElementById('multipleFilesArea').style.display = 'none';
                }
                
                document.getElementById('productDescription').value = product.description || '';
                
                // å¯¾å¿œã‚¢ãƒã‚¿ãƒ¼ã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’è¨­å®š
                const productAvatarIds = product.avatar_ids ? product.avatar_ids.split(',').map(id => id.trim()).filter(id => id) : [];
                const avatarCheckboxes = document.querySelectorAll('#avatarCheckboxes input[type="checkbox"]');
                avatarCheckboxes.forEach(checkbox => {
                    checkbox.checked = productAvatarIds.includes(checkbox.value);
                });
                
                // ã‚¿ã‚°ã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’è¨­å®š
                const productTags = product.tags ? product.tags.split(',').map(tag => tag.trim()).filter(tag => tag) : [];
                const tagCheckboxes = document.querySelectorAll('#tagCheckboxes input[type="checkbox"]');
                tagCheckboxes.forEach(checkbox => {
                    checkbox.checked = productTags.includes(checkbox.value);
                });
                
                // ç·¨é›†ç”¨ã‚¿ã‚°ã‚»ãƒƒãƒˆã‚’åˆæœŸåŒ–
                selectedTagsForEditing.clear();
                productTags.forEach(tag => selectedTagsForEditing.add(tag));
                
                document.getElementById('productModal').style.display = 'block';
                
                // ã‚¿ã‚°è¡¨ç¤ºã‚’æ›´æ–°
                setTimeout(() => {
                    updateTagsDisplay();
                    // ã‚¿ã‚°å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä¿®æ­£
                    const tagInput = document.getElementById('tagInput');
                    if (tagInput) {
                        tagInput.style.pointerEvents = 'auto';
                        tagInput.style.userSelect = 'text';
                        tagInput.disabled = false;
                        tagInput.readOnly = false;
                        tagInput.value = '';
                        tagInput.focus();
                    }
                }, 50);
            
            // ãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã®ã™ã¹ã¦ã®å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å®Œå…¨ã«ä¿®æ­£
            setTimeout(() => {
                const modalInputs = document.querySelectorAll('#productModal input[type="text"], #productModal input[type="url"], #productModal textarea');
                
                modalInputs.forEach((field, index) => {
                    // åŸºæœ¬ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¨­å®š
                    field.disabled = false;
                    field.readOnly = false;
                    field.tabIndex = 0;
                    
                    // CSSã‚’å®Œå…¨ã«ãƒªã‚»ãƒƒãƒˆ
                    field.style.cssText = field.style.cssText + '; pointer-events: auto !important; user-select: text !important; cursor: text !important;';
                    
                    // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ã‚¯ãƒªã‚¢
                    field.onclick = null;
                    field.onmousedown = null;
                    field.onfocus = null;
                    field.onblur = null;
                    
                    // æ–°ã—ã„ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
                    field.addEventListener('click', function(e) {
                        e.stopPropagation();
                        this.focus();
                    }, true);
                    
                    field.addEventListener('mousedown', function(e) {
                        e.stopPropagation();
                    }, true);
                });
            }, 100);
                
                // ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤ºå¾Œã«æœ€åˆã®å…¥åŠ›æ¬„ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
                setTimeout(() => {
                    const nameInput = document.getElementById('productName');
                    if (nameInput) {
                        nameInput.focus();
                        nameInput.select(); // ç·¨é›†æ™‚ã¯å…¨é¸æŠ
                    }
                }, 100);
            }
        }

        // å•†å“ã‚’å‰Šé™¤
        async function deleteProduct(event, productId) {
            event.stopPropagation();
            if (confirm('ã“ã®å•†å“ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
                try {
                    if (window.electronAPI) {
                        // å‰Šé™¤å‰ã«å•†å“æƒ…å ±ã‚’ä¿æŒ
                        const deletedProduct = products.find(p => p.id === productId);
                        console.log('å‰Šé™¤ã™ã‚‹å•†å“:', deletedProduct);
                        
                        await window.electronAPI.database.deleteProduct(productId);
                        
                        // ã‚¢ãƒã‚¿ãƒ¼æœ¬ä½“ãŒå‰Šé™¤ã•ã‚ŒãŸå ´åˆã¯ã€avatarsé…åˆ—ã¨ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰ã‚‚å‰Šé™¤
                        if (deletedProduct && deletedProduct.category === 'ã‚¢ãƒã‚¿ãƒ¼æœ¬ä½“') {
                            console.log('ã‚¢ãƒã‚¿ãƒ¼æœ¬ä½“ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚avatarsé…åˆ—ã¨ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰ã‚‚å‰Šé™¤ã—ã¾ã™ã€‚');
                            
                            // avatarsé…åˆ—ã‹ã‚‰è©²å½“ã™ã‚‹ã‚¢ãƒã‚¿ãƒ¼ã‚’å‰Šé™¤
                            const avatarIndex = avatars.findIndex(avatar => 
                                avatar.id === deletedProduct.id || avatar.name === deletedProduct.name
                            );
                            if (avatarIndex !== -1) {
                                console.log('avatarsé…åˆ—ã‹ã‚‰ã‚¢ãƒã‚¿ãƒ¼ã‚’å‰Šé™¤:', avatars[avatarIndex]);
                                const avatarToDelete = avatars[avatarIndex];
                                
                                // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰ã‚‚ã‚¢ãƒã‚¿ãƒ¼ã‚’å‰Šé™¤
                                try {
                                    await window.electronAPI.database.deleteAvatar(avatarToDelete.id);
                                    console.log('ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰ã‚¢ãƒã‚¿ãƒ¼ã‚’å‰Šé™¤ã—ã¾ã—ãŸ:', avatarToDelete.id);
                                } catch (error) {
                                    console.error('ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰ã‚¢ãƒã‚¿ãƒ¼å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
                                }
                                
                                // ãƒ­ãƒ¼ã‚«ãƒ«é…åˆ—ã‹ã‚‰ã‚‚å‰Šé™¤
                                avatars.splice(avatarIndex, 1);
                            }
                        }
                        
                        await loadProducts();
                        
                        // ã‚¢ãƒã‚¿ãƒ¼æœ¬ä½“ãŒå‰Šé™¤ã•ã‚ŒãŸå ´åˆã¯ã‚¢ãƒã‚¿ãƒ¼é–¢é€£ã®UIè¦ç´ ã‚’æ›´æ–°
                        if (deletedProduct && deletedProduct.category === 'ã‚¢ãƒã‚¿ãƒ¼æœ¬ä½“') {
                            console.log('ã‚¢ãƒã‚¿ãƒ¼UIè¦ç´ ã‚’æ›´æ–°ã—ã¾ã™ã€‚');
                            
                            // å°‘ã—é…å»¶ã•ã›ã¦ã‹ã‚‰UIæ›´æ–°
                            setTimeout(() => {
                                // ã‚¢ãƒã‚¿ãƒ¼ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’æ›´æ–°
                                updateAvatarCheckboxesImmediate();
                                
                                // ãƒ•ã‚£ãƒ«ã‚¿ã®ã‚¢ãƒã‚¿ãƒ¼é¸æŠè‚¢ã‚’æ›´æ–°
                                updateAvatarFilterOptions();
                                
                                console.log('ã‚¢ãƒã‚¿ãƒ¼UIè¦ç´ ã®æ›´æ–°å®Œäº†');
                            }, 100);
                        }
                    }
                } catch (error) {
                    console.error('Failed to delete product:', error);
                    alert('å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error);
                }
            }
        }

        // å•†å“ã‚’è¿½åŠ 
        function addProduct() {
            currentEditingProductId = null;
            document.getElementById('modalTitle').textContent = 'å•†å“ã‚’è¿½åŠ ';
            document.getElementById('productForm').reset();
            
            // ã‚µãƒ ãƒã‚¤ãƒ« ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’éè¡¨ç¤ºã«ã™ã‚‹
            document.getElementById('thumbnailPreview').style.display = 'none';
            
            // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã‚¨ãƒªã‚¢ã‚’éè¡¨ç¤ºã«ã™ã‚‹
            document.getElementById('multipleFilesArea').style.display = 'none';
            
            // ã‚¢ãƒã‚¿ãƒ¼ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
            const avatarCheckboxes = document.querySelectorAll('#avatarCheckboxes input[type="checkbox"]');
            avatarCheckboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // ã‚¿ã‚°ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
            const tagCheckboxes = document.querySelectorAll('#tagCheckboxes input[type="checkbox"]');
            tagCheckboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // ç·¨é›†ç”¨ã‚¿ã‚°ã‚»ãƒƒãƒˆã‚’åˆæœŸåŒ–
            selectedTagsForEditing.clear();
            
            document.getElementById('productModal').style.display = 'block';
            
            // ã‚¿ã‚°è¡¨ç¤ºã‚’æ›´æ–°
            setTimeout(() => {
                updateTagsDisplay();
                // ã‚¿ã‚°å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä¿®æ­£
                const tagInput = document.getElementById('tagInput');
                if (tagInput) {
                    tagInput.style.pointerEvents = 'auto';
                    tagInput.style.userSelect = 'text';
                    tagInput.disabled = false;
                    tagInput.readOnly = false;
                    tagInput.value = '';
                }
            }, 50);
            
            // ãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã®ã™ã¹ã¦ã®å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å®Œå…¨ã«ä¿®æ­£
            setTimeout(() => {
                const modalInputs = document.querySelectorAll('#productModal input[type="text"], #productModal input[type="url"], #productModal textarea');
                
                modalInputs.forEach((field, index) => {
                    // åŸºæœ¬ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¨­å®š
                    field.disabled = false;
                    field.readOnly = false;
                    field.tabIndex = 0;
                    
                    // CSSã‚’å®Œå…¨ã«ãƒªã‚»ãƒƒãƒˆ
                    field.style.cssText = field.style.cssText + '; pointer-events: auto !important; user-select: text !important; cursor: text !important;';
                    
                    // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ã‚¯ãƒªã‚¢
                    field.onclick = null;
                    field.onmousedown = null;
                    field.onfocus = null;
                    field.onblur = null;
                    
                    // æ–°ã—ã„ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
                    field.addEventListener('click', function(e) {
                        e.stopPropagation();
                        this.focus();
                    }, true);
                    
                    field.addEventListener('mousedown', function(e) {
                        e.stopPropagation();
                    }, true);
                });
            }, 100);
            
            // ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤ºå¾Œã«æœ€åˆã®å…¥åŠ›æ¬„ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
            setTimeout(() => {
                const nameInput = document.getElementById('productName');
                if (nameInput) {
                    nameInput.focus();
                }
            }, 100);
        }

        // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeModal() {
            document.getElementById('productModal').style.display = 'none';
            currentEditingProductId = null;
        }

        // ãƒ•ã‚©ãƒ«ãƒ€ã‚ªãƒ—ã‚·ãƒ§ãƒ³é¸æŠãƒ€ã‚¤ã‚¢ãƒ­ã‚°ï¼ˆè‡ªå‹•çµ±åˆç‰ˆï¼‰
        function showFolderOptionDialog(unityPackageFiles, folderName) {
            // å¸¸ã«çµ±åˆï¼ˆunifyï¼‰ã‚’è¿”ã™
            return Promise.resolve('unify');
        }

        // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è¡¨ç¤º
        function showFileSelectionMenu(event, product) {
            // æ—¢å­˜ã®ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãŒã‚ã‚Œã°å‰Šé™¤
            const existingMenu = document.getElementById('fileSelectionMenu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’ä½œæˆ
            const menu = document.createElement('div');
            menu.id = 'fileSelectionMenu';
            menu.style.cssText = `
                position: absolute;
                background-color: #374151;
                border: 1px solid #4b5563;
                border-radius: 6px;
                padding: 8px 0;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
                z-index: 10000;
                min-width: 250px;
                max-width: 500px;
                white-space: nowrap;
            `;
            
            // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã¨è¡¨ç¤ºåã‚’å–å¾—
            const filePaths = product.file_paths.split('|').filter(path => path.trim());
            const displayNames = product.display_names ? 
                product.display_names.split('|').filter(name => name.trim()) : 
                filePaths.map(path => path.split(/[/\\]/).pop().replace('.unitypackage', ''));
            
            // ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®ã‚’è¿½åŠ 
            filePaths.forEach((filePath, index) => {
                const menuItem = document.createElement('div');
                menuItem.style.cssText = `
                    padding: 10px 16px;
                    cursor: pointer;
                    color: white;
                    font-size: 14px;
                    transition: background-color 0.2s;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    white-space: nowrap;
                    overflow: hidden;
                `;
                
                // ã‚¢ã‚¤ã‚³ãƒ³ã¨è¡¨ç¤ºå
                const icon = 'ğŸ“¦';
                const displayName = displayNames[index] || `ãƒ•ã‚¡ã‚¤ãƒ« ${index + 1}`;
                
                // é•·ã„ãƒ•ã‚¡ã‚¤ãƒ«åã‚’çœç•¥
                const truncatedName = displayName.length > 30 ? 
                    displayName.substring(0, 27) + '...' : 
                    displayName;
                
                menuItem.innerHTML = `
                    <span style="color: #9ca3af; font-size: 14px; flex-shrink: 0;">${icon}</span>
                    <span style="flex: 1; overflow: hidden; text-overflow: ellipsis;" title="${displayName}">${truncatedName}</span>
                `;
                
                // ãƒ›ãƒãƒ¼åŠ¹æœ
                menuItem.addEventListener('mouseenter', () => {
                    menuItem.style.backgroundColor = '#4b5563';
                });
                menuItem.addEventListener('mouseleave', () => {
                    menuItem.style.backgroundColor = '';
                });
                
                // ã‚¯ãƒªãƒƒã‚¯ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
                menuItem.addEventListener('click', async () => {
                    menu.remove();
                    
                    // ãƒ•ã‚¡ã‚¤ãƒ«å­˜åœ¨ç¢ºèª
                    const fileExists = await window.electronAPI.fs.exists(filePath);
                    
                    if (!fileExists) {
                        alert(`ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${filePath}`);
                        return;
                    }
                    
                    await window.electronAPI.shell.openFile(filePath);
                });
                
                menu.appendChild(menuItem);
            });
            
            // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ä½ç½®ã‚’è¨­å®šï¼ˆãƒœã‚¿ãƒ³ã®ä¸‹ã«è¡¨ç¤ºï¼‰
            const button = event.target;
            const rect = button.getBoundingClientRect();
            menu.style.left = `${rect.left}px`;
            menu.style.top = `${rect.bottom + 5}px`;
            
            // ç”»é¢å¤–ã«ã¯ã¿å‡ºã‚‹å ´åˆã®èª¿æ•´
            document.body.appendChild(menu);
            const menuRect = menu.getBoundingClientRect();
            if (menuRect.right > window.innerWidth) {
                menu.style.left = `${window.innerWidth - menuRect.width - 10}px`;
            }
            if (menuRect.bottom > window.innerHeight) {
                menu.style.top = `${rect.top - menuRect.height - 5}px`;
            }
            
            // ã‚¯ãƒªãƒƒã‚¯å¤–ã§é–‰ã˜ã‚‹
            setTimeout(() => {
                const closeMenu = (e) => {
                    if (!menu.contains(e.target) && e.target !== button) {
                        menu.remove();
                        document.removeEventListener('click', closeMenu);
                    }
                };
                document.addEventListener('click', closeMenu);
            }, 0);
        }
        
        // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®è¡¨ç¤º/éè¡¨ç¤º
        function toggleFileSelectMenu() {
            const menu = document.getElementById('fileSelectMenu');
            menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
        }
        
        function hideFileSelectMenu() {
            document.getElementById('fileSelectMenu').style.display = 'none';
        }
        
        // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®å¤–ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‰é–‰ã˜ã‚‹
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('fileSelectMenu');
            const button = e.target.closest('button[onclick*="toggleFileSelectMenu"]');
            if (!button && menu && !menu.contains(e.target)) {
                hideFileSelectMenu();
            }
        });
        
        // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠï¼ˆå•†å“è¿½åŠ ãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨ï¼‰
        async function selectMultipleFiles() {
            if (window.electronAPI) {
                try {
                    const filePaths = await window.electronAPI.dialog.selectMultipleFiles();
                    if (filePaths && filePaths.length > 0) {
                        
                        // ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã‚’è¡¨ç¤º
                        document.getElementById('selectedFileInfo').textContent = `(${filePaths.length}å€‹ã®ãƒ•ã‚¡ã‚¤ãƒ«)`;
                        
                        if (filePaths.length === 1) {
                            // å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆ
                            document.getElementById('productFilePath').value = filePaths[0];
                            document.getElementById('multipleFilesArea').style.display = 'none';
                        } else {
                            // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆ
                            displayMultipleFiles(filePaths);
                            document.getElementById('productFilePath').value = filePaths[0]; // æœ€åˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ¡ã‚¤ãƒ³ã«è¨­å®š
                        }
                    }
                } catch (error) {
                    console.error('Failed to select files:', error);
                    alert('ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error);
                }
            }
        }
        
        // ãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ãƒ•ã‚©ãƒ«ãƒ€é¸æŠï¼ˆçµ±åˆç‰ˆï¼‰
        async function selectFilesOrFolders() {
            if (window.electronAPI && window.electronAPI.dialog.selectFilesOrFolders) {
                try {
                    const result = await window.electronAPI.dialog.selectFilesOrFolders();
                    
                    if (!result || !result.type) {
                        return;
                    }
                    
                    if (result.type === 'folder') {
                        // ãƒ•ã‚©ãƒ«ãƒ€ãŒé¸æŠã•ã‚ŒãŸå ´åˆ
                        if (result.files && result.files.length > 0) {
                            
                            // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã®è¡¨ç¤º
                            displayMultipleFiles(result.files);
                            
                            // æœ€åˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ¡ã‚¤ãƒ³ã¨ã—ã¦è¨­å®š
                            document.getElementById('productFilePath').value = result.files[0];
                            
                            // ãƒ•ã‚©ãƒ«ãƒ€åã‹ã‚‰å•†å“åã‚’æ¨æ¸¬
                            if (!document.getElementById('productName').value) {
                                document.getElementById('productName').value = result.folderName;
                            }
                        } else {
                            alert('é¸æŠã•ã‚ŒãŸãƒ•ã‚©ãƒ«ãƒ€ã«.unitypackageãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚');
                        }
                    } else if (result.type === 'files') {
                        // ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚ŒãŸå ´åˆ
                        if (result.files && result.files.length > 0) {
                            if (result.files.length === 1) {
                                document.getElementById('productFilePath').value = result.files[0];
                                document.getElementById('multipleFilesArea').style.display = 'none';
                            } else {
                                displayMultipleFiles(result.files);
                                document.getElementById('productFilePath').value = result.files[0];
                            }
                        }
                    }
                } catch (error) {
                    console.error('Failed to select files or folders:', error);
                    alert('ãƒ•ã‚¡ã‚¤ãƒ«/ãƒ•ã‚©ãƒ«ãƒ€é¸æŠã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error);
                }
            }
        }
        
        // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ
        async function selectFile() {
            if (window.electronAPI) {
                try {
                    const filePaths = await window.electronAPI.dialog.selectMultipleFiles();
                    if (filePaths && filePaths.length > 0) {
                        if (filePaths.length === 1) {
                            document.getElementById('productFilePath').value = filePaths[0];
                            document.getElementById('multipleFilesArea').style.display = 'none';
                        } else {
                            displayMultipleFiles(filePaths);
                            document.getElementById('productFilePath').value = filePaths[0];
                        }
                    }
                } catch (error) {
                    console.error('Failed to select file:', error);
                    alert('ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error);
                }
            }
        }

        // ãƒ•ã‚©ãƒ«ãƒ€é¸æŠã¨è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†
        async function selectFolder() {
            if (window.electronAPI) {
                try {
                    const result = await window.electronAPI.dialog.selectDirectory();
                    if (result && result.folderPath) {
                        if (result.files && result.files.length > 0) {
                            
                            // ãƒ•ã‚©ãƒ«ãƒ€æƒ…å ±ã‚’è¡¨ç¤º
                            document.getElementById('selectedFolderInfo').textContent = `(ãƒ•ã‚©ãƒ«ãƒ€: ${result.folderName})`;
                            
                            // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã®è¡¨ç¤º
                            displayMultipleFiles(result.files);
                            
                            // æœ€åˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ¡ã‚¤ãƒ³ã¨ã—ã¦è¨­å®š
                            document.getElementById('productFilePath').value = result.files[0];
                            
                            // ãƒ•ã‚©ãƒ«ãƒ€åã‹ã‚‰å•†å“åã‚’æ¨æ¸¬
                            if (!document.getElementById('productName').value) {
                                document.getElementById('productName').value = result.folderName;
                            }
                            
                            // è©³ç´°ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                            const fileNames = result.files.map(f => f.split(/[/\\]/).pop()).join('\nãƒ»');
                            alert(`ãƒ•ã‚©ãƒ«ãƒ€ "${result.folderName}" ã‹ã‚‰${result.files.length}å€‹ã®.unitypackageãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚\n\nè¦‹ã¤ã‹ã£ãŸãƒ•ã‚¡ã‚¤ãƒ«:\nãƒ»${fileNames}\n\nå•†å“æƒ…å ±ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚`);
                        } else {
                            alert('é¸æŠã—ãŸãƒ•ã‚©ãƒ«ãƒ€ã«.unitypackageãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                        }
                        
                        if (result.error) {
                            console.error('ãƒ•ã‚©ãƒ«ãƒ€èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', result.error);
                        }
                    }
                } catch (error) {
                    console.error('Failed to select folder:', error);
                    alert('ãƒ•ã‚©ãƒ«ãƒ€é¸æŠã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error);
                }
            }
        }

        // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
        function displayMultipleFiles(filePaths, existingDisplayNames = null) {
            const multipleFilesArea = document.getElementById('multipleFilesArea');
            const filesList = document.getElementById('filesList');
            
            multipleFilesArea.style.display = 'block';
            filesList.innerHTML = '';
            
            // ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã‚’ä¿å­˜ã™ã‚‹é…åˆ—
            window.multipleFileData = filePaths.map((filePath, index) => {
                const originalName = filePath.split(/[/\\]/).pop();
                return {
                    path: filePath,
                    originalName: originalName,
                    displayName: existingDisplayNames && existingDisplayNames[index] ? existingDisplayNames[index] : originalName
                };
            });
            
            filePaths.forEach((filePath, index) => {
                const fileName = filePath.split(/[/\\]/).pop();
                const fileItem = document.createElement('div');
                fileItem.id = `fileItem_${index}`;
                fileItem.style.cssText = `
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    padding: 10px;
                    margin-bottom: 8px;
                    border-radius: 4px;
                    background-color: #4b5563;
                    transition: all 0.2s;
                `;
                
                // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ã‚¤ã‚³ãƒ³
                const fileIcon = document.createElement('span');
                fileIcon.textContent = 'ğŸ“¦';
                fileIcon.style.cssText = 'font-size: 16px; flex-shrink: 0;';
                
                const contentDiv = document.createElement('div');
                contentDiv.style.cssText = 'flex: 1; display: flex; flex-direction: column; gap: 4px; min-width: 0;';
                
                const textInput = document.createElement('input');
                textInput.type = 'text';
                textInput.value = window.multipleFileData[index].displayName;
                textInput.id = `fileName_${index}`;
                textInput.dataset.index = index;
                textInput.onchange = () => updateFileName(index, textInput.value);
                // ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ•ã‚©ãƒ¼ã‚«ã‚¹å‡¦ç†ã®ã¿
                textInput.addEventListener('click', () => textInput.focus());
                textInput.style.pointerEvents = 'auto';
                textInput.style.userSelect = 'text';
                textInput.onfocus = () => {
                    textInput.style.borderColor = '#10b981'; // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹æ™‚ã«æ ç·šã®è‰²ã‚’å¤‰æ›´
                    textInput.style.outline = 'none'; // ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã‚’ç„¡åŠ¹åŒ–
                };
                textInput.onblur = () => {
                    textInput.style.borderColor = '#6b7280'; // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ãŒå¤–ã‚ŒãŸã‚‰å…ƒã«æˆ»ã™
                };
                textInput.style.cssText = 'flex: 1; padding: 4px 8px; background-color: #374151; color: white; border: 1px solid #6b7280; border-radius: 3px; font-size: 12px; transition: border-color 0.2s; caret-color: white; pointer-events: auto; user-select: text; cursor: text;';
                textInput.placeholder = 'è¡¨ç¤ºåã‚’å…¥åŠ›';
                
                contentDiv.appendChild(textInput);
                
                const originalNameSpan = document.createElement('span');
                originalNameSpan.style.cssText = 'font-size: 11px; color: #9ca3af; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;';
                originalNameSpan.title = fileName;
                originalNameSpan.textContent = `å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«å: ${fileName}`;
                
                contentDiv.appendChild(originalNameSpan);
                
                fileItem.appendChild(fileIcon);
                fileItem.appendChild(contentDiv);
                
                // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã¨ãã®å‡¦ç†ï¼ˆå‰Šé™¤ï¼‰
                
                // ã‚¿ãƒ–ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨­å®šã—ã¦ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ”¹å–„
                textInput.tabIndex = 100 + index;
                
                fileItem.onmouseover = () => fileItem.style.backgroundColor = '#6b7280';
                fileItem.onmouseout = () => fileItem.style.backgroundColor = '#4b5563';
                
                filesList.appendChild(fileItem);
            });
            
            // æœ€åˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¨­å®šï¼ˆãƒ¡ã‚¤ãƒ³ã¨ã„ã†æ¦‚å¿µã¯å‰Šé™¤ï¼‰
            if (filePaths.length > 0) {
                document.getElementById('productFilePath').value = filePaths[0];
            }
        }
        
        // ãƒ•ã‚¡ã‚¤ãƒ«åæ›´æ–°æ™‚ã®å‡¦ç†
        function updateFileName(index, newName) {
            if (window.multipleFileData && window.multipleFileData[index]) {
                window.multipleFileData[index].displayName = newName;
            }
        }
        
        function forceTextInputFocus(index) {
            const textInput = document.getElementById(`fileName_${index}`);
            if (textInput) {
                textInput.disabled = false;
                textInput.readOnly = false;
                textInput.style.pointerEvents = 'auto';
                setTimeout(() => {
                    textInput.focus();
                    textInput.select();
                }, 50);
            }
        }

        // ã‚µãƒ ãƒã‚¤ãƒ«å–å¾—
        async function fetchThumbnail(isAutomatic = false) {
            const boothUrl = document.getElementById('productBoothUrl').value;
            if (!boothUrl) {
                if (!isAutomatic) {
                    // alertã®ä»£ã‚ã‚Šã«Booth URLãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
                    const boothUrlField = document.getElementById('productBoothUrl');
                    if (boothUrlField) {
                        boothUrlField.style.borderColor = '#ef4444';
                        boothUrlField.placeholder = 'Booth URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
                        boothUrlField.focus();
                        setTimeout(() => {
                            boothUrlField.style.borderColor = '';
                            boothUrlField.placeholder = 'https://booth.pm/...';
                        }, 2000);
                    }
                }
                return;
            }

            if (!boothUrl.includes('booth.pm')) {
                if (!isAutomatic) {
                    // alertã®ä»£ã‚ã‚Šã«ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                    const boothUrlField = document.getElementById('productBoothUrl');
                    if (boothUrlField) {
                        boothUrlField.style.borderColor = '#ef4444';
                        boothUrlField.select();
                        setTimeout(() => {
                            boothUrlField.style.borderColor = '';
                        }, 2000);
                    }
                }
                return;
            }

            // ãƒœã‚¿ãƒ³ã‚’ç›´æ¥å–å¾—ï¼ˆæ‰‹å‹•å®Ÿè¡Œæ™‚ï¼‰
            let button = null;
            let originalText = '';
            if (!isAutomatic) {
                const thumbnailButtons = document.querySelectorAll('button');
                for (let btn of thumbnailButtons) {
                    if (btn.textContent.includes('ã‚µãƒ ãƒã‚¤ãƒ«å–å¾—')) {
                        button = btn;
                        originalText = btn.textContent;
                        btn.disabled = true;
                        btn.textContent = 'å–å¾—ä¸­...';
                        break;
                    }
                }
            }

            try {
                if (window.electronAPI && window.electronAPI.fetch && window.electronAPI.fetch.thumbnail) {
                    const result = await window.electronAPI.fetch.thumbnail(boothUrl);
                    if (result && result.success && result.thumbnailUrl) {
                        const thumbnailUrlField = document.getElementById('productThumbnailUrl');
                        if (thumbnailUrlField) {
                            thumbnailUrlField.value = result.thumbnailUrl;
                        }
                        try {
                            showThumbnailPreview(result.thumbnailUrl);
                        } catch (previewError) {
                            console.error('Thumbnail preview error:', previewError);
                        }
                        // alertã®ä»£ã‚ã‚Šã«ãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§æˆåŠŸã‚’è¡¨ç¤º
                        if (!isAutomatic && button) {
                            button.textContent = 'âœ“ å–å¾—æˆåŠŸ';
                            button.style.backgroundColor = '#10b981';
                            setTimeout(() => {
                                button.textContent = originalText;
                                button.style.backgroundColor = '';
                            }, 2000);
                        }
                    } else {
                        // alertã®ä»£ã‚ã‚Šã«ãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§å¤±æ•—ã‚’è¡¨ç¤º
                        if (!isAutomatic && button) {
                            button.textContent = 'âœ— å–å¾—å¤±æ•—';
                            button.style.backgroundColor = '#ef4444';
                            setTimeout(() => {
                                button.textContent = originalText;
                                button.style.backgroundColor = '';
                            }, 2000);
                        }
                    }
                } else {
                    if (!isAutomatic && button) {
                        button.textContent = 'âœ— æ©Ÿèƒ½åˆ©ç”¨ä¸å¯';
                        button.style.backgroundColor = '#ef4444';
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.style.backgroundColor = '';
                        }, 2000);
                    }
                }
            } catch (error) {
                console.error('Failed to fetch thumbnail:', error);
                // alertã®ä»£ã‚ã‚Šã«ãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã‚¨ãƒ©ãƒ¼ã‚’è¡¨ç¤º
                if (!isAutomatic && button) {
                    button.textContent = 'âœ— ã‚¨ãƒ©ãƒ¼';
                    button.style.backgroundColor = '#ef4444';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = '';
                    }, 2000);
                }
            } finally {
                // ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã®ã¿ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆä»–ã®è¦ç´ ã«ã¯è§¦ã‚‰ãªã„ï¼‰
                if (button) {
                    button.disabled = false;
                    button.textContent = originalText;
                }
            }
        }

        // ã‚µãƒ ãƒã‚¤ãƒ« ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¡¨ç¤º
        function showThumbnailPreview(thumbnailUrl) {
            try {
                const thumbnailPreview = document.getElementById('thumbnailPreview');
                const thumbnailImage = document.getElementById('thumbnailImage');
                
                if (!thumbnailPreview || !thumbnailImage) {
                    console.warn('Thumbnail preview elements not found');
                    return;
                }
                
                if (thumbnailUrl && thumbnailUrl.trim() !== '') {
                    thumbnailImage.src = thumbnailUrl;
                    thumbnailImage.onerror = function() {
                        // ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ãŸå ´åˆã¯éè¡¨ç¤ºã«ã™ã‚‹
                        thumbnailPreview.style.display = 'none';
                    };
                    thumbnailImage.onload = function() {
                        // ç”»åƒã®èª­ã¿è¾¼ã¿ãŒæˆåŠŸã—ãŸå ´åˆã«è¡¨ç¤º
                        thumbnailPreview.style.display = 'block';
                    };
                } else {
                    thumbnailPreview.style.display = 'none';
                }
            } catch (error) {
                console.error('Error in showThumbnailPreview:', error);
            }
        }

        // ãƒ•ã‚©ãƒ¼ãƒ é€ä¿¡
        document.getElementById('productForm').addEventListener('submit', async function(event) {
            event.preventDefault();
            
            const formData = new FormData(event.target);
            
            // é¸æŠã•ã‚ŒãŸã‚¢ãƒã‚¿ãƒ¼IDã‚’å–å¾—
            const selectedAvatarIds = [];
            const avatarCheckboxes = document.querySelectorAll('#avatarCheckboxes input[type="checkbox"]:checked');
            avatarCheckboxes.forEach(checkbox => {
                selectedAvatarIds.push(checkbox.value);
            });
            
            // é¸æŠã•ã‚ŒãŸã‚¿ã‚°ã‚’å–å¾—
            const selectedTags = [];
            const tagCheckboxes = document.querySelectorAll('#tagCheckboxes input[type="checkbox"]:checked');
            tagCheckboxes.forEach(checkbox => {
                selectedTags.push(checkbox.value);
            });
            
            // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã®è¡¨ç¤ºåã‚’ä¿å­˜
            let displayNames = '';
            let filePaths = '';
            if (window.multipleFileData && window.multipleFileData.length > 0) {
                displayNames = window.multipleFileData.map(f => f.displayName).join('|');
                filePaths = window.multipleFileData.map(f => f.path).join('|');
            }
            
            const productData = {
                name: formData.get('name'),
                category: formData.get('category'),
                booth_url: formData.get('booth_url'),
                thumbnail_url: formData.get('thumbnail_url'),
                file_path: formData.get('file_path'),
                description: formData.get('description'),
                author: '',
                avatar_ids: selectedAvatarIds.join(','),
                tags: selectedTags.join(','),
                file_paths: filePaths,
                display_names: displayNames
            };

            try {
                if (window.electronAPI) {
                    if (currentEditingProductId) {
                        // ç·¨é›†
                        await window.electronAPI.database.updateProduct(currentEditingProductId, productData);
                        
                        // å­¦ç¿’æ©Ÿèƒ½ï¼šBooth URLãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãƒ•ã‚¡ã‚¤ãƒ«åã¨ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’å­¦ç¿’ï¼ˆç·¨é›†æ™‚ï¼‰
                        if (productData.booth_url && productData.booth_url.includes('booth.pm') && productData.booth_url.includes('/items/') && productData.file_path) {
                            try {
                                const filename = productData.file_path.split(/[/\\]/).pop();
                                const learningResult = await window.electronAPI.booth.learnMapping(filename, productData.booth_url);
                            } catch (learningError) {
                                console.error('å•†å“ç·¨é›†æ™‚ã®å­¦ç¿’ã‚¨ãƒ©ãƒ¼:', learningError);
                            }
                        } else {
                        }
                    } else {
                        // æ–°è¦è¿½åŠ 
                        await window.electronAPI.database.addProduct(productData);
                        
                        // å­¦ç¿’æ©Ÿèƒ½ï¼šBooth URLãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãƒ•ã‚¡ã‚¤ãƒ«åã¨ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’å­¦ç¿’
                        if (productData.booth_url && productData.booth_url.includes('booth.pm') && productData.booth_url.includes('/items/') && productData.file_path) {
                            try {
                                const filename = productData.file_path.split(/[/\\]/).pop();
                                const learningResult = await window.electronAPI.booth.learnMapping(filename, productData.booth_url);
                            } catch (learningError) {
                                console.error('å•†å“è¿½åŠ æ™‚ã®å­¦ç¿’ã‚¨ãƒ©ãƒ¼:', learningError);
                            }
                        } else {
                        }
                        
                        // è¨­å®šç¢ºèªå¾Œã€ãƒ¡ã‚¤ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã«ç§»å‹•
                        const settings = await window.electronAPI.settings.get();
                        if (settings.autoArchive === true && productData.file_path && productData.file_path.trim()) {
                            const archiveResult = await window.electronAPI.fs.moveToArchive(productData.file_path);
                            if (archiveResult.success) {
                                
                                // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æ›´æ–°
                                const products = await window.electronAPI.database.getProducts();
                                const addedProduct = products[products.length - 1]; // æœ€å¾Œã«è¿½åŠ ã•ã‚ŒãŸå•†å“
                                if (addedProduct) {
                                    let updatedData = { ...addedProduct, file_path: archiveResult.newPath };
                                    
                                    // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã‚‚ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã«ç§»å‹•
                                    if (window.multipleFileData && window.multipleFileData.length > 0) {
                                        const archivedFiles = [];
                                        for (const fileData of window.multipleFileData) {
                                            const result = await window.electronAPI.fs.moveToArchive(fileData.path);
                                            if (result.success) {
                                                archivedFiles.push({ ...fileData, path: result.newPath });
                                            } else {
                                                archivedFiles.push(fileData); // ç§»å‹•å¤±æ•—æ™‚ã¯å…ƒã®ãƒ‘ã‚¹ã‚’ä¿æŒ
                                                console.warn('è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ç§»å‹•ã«å¤±æ•—:', result.error);
                                            }
                                        }
                                        
                                        updatedData.file_paths = archivedFiles.map(f => f.path).join('|');
                                        updatedData.display_names = archivedFiles.map(f => f.displayName).join('|');
                                    }
                                    
                                    await window.electronAPI.database.updateProduct(addedProduct.id, updatedData);
                                }
                            } else {
                                console.warn('ãƒ¡ã‚¤ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ç§»å‹•ã«å¤±æ•—:', archiveResult.error);
                            }
                        } else {
                        }
                    }
                    await loadProducts();
                    closeModal();
                }
            } catch (error) {
                console.error('Failed to save product:', error);
                alert('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error);
            }
        });

        // ãƒ¢ãƒ¼ãƒ€ãƒ«å¤–ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
        document.getElementById('productModal').addEventListener('click', function(event) {
            if (event.target === this) {
                closeModal();
            }
        });

        // å•†å“è©³ç´°ã‚’é–‹ã
        function openProductDetail(productOrId) {
            // IDã®å ´åˆã¯å•†å“ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—
            const product = typeof productOrId === 'number' ? 
                products.find(p => p.id === productOrId) : productOrId;
            
            if (!product) {
                console.error('Product not found:', productOrId);
                return;
            }
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            
            const modalContent = document.createElement('div');
            modalContent.className = 'modal-content';
            modalContent.style.width = '600px';
            modalContent.style.maxWidth = '90vw';
            
            // å¯¾å¿œã‚¢ãƒã‚¿ãƒ¼åã‚’å–å¾—
            let avatarNames = '';
            if (product.avatar_ids) {
                const avatarIds = product.avatar_ids.split(',').map(id => id.trim()).filter(id => id);
                const matchedAvatars = avatars.filter(avatar => avatarIds.includes(avatar.id.toString()));
                avatarNames = matchedAvatars.map(avatar => avatar.name).join(', ');
            }
            
            modalContent.innerHTML = `
                <h2>${product.name}</h2>
                <div style="display: flex; gap: 20px; margin: 20px 0;">
                    <div style="flex-shrink: 0;">
                        ${product.thumbnail_url ? 
                            `<img src="${product.thumbnail_url}" alt="${product.name}" style="width: 150px; height: 150px; object-fit: cover; border-radius: 6px;" draggable="false">` : 
                            '<div style="width: 150px; height: 150px; background-color: #4b5563; display: flex; align-items: center; justify-content: center; border-radius: 6px; color: #9ca3af;">ç”»åƒãªã—</div>'
                        }
                    </div>
                    <div style="flex: 1;">
                        <p><strong>ã‚«ãƒ†ã‚´ãƒª:</strong> ${product.category || 'ãªã—'}</p>
                        ${avatarNames ? `<p><strong>å¯¾å¿œã‚¢ãƒã‚¿ãƒ¼:</strong> ${avatarNames}</p>` : ''}
                        ${product.tags && product.tags.trim() !== '' ? `<p><strong>ã‚¿ã‚°:</strong> ${product.tags.split(',').map(tag => `<span style="background-color: #4b5563; padding: 2px 6px; border-radius: 4px; margin-right: 4px; font-size: 12px;">${tag.trim()}</span>`).join('')}</p>` : ''}
                        ${product.booth_url ? `<p><strong>Booth URL:</strong> <a href="${product.booth_url}" target="_blank" style="color: #60a5fa;">${product.booth_url}</a></p>` : ''}
                        ${product.file_path ? `<p><strong>ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹:</strong> ${product.file_path}</p>` : ''}
                        ${product.description ? `<p><strong>èª¬æ˜:</strong><br>${product.description}</p>` : ''}
                    </div>
                </div>
                <div class="form-buttons">
                    ${product.file_path ? `<button onclick="openFile(event, '${product.file_path.replace(/\\/g, '\\\\')}', ${product.id})" class="form-btn form-btn-submit">Unityã§é–‹ã${product.file_paths && product.file_paths.includes('|') ? ' â–¼' : ''}</button>` : ''}
                    <button onclick="editProductFromDetail(event, ${product.id})" class="form-btn form-btn-submit">ç·¨é›†</button>
                    <button onclick="closeDetailModal()" class="form-btn form-btn-cancel">é–‰ã˜ã‚‹</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            
            // ãƒ¢ãƒ¼ãƒ€ãƒ«å¤–ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
            modal.addEventListener('click', function(event) {
                if (event.target === modal) {
                    closeDetailModal();
                }
            });
            
            document.body.appendChild(modal);
            window.currentDetailModal = modal;
        }
        
        // è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeDetailModal() {
            if (window.currentDetailModal) {
                document.body.removeChild(window.currentDetailModal);
                window.currentDetailModal = null;
            }
        }


        // ESCã‚­ãƒ¼ã§ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                // å•†å“è¿½åŠ ãƒ»ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«
                const productModal = document.getElementById('productModal');
                if (productModal && productModal.style.display === 'block') {
                    closeModal();
                }
                
                // å•†å“è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ«
                if (window.currentDetailModal) {
                    closeDetailModal();
                }
            }
        });

        // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½
        function initDragAndDrop() {
            const dropZone = document.getElementById('dropZone');
            const dragOverlay = document.getElementById('dragOverlay');
            const body = document.body;
            let dragCounter = 0;
            
            // ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ‰ãƒ©ãƒƒã‚°ã•ã‚ŒãŸæ™‚ã«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã¨ãƒ‰ãƒ­ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³ã‚’è¡¨ç¤º
            body.addEventListener('dragenter', function(e) {
                e.preventDefault();
                dragCounter++;
                // ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ‰ãƒ©ãƒƒã‚°ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯å¸¸ã«è¡¨ç¤ºï¼ˆãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã®åˆ¤å®šã¯å¾Œã§è¡Œã†ï¼‰
                if (e.dataTransfer && (e.dataTransfer.files.length > 0 || e.dataTransfer.types.includes('Files') || e.dataTransfer.types.includes('application/x-moz-file'))) {
                    dropZone.style.display = 'block';
                    dragOverlay.style.display = 'block';
                    // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³ã«ãƒ‘ãƒ«ã‚¹åŠ¹æœã‚’è¿½åŠ 
                    dropZone.style.animation = 'pulse 2s infinite';
                }
            });
            
            body.addEventListener('dragover', function(e) {
                e.preventDefault();
            });
            
            body.addEventListener('dragleave', function(e) {
                e.preventDefault();
                dragCounter--;
                // ã™ã¹ã¦ã®ãƒ‰ãƒ©ãƒƒã‚°ãŒçµ‚äº†ã—ãŸå ´åˆã®ã¿éè¡¨ç¤º
                if (dragCounter === 0) {
                    dropZone.style.display = 'none';
                    dragOverlay.style.display = 'none';
                    dropZone.style.animation = '';
                }
            });
            
            body.addEventListener('drop', function(e) {
                e.preventDefault();
                dragCounter = 0;
                dropZone.style.display = 'none';
                dragOverlay.style.display = 'none';
                dropZone.style.animation = '';
                
                const files = Array.from(e.dataTransfer.files);
                
                // æ··åœ¨ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†: ãƒ•ã‚©ãƒ«ãƒ€å†…ãƒ•ã‚¡ã‚¤ãƒ«ã¨å˜ä½“ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åˆ†é¡
                processedMixedDrop(files, e.dataTransfer.items);
            });
            
            // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ«å¤‰æ›´
            dropZone.addEventListener('dragover', function(e) {
                e.preventDefault();
                this.style.borderColor = '#16a34a';
                this.style.backgroundColor = '#065f46';
                this.style.borderWidth = '3px';
                this.style.transform = 'scale(1.02)';
            });
            
            dropZone.addEventListener('dragleave', function(e) {
                e.preventDefault();
                this.style.borderColor = '#4b5563';
                this.style.backgroundColor = '#374151';
                this.style.borderWidth = '2px';
                this.style.transform = 'scale(1)';
            });
            
            dropZone.addEventListener('drop', function(e) {
                this.style.borderColor = '#4b5563';
                this.style.backgroundColor = '#374151';
                this.style.borderWidth = '2px';
                this.style.transform = 'scale(1)';
            });
        }
        
        // .unitypackageãƒ•ã‚¡ã‚¤ãƒ«ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        function hasUnityPackageFiles(dataTransfer) {
            if (dataTransfer.items) {
                for (let item of dataTransfer.items) {
                    if (item.kind === 'file') {
                        const file = item.getAsFile();
                        if (file && file.name.toLowerCase().endsWith('.unitypackage')) {
                            return true;
                        }
                        // ãƒ•ã‚©ãƒ«ãƒ€ã®å ´åˆã‚‚trueã‚’è¿”ã™ï¼ˆå¾Œã§ãƒ•ã‚©ãƒ«ãƒ€å†…ã‚’ãƒã‚§ãƒƒã‚¯ï¼‰
                        if (file && file.type === '') {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        
        // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’1ã¤ã®å•†å“ã¨ã—ã¦ã‚°ãƒ«ãƒ¼ãƒ—å‡¦ç†
        async function processDroppedFilesAsGroup(files) {
            
            const firstFile = files[0];
            const { normalizedName } = extractSearchKeywords(firstFile.name);
            
            // ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰å•†å“åã‚’æ¨æ¸¬ï¼ˆå„å˜èªã®å…ˆé ­ã‚’å¤§æ–‡å­—ã«ï¼‰
            const productName = normalizedName
                .replace(/\b\w/g, l => l.toUpperCase());
            
            // è‡ªå‹•ã§ã‚«ãƒ†ã‚´ãƒªã‚’æ¨æ¸¬
            let category = 'ãã®ä»–';
            const lowerName = normalizedName.toLowerCase();
            if (lowerName.includes('avatar') || lowerName.includes('ã‚¢ãƒã‚¿ãƒ¼')) {
                category = 'ã‚¢ãƒã‚¿ãƒ¼æœ¬ä½“';
            } else if (lowerName.includes('costume') || lowerName.includes('cloth') || lowerName.includes('è¡£è£…')) {
                category = 'è¡£è£…';
            } else if (lowerName.includes('accessory') || lowerName.includes('ã‚¢ã‚¯ã‚»ã‚µãƒªãƒ¼')) {
                category = 'ã‚¢ã‚¯ã‚»ã‚µãƒªãƒ¼';
            } else if (lowerName.includes('hair') || lowerName.includes('é«ª')) {
                category = 'é«ªå‹';
            } else if (lowerName.includes('tool') || lowerName.includes('ãƒ„ãƒ¼ãƒ«') || lowerName.includes('editor') || lowerName.includes('utility')) {
                category = 'ãƒ„ãƒ¼ãƒ«';
            } else if (lowerName.includes('pose') || lowerName.includes('ãƒãƒ¼ã‚º') || lowerName.includes('motion') || lowerName.includes('anim')) {
                category = 'ãƒãƒ¼ã‚º';
            } else if (lowerName.includes('world') || lowerName.includes('ãƒ¯ãƒ¼ãƒ«ãƒ‰') || lowerName.includes('scene')) {
                category = 'ãƒ¯ãƒ¼ãƒ«ãƒ‰';
            }
            
            // å…¨ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’ä¿å­˜ç”¨ã«æº–å‚™
            const allFilePaths = files.map(file => file.path || file.name);
            
            const productData = {
                name: productName,
                category: category,
                booth_url: '',
                thumbnail_url: '',
                file_path: allFilePaths[0], // ãƒ¡ã‚¤ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
                file_paths: allFilePaths.join('|'), // å…¨ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’åŒºåˆ‡ã‚Šæ–‡å­—ã§ä¿å­˜
                description: `è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«: ${files.map(f => f.name).join(', ')}`,
                author: '',
                avatar_ids: '',
                tags: ''
            };
            
            try {
                if (window.electronAPI) {
                    await window.electronAPI.database.addProduct(productData);
                    
                    // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰è‡ªå‹•ã§Booth URLå–å¾—ã¨ã‚µãƒ ãƒã‚¤ãƒ«è¨­å®š
                    const firstFileName = files[0].name;
                    try {
                        const boothSearchResult = await window.electronAPI.booth.searchByFilename(firstFileName);
                        if (boothSearchResult.success && boothSearchResult.results && boothSearchResult.results.length > 0) {
                            const firstResult = boothSearchResult.results[0];
                            if (firstResult.url && firstResult.url.includes('booth.pm') && firstResult.url.includes('/items/')) {
                                // Booth URLã‚’æ›´æ–°
                                productData.booth_url = firstResult.url;
                                
                                if (boothSearchResult.highConfidence !== false) {
                                    try {
                                        const thumbnailResult = await window.electronAPI.fetch.thumbnail(firstResult.url);
                                        if (thumbnailResult.success && thumbnailResult.thumbnailUrl) {
                                            productData.thumbnail_url = thumbnailResult.thumbnailUrl;
                                        }
                                    } catch (thumbnailError) {
                                        // ã‚µãƒ ãƒã‚¤ãƒ«å–å¾—å¤±æ•—ã¯è‡´å‘½çš„ã§ã¯ãªã„
                                    }
                                } else {
                                    // ä½ä¿¡é ¼åº¦ã®å ´åˆã¯ã‚µãƒ ãƒã‚¤ãƒ«ã‚’å–å¾—ã›ãšè­¦å‘Šè¡¨ç¤º
                                    console.warn('ä¿¡é ¼åº¦ãŒä½ã„ãƒãƒƒãƒã®ãŸã‚ã‚µãƒ ãƒã‚¤ãƒ«ã‚’å–å¾—ã—ã¾ã›ã‚“ã§ã—ãŸ:', firstResult.title);
                                }
                                
                                // æ›´æ–°ã•ã‚ŒãŸå•†å“ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
                                const products = await window.electronAPI.database.getProducts();
                                const addedProduct = products[products.length - 1];
                                if (addedProduct) {
                                    await window.electronAPI.database.updateProduct(addedProduct.id, {
                                        ...addedProduct,
                                        booth_url: productData.booth_url,
                                        thumbnail_url: productData.thumbnail_url
                                    });
                                }
                            }
                        }
                    } catch (boothError) {
                        // Boothæ¤œç´¢å¤±æ•—ã¯è‡´å‘½çš„ã§ã¯ãªã„
                    }
                    
                    loadProducts();
                }
            } catch (error) {
                console.error('ã‚°ãƒ«ãƒ¼ãƒ—å•†å“è¿½åŠ ã‚¨ãƒ©ãƒ¼:', error);
            }
        }
        
        // ãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰unitypackageãƒ•ã‚¡ã‚¤ãƒ«ã‚’å†å¸°çš„ã«æŠ½å‡ºã™ã‚‹é–¢æ•°
        async function extractFilesFromFolder(folderEntry) {
            return new Promise((resolve, reject) => {
                const files = [];
                let pendingOperations = 0;
                let totalEntries = 0;
                
                function processEntry(entry, depth = 0) {
                    if (entry.isFile && entry.name.toLowerCase().endsWith('.unitypackage')) {
                        pendingOperations++;
                        entry.file(file => {
                            const filePath = file.path || `${entry.fullPath}`;
                            files.push(filePath);
                            pendingOperations--;
                            
                            if (pendingOperations === 0) {
                                resolve(files);
                            }
                        }, error => {
                            console.error('ãƒ•ã‚¡ã‚¤ãƒ«å–å¾—ã‚¨ãƒ©ãƒ¼:', entry.name, error);
                            pendingOperations--;
                            if (pendingOperations === 0) {
                                resolve(files);
                            }
                        });
                    } else if (entry.isDirectory && depth < 3) { // æœ€å¤§3éšå±¤ã¾ã§
                        pendingOperations++;
                        const subReader = entry.createReader();
                        
                        function readSubEntries() {
                            subReader.readEntries(subEntries => {
                                if (subEntries.length > 0) {
                                    subEntries.forEach(subEntry => {
                                        processEntry(subEntry, depth + 1);
                                    });
                                    readSubEntries(); // ç¶šãã‚’èª­ã‚€
                                } else {
                                    pendingOperations--;
                                    if (pendingOperations === 0) {
                                        resolve(files);
                                    }
                                }
                            }, error => {
                                console.error('ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', entry.name, error);
                                pendingOperations--;
                                if (pendingOperations === 0) {
                                    resolve(files);
                                }
                            });
                        }
                        readSubEntries();
                    }
                }
                
                const dirReader = folderEntry.createReader();
                function readEntries() {
                    dirReader.readEntries(entries => {
                        totalEntries += entries.length;
                        
                        if (entries.length > 0) {
                            entries.forEach(entry => {
                                processEntry(entry, 0);
                            });
                            readEntries(); // ç¶šãã‚’èª­ã‚€
                        } else {
                            if (pendingOperations === 0) {
                                resolve(files);
                            }
                        }
                    }, error => {
                        console.error('ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', folderEntry.name, error);
                        reject(error);
                    });
                }
                
                readEntries();
            });
        }
        
        // ZIPãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†é–¢æ•°
        async function processZipFile(zipFilePath) {
            try {
                // ZIPãƒ•ã‚¡ã‚¤ãƒ«åã‚’å–å¾—
                const zipFileName = zipFilePath.split('\\').pop().split('/').pop();
                
                // ZIPãƒ•ã‚¡ã‚¤ãƒ«å†…ã®Unitypackageãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œç´¢
                const zipResult = await window.electronAPI.zip.listUnitypackages(zipFilePath);
                
                console.log('ZIPãƒ•ã‚¡ã‚¤ãƒ«è§£æçµæœ:', zipResult);
                
                if (!zipResult.success) {
                    alert(`ZIPãƒ•ã‚¡ã‚¤ãƒ«ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ: ${zipResult.error}`);
                    return;
                }
                
                if (!zipResult.files || zipResult.files.length === 0) {
                    alert(`${zipFileName} ã«ã¯Unitypackageãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚`);
                    return;
                }
                
                // Unitypackageãƒ•ã‚¡ã‚¤ãƒ«ãŒ1ã¤ã®å ´åˆã¯è‡ªå‹•ã§æŠ½å‡ºãƒ»ç™»éŒ²
                if (zipResult.files.length === 1) {
                    const unityFile = zipResult.files[0];
                    console.log('å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†:', unityFile);
                    if (!unityFile) {
                        console.error('unityFileãŒundefinedã§ã™');
                        alert('ZIPãƒ•ã‚¡ã‚¤ãƒ«å†…ã®Unitypackageãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
                        return;
                    }
                    await extractAndRegisterUnitypackage(zipFilePath, unityFile, zipFileName);
                    return;
                }
                
                // è¤‡æ•°ã®Unitypackageãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚‹å ´åˆã®å‡¦ç†
                // è¨­å®šã‹ã‚‰è‡ªå‹•ç™»éŒ²ãƒ¢ãƒ¼ãƒ‰ã‚’ç¢ºèªï¼ˆå¼·åˆ¶çš„ã«trueï¼‰
                let autoRegisterAll = true; // å¸¸ã«è‡ªå‹•ç™»éŒ²
                
                // å…¨ã¦ã®Unitypackageã‚’è‡ªå‹•ã§æŠ½å‡ºãƒ»ç™»éŒ²ï¼ˆãƒ•ã‚©ãƒ«ãƒ€ã‚°ãƒ«ãƒ¼ãƒ—åŒ–å¯¾å¿œï¼‰
                await autoExtractAndRegisterAllFiles(zipFilePath, zipResult.files, zipFileName);
                
            } catch (error) {
                console.error('ZIPãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                alert(`ZIPãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
        }
        
        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ•ã‚©ãƒ«ãƒ€åˆ¥ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ï¼ˆéšå±¤æ§‹é€ ã‚’è€ƒæ…®ï¼‰
        function groupFilesByFolder(files) {
            const groups = {};
            
            for (const file of files) {
                // ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹æƒ…å ±ã‚’å–å¾—ï¼ˆfile.path ã¾ãŸã¯ file.fullPath ã¾ãŸã¯ file.nameï¼‰
                const filePath = file.path || file.fullPath || file.name || '';
                
                if (!filePath) {
                    console.warn('ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒå–å¾—ã§ãã¾ã›ã‚“:', file);
                    continue;
                }
                
                // ãƒ‘ã‚¹åŒºåˆ‡ã‚Šæ–‡å­—ã‚’æ­£è¦åŒ–
                const normalizedPath = filePath.replace(/\\/g, '/');
                const pathParts = normalizedPath.split('/');
                
                // ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ«ãƒ€ï¼ˆæœ€ä¸Šä½ãƒ•ã‚©ãƒ«ãƒ€ï¼‰ã‚’åŸºæº–ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
                let groupKey;
                if (pathParts.length > 1) {
                    // ãƒ•ã‚©ãƒ«ãƒ€æ§‹é€ ãŒã‚ã‚‹å ´åˆã¯æœ€ä¸Šä½ãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½¿ç”¨
                    groupKey = pathParts[0];
                } else {
                    // ãƒ•ã‚©ãƒ«ãƒ€æ§‹é€ ãŒãªã„å ´åˆã¯'root'
                    groupKey = 'root';
                }
                
                if (!groups[groupKey]) {
                    groups[groupKey] = [];
                }
                groups[groupKey].push(file);
            }
            
            return groups;
        }
        
        // åŒã˜ãƒ•ã‚©ãƒ«ãƒ€ã®Unitypackageãƒ•ã‚¡ã‚¤ãƒ«ã‚’çµåˆç™»éŒ²
        async function extractAndRegisterGroupedUnitypackages(zipFilePath, unityFiles, zipFileName, folderPath) {
            // ä¸¦è¡Œå‡¦ç†æ•°ãƒã‚§ãƒƒã‚¯
            if (activeZipProcessingCount >= MAX_CONCURRENT_ZIP_PROCESSING) {
                console.warn(`æœ€å¤§ä¸¦è¡Œå‡¦ç†æ•°(${MAX_CONCURRENT_ZIP_PROCESSING})ã«é”ã—ãŸãŸã‚`, folderPath, 'ã‚’å¾…æ©Ÿã—ã¾ã™');
                while (activeZipProcessingCount >= MAX_CONCURRENT_ZIP_PROCESSING) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            activeZipProcessingCount++;
            
            
            try {
                // è¨­å®šã‹ã‚‰ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’å–å¾—
                const archiveDir = await window.electronAPI.fs.getArchiveDir();
                
                // å„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŠ½å‡º
                const extractedFilePaths = [];
                const displayNames = [];
                
                for (const unityFile of unityFiles) {
                    const unitypackageEntry = {
                        path: unityFile.fullPath || unityFile.fileName,
                        name: unityFile.fileName || unityFile.name
                    };
                    
                    const extractResult = await window.electronAPI.zip.extractUnitypackage(
                        zipFilePath, 
                        unitypackageEntry, 
                        archiveDir
                    );
                    
                    if (extractResult.success) {
                        extractedFilePaths.push(extractResult.extractedPath);
                        displayNames.push(unityFile.fileName || unityFile.name || 'Unknown');
                    } else {
                        console.error('ã‚°ãƒ«ãƒ¼ãƒ—å†…ãƒ•ã‚¡ã‚¤ãƒ«æŠ½å‡ºå¤±æ•—:', extractResult.error);
                        alert(`ã‚°ãƒ«ãƒ¼ãƒ—å†…ãƒ•ã‚¡ã‚¤ãƒ«æŠ½å‡ºã«å¤±æ•—: ${unityFile.fileName || unityFile.name || 'Unknown'}\nã‚¨ãƒ©ãƒ¼: ${extractResult.error}`);
                    }
                }
                
                if (extractedFilePaths.length === 0) {
                    console.error('ã‚°ãƒ«ãƒ¼ãƒ—å†…ã§æŠ½å‡ºã§ããŸãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“');
                    return;
                }
                
                // ãƒ•ã‚©ãƒ«ãƒ€åã‹ã‚‰å•†å“åã‚’ä½œæˆ
                const folderName = folderPath === 'root' ? zipFileName.replace(/\.zip$/i, '') : folderPath;
                
                // ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã•ã‚ŒãŸå•†å“ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
                const productData = {
                    name: folderName,
                    category: '',
                    tags: '',
                    description: `${folderName}`,
                    booth_url: '',
                    thumbnail_url: '',
                    file_path: extractedFilePaths[0], // ãƒ¡ã‚¤ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«
                    file_paths: extractedFilePaths.join('|'), // å…¨ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ï¼ˆåŒºåˆ‡ã‚Šæ–‡å­—|ï¼‰
                    display_names: displayNames.join('|'), // è¡¨ç¤ºåï¼ˆåŒºåˆ‡ã‚Šæ–‡å­—|ï¼‰
                    author: '',
                    avatar_ids: ''
                };
                
                // è³¼å…¥å±¥æ­´ã‹ã‚‰å•†å“æƒ…å ±ã‚’å–å¾—ï¼ˆå„ªå…ˆï¼‰
                const purchaseHistoryData = JSON.parse(localStorage.getItem('boothPurchaseHistory') || '[]');
                let foundFromPurchaseHistory = false;
                
                if (purchaseHistoryData.length > 0) {
                    // ZIPãƒ•ã‚¡ã‚¤ãƒ«åã§å€™è£œæ¤œç´¢
                    const zipCandidates = findCandidatesForFile(zipFileName);
                    // æœ€åˆã®Unitypackageãƒ•ã‚¡ã‚¤ãƒ«åã§ã‚‚æ¤œç´¢  
                    const firstUnityFile = unityFiles && unityFiles[0] ? unityFiles[0] : null;
                    const unityCandidates = firstUnityFile ? findCandidatesForFile(firstUnityFile.fileName || firstUnityFile.name || '') : [];
                    
                    // é‡è¤‡é™¤å»ã—ã¦å€™è£œã‚’ãƒãƒ¼ã‚¸
                    const allCandidates = [...zipCandidates];
                    unityCandidates.forEach(candidate => {
                        if (!allCandidates.some(existing => existing.boothUrl === candidate.boothUrl)) {
                            allCandidates.push(candidate);
                        }
                    });
                    
                    if (allCandidates.length > 0) {
                        const topCandidate = allCandidates[0];
                        const matchPercentage = Math.round(topCandidate.matchScore * 100);
                        
                        // 70%ä»¥ä¸Šã®å ´åˆã®ã¿è³¼å…¥å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã‚’é©ç”¨
                        if (topCandidate.matchScore >= 0.7) {
                            // è³¼å…¥å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã§å•†å“æƒ…å ±ã‚’æ›´æ–°
                            productData.name = topCandidate.title;
                            productData.booth_url = topCandidate.boothUrl;
                            productData.thumbnail_url = topCandidate.thumbnailUrl;
                            productData.author = topCandidate.author;
                            productData.description = `${folderName} (è³¼å…¥å±¥æ­´ãƒãƒƒãƒ ${matchPercentage}%: ${topCandidate.bestMatch})`;
                            
                            foundFromPurchaseHistory = true;
                        }
                    }
                }
                
                // è³¼å…¥å±¥æ­´ã§è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯å¾“æ¥ã®å­¦ç¿’ãƒ‡ãƒ¼ã‚¿æ¤œç´¢
                if (!foundFromPurchaseHistory) {
                    try {
                        // ã¾ãšZIPãƒ•ã‚¡ã‚¤ãƒ«åã§æ¤œç´¢
                        let boothSearchResult = await window.electronAPI.booth.searchByFilename(zipFileName);
                        
                        // ZIPãƒ•ã‚¡ã‚¤ãƒ«åã§è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã€æœ€åˆã®Unitypackageãƒ•ã‚¡ã‚¤ãƒ«åã§æ¤œç´¢
                        if (!boothSearchResult.success || !boothSearchResult.results || boothSearchResult.results.length === 0 || 
                            !boothSearchResult.results[0].url) {
                            boothSearchResult = await window.electronAPI.booth.searchByFilename(unityFiles[0].fileName);
                        }
                        
                        if (boothSearchResult.success && boothSearchResult.results && boothSearchResult.results.length > 0) {
                            const firstResult = boothSearchResult.results[0];
                            if (firstResult.url && firstResult.url.includes('booth.pm') && firstResult.url.includes('/items/')) {
                                productData.booth_url = firstResult.url;
                                
                                if (boothSearchResult.highConfidence !== false) {
                                    try {
                                        const thumbnailResult = await window.electronAPI.fetch.thumbnail(firstResult.url);
                                        if (thumbnailResult.success && thumbnailResult.thumbnailUrl) {
                                            productData.thumbnail_url = thumbnailResult.thumbnailUrl;
                                        }
                                    } catch (thumbnailError) {
                                        console.warn('ã‚µãƒ ãƒã‚¤ãƒ«å–å¾—å¤±æ•—:', thumbnailError);
                                    }
                                }
                            }
                        }
                    } catch (boothError) {
                        console.warn('Boothæ¤œç´¢ã«å¤±æ•—:', boothError);
                    }
                }
                
                // å•†å“ã‚’è¿½åŠ 
                try {
                    const addResult = await window.electronAPI.database.addProduct(productData);
                } catch (dbError) {
                    console.error('ã‚°ãƒ«ãƒ¼ãƒ—å•†å“ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¿½åŠ ã‚¨ãƒ©ãƒ¼:', dbError);
                    alert(`ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¿½åŠ ã‚¨ãƒ©ãƒ¼: ${dbError.message}`);
                    return;
                }
                
                // ZIPãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å‡¦ç†
                await handleZipFileArchive(zipFilePath);
                
                // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ï¼ˆæœ€åˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã§ï¼‰
                if (productData.booth_url) {
                    try {
                        await window.electronAPI.booth.learnMapping(unityFiles[0].fileName, productData.booth_url);
                    } catch (learningError) {
                        console.error('å­¦ç¿’ãƒ‡ãƒ¼ã‚¿æ›´æ–°ã‚¨ãƒ©ãƒ¼:', learningError);
                    }
                }
                
                try {
                    await loadProducts();
                } catch (loadError) {
                    console.error('å•†å“ãƒªã‚¹ãƒˆæ›´æ–°ã‚¨ãƒ©ãƒ¼:', loadError);
                }
                
            } catch (error) {
                console.error('ã‚°ãƒ«ãƒ¼ãƒ—æŠ½å‡ºãƒ»ç™»éŒ²ã‚¨ãƒ©ãƒ¼:', error);
                alert(`ã‚°ãƒ«ãƒ¼ãƒ—æŠ½å‡ºãƒ»ç™»éŒ²ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            } finally {
                activeZipProcessingCount--;
            }
        }
        
        // è‡ªå‹•ç™»éŒ²æ™‚ã®å…¨ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ï¼ˆãƒ•ã‚©ãƒ«ãƒ€ã‚°ãƒ«ãƒ¼ãƒ—åŒ–å¯¾å¿œï¼‰
        async function autoExtractAndRegisterAllFiles(zipFilePath, unityFiles, zipFileName) {
            // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ•ã‚©ãƒ«ãƒ€åˆ¥ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
            const folderGroups = groupFilesByFolder(unityFiles);
            
            // ãƒ•ã‚©ãƒ«ãƒ€ã”ã¨ã«å‡¦ç†
            for (const [folderPath, files] of Object.entries(folderGroups)) {
                if (files.length === 1) {
                    // å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆã¯å€‹åˆ¥ç™»éŒ²
                    await extractAndRegisterUnitypackage(zipFilePath, files[0], zipFileName);
                } else {
                    // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆã¯çµåˆç™»éŒ²
                    await extractAndRegisterGroupedUnitypackages(zipFilePath, files, zipFileName, folderPath);
                }
            }
        }
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å‡¦ç†ãƒ•ãƒ©ã‚°ï¼ˆä¸¦è¡Œå‡¦ç†æ•°ã‚’ç®¡ç†ï¼‰
        let activeZipProcessingCount = 0;
        const MAX_CONCURRENT_ZIP_PROCESSING = 3;
        
        // ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸãƒ•ã‚©ãƒ«ãƒ€ã®ãƒ«ãƒ¼ãƒˆãƒ‘ã‚¹æƒ…å ±ã‚’ä¿æŒ
        let currentDroppedFolderPaths = new Map(); // folderName -> rootPath
        
        // ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹ã‚’ç‰¹å®šã™ã‚‹é–¢æ•°
        function findRootFolderPath(filePath, folderName) {
            try {
                // ãƒ•ã‚©ãƒ«ãƒ€åãŒå«ã¾ã‚Œã‚‹æœ€ä¸Šä½ã®ãƒ‘ã‚¹ã‚’æ¢ã™
                const normalizedPath = filePath.replace(/\//g, '\\');
                const pathParts = normalizedPath.split('\\');
                
                // folderNameãŒå«ã¾ã‚Œã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ¢ã™
                const folderIndex = pathParts.findIndex(part => part === folderName);
                
                if (folderIndex !== -1) {
                    // folderNameã¾ã§ã®ãƒ‘ã‚¹ã‚’çµåˆã—ã¦ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹ã¨ã™ã‚‹
                    const rootParts = pathParts.slice(0, folderIndex + 1);
                    const rootPath = rootParts.join('\\');
                    console.log('ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹ç‰¹å®š:', {
                        filePath,
                        folderName,
                        pathParts,
                        folderIndex,
                        rootPath
                    });
                    return rootPath;
                } else {
                    // folderNameãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã€ç›´æ¥ã®è¦ªãƒ•ã‚©ãƒ«ãƒ€ã‚’è¿”ã™
                    console.warn('ãƒ•ã‚©ãƒ«ãƒ€åãŒãƒ‘ã‚¹ã«è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:', { filePath, folderName });
                    return filePath.substring(0, filePath.lastIndexOf('\\'));
                }
            } catch (error) {
                console.error('ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹ç‰¹å®šã‚¨ãƒ©ãƒ¼:', error);
                // ã‚¨ãƒ©ãƒ¼æ™‚ã¯å¾“æ¥ã®æ–¹æ³•ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                return filePath.substring(0, filePath.lastIndexOf('\\'));
            }
        }
        
        // Unitypackageã‚’æŠ½å‡ºãƒ»ç™»éŒ²
        async function extractAndRegisterUnitypackage(zipFilePath, unityFile, zipFileName) {
            console.log('extractAndRegisterUnitypackageå‘¼ã³å‡ºã—:', {
                zipFilePath,
                unityFile,
                zipFileName
            });
            
            // ä¸¦è¡Œå‡¦ç†æ•°ãƒã‚§ãƒƒã‚¯
            if (activeZipProcessingCount >= MAX_CONCURRENT_ZIP_PROCESSING) {
                console.warn(`æœ€å¤§ä¸¦è¡Œå‡¦ç†æ•°(${MAX_CONCURRENT_ZIP_PROCESSING})ã«é”ã—ãŸãŸã‚`, unityFile.fileName || unityFile.name || 'Unknown', 'ã‚’å¾…æ©Ÿã—ã¾ã™');
                // å‡¦ç†æ•°ãŒæ¸›ã‚‹ã¾ã§å¾…æ©Ÿ
                while (activeZipProcessingCount >= MAX_CONCURRENT_ZIP_PROCESSING) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            activeZipProcessingCount++;
            
            
            try {
                // è¨­å®šã‹ã‚‰ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’å–å¾—
                const archiveDir = await window.electronAPI.fs.getArchiveDir();
                
                // ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰Unitypackageã‚’æŠ½å‡º
                // fullPathãŒã‚ã‚‹å ´åˆã¯å„ªå…ˆã—ã¦ä½¿ç”¨ã€ãªã‘ã‚Œã°fileNameã‚’ä½¿ç”¨
                const unitypackageEntry = {
                    path: unityFile.fullPath || unityFile.fileName,
                    name: unityFile.fileName || unityFile.name
                };
                
                const extractResult = await window.electronAPI.zip.extractUnitypackage(
                    zipFilePath, 
                    unitypackageEntry, 
                    archiveDir
                );
                
                console.log('æŠ½å‡ºçµæœ:', extractResult);
                
                if (!extractResult || !extractResult.success) {
                    console.error('è©³ç´°ãªæŠ½å‡ºã‚¨ãƒ©ãƒ¼:', extractResult);
                    alert(`æŠ½å‡ºã«å¤±æ•—ã—ã¾ã—ãŸ: ${extractResult?.error || 'Unknown error'}\n\nè©³ç´°æƒ…å ±:\n- ZIPãƒ•ã‚¡ã‚¤ãƒ«: ${zipFilePath}\n- å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«: ${unityFile.fileName || unityFile.name || 'Unknown'}\n- ãƒ•ãƒ«ãƒ‘ã‚¹: ${unityFile.fullPath || unityFile.path || 'N/A'}`);
                    return;
                }
                
                // æŠ½å‡ºã—ãŸUnitypackageãƒ•ã‚¡ã‚¤ãƒ«ã‚’å•†å“ã¨ã—ã¦ç™»éŒ²
                const fileName = unityFile.fileName || unityFile.name || 'Unknown';
                const productData = {
                    name: fileName.replace(/\.unitypackage$/i, ''),
                    category: '',
                    tags: '',
                    description: `${fileName}`,
                    booth_url: '',
                    thumbnail_url: '',
                    file_path: extractResult.extractedPath,
                    author: '',
                    avatar_ids: ''
                };
                
                // è³¼å…¥å±¥æ­´ã‹ã‚‰å€™è£œå•†å“ã‚’æ¤œç´¢ã—ã¦è¡¨ç¤º
                const purchaseHistoryData = JSON.parse(localStorage.getItem('boothPurchaseHistory') || '[]');
                
                if (purchaseHistoryData.length > 0) {
                    // ZIPãƒ•ã‚¡ã‚¤ãƒ«åã¨Unitypackageãƒ•ã‚¡ã‚¤ãƒ«åã§å€™è£œã‚’æ¤œç´¢
                    const zipCandidates = findCandidatesForFile(zipFileName);
                    const unityCandidates = findCandidatesForFile(unityFile.fileName || unityFile.name || '');
                    
                    // é‡è¤‡é™¤å»ã—ã¦å€™è£œã‚’ãƒãƒ¼ã‚¸
                    const allCandidates = [...zipCandidates];
                    unityCandidates.forEach(candidate => {
                        if (!allCandidates.some(existing => existing.boothUrl === candidate.boothUrl)) {
                            allCandidates.push(candidate);
                        }
                    });
                    
                    if (allCandidates.length > 0) {
                        // æœ€é«˜ã‚¹ã‚³ã‚¢ã®å€™è£œã‚’ãƒã‚§ãƒƒã‚¯
                        const topCandidate = allCandidates[0];
                        const isHighConfidenceMatch = topCandidate.matchScore >= 0.7; // 70%ä»¥ä¸Šã§è‡ªå‹•ç™»éŒ²
                        
                        if (isHighConfidenceMatch) {
                            // 70%ä»¥ä¸Šãƒãƒƒãƒã®å ´åˆã¯ç¢ºèªãªã—ã§è‡ªå‹•ç™»éŒ²
                            const matchPercentage = Math.round(topCandidate.matchScore * 100);
                            
                            // å•†å“ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
                            productData.name = topCandidate.title;
                            productData.booth_url = topCandidate.boothUrl;
                            productData.thumbnail_url = topCandidate.thumbnailUrl;
                            productData.author = topCandidate.author;
                            productData.description = `${fileName} (è‡ªå‹•ãƒãƒƒãƒ ${matchPercentage}%: ${topCandidate.bestMatch})`;
                            
                            // å•†å“ã‚’ç™»éŒ²
                            console.log('è‡ªå‹•ãƒãƒƒãƒã§å•†å“ã‚’ç™»éŒ²ã—ã¾ã™:', productData);
                            await registerProduct(productData);
                            
                            // ZIPãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å‡¦ç†
                            await handleZipFileArchive(zipFilePath);
                            
                            return;
                        } else {
                            // 70%æœªæº€ã®å ´åˆã¯å€™è£œé¸æŠãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤º
                            const matchPercentage = Math.round(topCandidate.matchScore * 100);
                            
                            // ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã—ã¦é †æ¬¡å‡¦ç†
                            modalQueue.push({
                                fileName: zipFileName,
                                candidates: allCandidates,
                                productData: productData
                            });
                            
                            // ã‚­ãƒ¥ãƒ¼å‡¦ç†ã‚’é–‹å§‹
                            await processModalQueue();
                            
                            // å€™è£œé¸æŠå¾…ã¡ãªã®ã§ã€ã“ã“ã§å‡¦ç†ã‚’çµ‚äº†
                            return;
                        }
                    }
                }
                
                // å€™è£œãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯é€šå¸¸ã®å‡¦ç†ã‚’ç¶™ç¶š
                console.log('å•†å“ã‚’ç™»éŒ²ã—ã¾ã™:', productData);
                await registerProduct(productData);
                
                // ZIPãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å‡¦ç†
                await handleZipFileArchive(zipFilePath);
                
            } catch (error) {
                console.error('æŠ½å‡ºãƒ»ç™»éŒ²ã‚¨ãƒ©ãƒ¼:', error);
                alert(`æŠ½å‡ºãƒ»ç™»éŒ²ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            } finally {
                // å‡¦ç†ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›å°‘
                activeZipProcessingCount--;
            }
        }
        
        // ZIPãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å‡¦ç†
        async function handleZipFileArchive(zipFilePath) {
            try {
                const settings = await window.electronAPI.settings.get();
                if (settings.autoArchive === true) {
                    console.log('ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å‡¦ç†é–‹å§‹:', zipFilePath);
                    
                    const archiveResult = await window.electronAPI.fs.moveToArchive(zipFilePath);
                    console.log('ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–çµæœ:', archiveResult);
                    
                    if (archiveResult.success) {
                        console.log('ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã«ç§»å‹•ã—ã¾ã—ãŸ:', archiveResult.newPath);
                    } else {
                        console.error('ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å¤±æ•—:', archiveResult.error);
                    }
                }
            } catch (error) {
                console.error('ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚¨ãƒ©ãƒ¼:', error);
            }
        }
        
        // æ··åœ¨ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†: ãƒ•ã‚©ãƒ«ãƒ€å†…ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆçµåˆï¼‰ã¨å˜ä½“ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆå€‹åˆ¥ï¼‰ã‚’åˆ†é¡å‡¦ç†
        async function processedMixedDrop(files, dataTransferItems) {
            
            // unitypackageãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŠ½å‡º
            const unityPackageFiles = files.filter(file => 
                file.name.toLowerCase().endsWith('.unitypackage')
            );
            
            // ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œå‡º
            const zipFiles = files.filter(file => 
                file.name.toLowerCase().endsWith('.zip')
            );
            
            // ãƒ•ã‚©ãƒ«ãƒ€ã‚’æ¤œå‡º
            const folderItems = [];
            if (dataTransferItems) {
                for (let item of dataTransferItems) {
                    if (item.kind === 'file') {
                        const entry = item.webkitGetAsEntry();
                        if (entry && entry.isDirectory) {
                            folderItems.push(entry);
                        }
                    }
                }
            }
            
            
            // ãƒ•ã‚©ãƒ«ãƒ€ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŠ½å‡ºã—ã¦å‡¦ç†
            if (folderItems.length > 0) {
                
                // å„ãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰unitypackageãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŠ½å‡º
                for (let i = 0; i < folderItems.length; i++) {
                    const folderEntry = folderItems[i];
                    
                    try {
                        const folderFiles = await extractFilesFromFolder(folderEntry);
                        
                        if (folderFiles.length > 0) {
                            await processFilesAsOneProduct(folderFiles, folderEntry.name);
                        } else {
                        }
                    } catch (error) {
                        console.error(`âŒ ãƒ•ã‚©ãƒ«ãƒ€å‡¦ç†ã‚¨ãƒ©ãƒ¼ (${folderEntry.name}):`, error);
                        // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚ãƒ«ãƒ¼ãƒ—ã¯ç¶™ç¶š
                    }
                }
                
                // ZIPãƒ•ã‚¡ã‚¤ãƒ«ã®å‡¦ç†
                if (zipFiles.length > 0) {
                    for (const zipFile of zipFiles) {
                        try {
                            await processZipFile(zipFile.path || zipFile.name);
                        } catch (error) {
                            console.error('ZIPãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                            alert(`ZIPãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚¨ãƒ©ãƒ¼: ${zipFile.name} - ${error.message}`);
                        }
                    }
                }
                
                // å˜ä½“unitypackageãƒ•ã‚¡ã‚¤ãƒ«ã‚‚å‡¦ç†
                if (unityPackageFiles.length > 0) {
                    const standaloneFilePaths = unityPackageFiles.map(f => f.path || f.name);
                    await processFilesAsSeparateProducts(standaloneFilePaths);
                }
                
                let message = `${folderItems.length}å€‹ã®ãƒ•ã‚©ãƒ«ãƒ€ã‚’çµ±åˆå•†å“ã¨ã—ã¦è¿½åŠ `;
                if (zipFiles.length > 0) {
                    message += `ã€${zipFiles.length}å€‹ã®ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡¦ç†`;
                }
                if (unityPackageFiles.length > 0) {
                    message += `ã€${unityPackageFiles.length}å€‹ã®å˜ä½“ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å€‹åˆ¥å•†å“ã¨ã—ã¦è¿½åŠ `;
                }
                
                loadProducts();
                return;
            }
            
            // ZIPãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿ãŒãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸå ´åˆã®å‡¦ç†
            if (zipFiles.length > 0 && folderItems.length === 0) {
                for (const zipFile of zipFiles) {
                    try {
                        await processZipFile(zipFile.path || zipFile.name);
                    } catch (error) {
                        console.error('ZIPãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                        alert(`ZIPãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚¨ãƒ©ãƒ¼: ${zipFile.name} - ${error.message}`);
                    }
                }
                loadProducts();
                return;
            }
            
            // ãƒ•ã‚©ãƒ«ãƒ€å†…ãƒ•ã‚¡ã‚¤ãƒ«ã¨å˜ä½“ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åˆ†é¡
            const folderGroups = new Map(); // ãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹ -> ãƒ•ã‚¡ã‚¤ãƒ«é…åˆ—
            const standaloneFiles = []; // å˜ä½“ãƒ•ã‚¡ã‚¤ãƒ«
            
            for (const file of unityPackageFiles) {
                const filePath = file.path || file.name;
                
                // webkitRelativePathãŒã‚ã‚‹å ´åˆã¯ç¢ºå®Ÿã«ãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰
                if (file.webkitRelativePath && file.webkitRelativePath !== '') {
                    const pathParts = file.webkitRelativePath.split('/');
                    const folderName = pathParts[0];
                    
                    if (!folderGroups.has(folderName)) {
                        folderGroups.set(folderName, {
                            folderName: folderName,
                            files: []
                        });
                    }
                    folderGroups.get(folderName).files.push(filePath);
                    continue;
                }
                
                // ãƒ‘ã‚¹ãŒã‚ã‚‹å ´åˆã€ãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰æ¥ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‹ãƒã‚§ãƒƒã‚¯
                if (filePath && filePath !== file.name && (filePath.includes('/') || filePath.includes('\\'))) {
                    const separator = filePath.includes('/') ? '/' : '\\';
                    const folderPath = filePath.substring(0, filePath.lastIndexOf(separator));
                    const folderName = folderPath.substring(folderPath.lastIndexOf(separator) + 1);
                    
                    if (folderName && folderName !== '') {
                        if (!folderGroups.has(folderPath)) {
                            folderGroups.set(folderPath, {
                                folderName: folderName,
                                files: []
                            });
                        }
                        folderGroups.get(folderPath).files.push(filePath);
                    } else {
                        standaloneFiles.push(filePath);
                    }
                } else {
                    standaloneFiles.push(filePath);
                }
            }
            
            
            // å˜ä½“ãƒ•ã‚¡ã‚¤ãƒ«è¤‡æ•°ã®å ´åˆã¯å¸¸ã«å€‹åˆ¥ç™»éŒ²
            if (folderGroups.size > 0 && standaloneFiles.length === 0) {
                // å…¨ã¦ãŒãƒ•ã‚©ãƒ«ãƒ€ã‚°ãƒ«ãƒ¼ãƒ—ã®å ´åˆã€å€‹åˆ¥å•†å“ã¨ã—ã¦å‡¦ç†
                const allFiles = [];
                for (const [folderPath, groupData] of folderGroups) {
                    allFiles.push(...groupData.files);
                }
                await processFilesAsSeparateProducts(allFiles);
            } else {
                // æ··åœ¨ã—ã¦ã„ã‚‹å ´åˆã¯å…ƒã®å‡¦ç†
                
                // ãƒ•ã‚©ãƒ«ãƒ€ã‚°ãƒ«ãƒ¼ãƒ—å‡¦ç†
                for (const [folderPath, groupData] of folderGroups) {
                    if (groupData.files.length > 0) {
                        try {
                            await processFilesAsOneProduct(groupData.files, groupData.folderName);
                        } catch (error) {
                            // ã‚¨ãƒ©ãƒ¼å‡¦ç†ã¯å†…éƒ¨ã§è¡Œã†
                        }
                    }
                }
                
                // å˜ä½“ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†
                if (standaloneFiles.length > 0) {
                    try {
                        await processFilesAsSeparateProducts(standaloneFiles);
                    } catch (error) {
                        // ã‚¨ãƒ©ãƒ¼å‡¦ç†ã¯å†…éƒ¨ã§è¡Œã†
                    }
                }
                
            }
            
            loadProducts();
        }
        
        // ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡¦ç†
        async function processDroppedFiles(files) {
            
            for (let i = 0; i < files.length; i++) {
                const filePath = files[i];
                // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‹ã‚‰æ‹¡å¼µå­ã‚’é™¤ã„ãŸãƒ•ã‚¡ã‚¤ãƒ«åã‚’å–å¾—
                const rawFileName = typeof filePath === 'string' 
                    ? filePath.split('\\').pop().split('/').pop()
                    : filePath.name;
                    
                const { normalizedName } = extractSearchKeywords(rawFileName);
                
                // ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰å•†å“åã‚’æ¨æ¸¬ï¼ˆå„å˜èªã®å…ˆé ­ã‚’å¤§æ–‡å­—ã«ï¼‰
                const productName = normalizedName
                    .replace(/\b\w/g, l => l.toUpperCase());
                
                // è‡ªå‹•ã§ã‚«ãƒ†ã‚´ãƒªã‚’æ¨æ¸¬
                let category = 'ãã®ä»–';
                const lowerName = normalizedName.toLowerCase();
                if (lowerName.includes('avatar') || lowerName.includes('ã‚¢ãƒã‚¿ãƒ¼')) {
                    category = 'ã‚¢ãƒã‚¿ãƒ¼æœ¬ä½“';
                } else if (lowerName.includes('costume') || lowerName.includes('cloth') || lowerName.includes('è¡£è£…')) {
                    category = 'è¡£è£…';
                } else if (lowerName.includes('accessory') || lowerName.includes('ã‚¢ã‚¯ã‚»ã‚µãƒªãƒ¼')) {
                    category = 'ã‚¢ã‚¯ã‚»ã‚µãƒªãƒ¼';
                } else if (lowerName.includes('hair') || lowerName.includes('é«ª')) {
                    category = 'é«ªå‹';
                } else if (lowerName.includes('tool') || lowerName.includes('ãƒ„ãƒ¼ãƒ«') || lowerName.includes('editor') || lowerName.includes('utility')) {
                    category = 'ãƒ„ãƒ¼ãƒ«';
                } else if (lowerName.includes('pose') || lowerName.includes('ãƒãƒ¼ã‚º') || lowerName.includes('motion') || lowerName.includes('anim')) {
                    category = 'ãƒãƒ¼ã‚º';
                } else if (lowerName.includes('world') || lowerName.includes('ãƒ¯ãƒ¼ãƒ«ãƒ‰') || lowerName.includes('scene')) {
                    category = 'ãƒ¯ãƒ¼ãƒ«ãƒ‰';
                }
                
                const productData = {
                    name: productName,
                    category: category,
                    booth_url: '',
                    thumbnail_url: '',
                    file_path: typeof filePath === 'string' ? filePath : filePath.path,
                    description: `ãƒ•ã‚¡ã‚¤ãƒ«: ${fileName}.unitypackage`,
                    author: '',
                    avatar_ids: '',
                    tags: ''
                };
                
                try {
                    if (window.electronAPI) {
                        await window.electronAPI.database.addProduct(productData);
                        
                        // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰è‡ªå‹•ã§Booth URLå–å¾—ã¨ã‚µãƒ ãƒã‚¤ãƒ«è¨­å®š
                        const actualFileName = typeof filePath === 'string' 
                            ? filePath.split('\\').pop().split('/').pop() 
                            : filePath.name;
                        
                        try {
                            const boothSearchResult = await window.electronAPI.booth.searchByFilename(actualFileName);
                            if (boothSearchResult.success && boothSearchResult.results && boothSearchResult.results.length > 0) {
                                const firstResult = boothSearchResult.results[0];
                                if (firstResult.url && firstResult.url.includes('booth.pm') && firstResult.url.includes('/items/')) {
                                    // Booth URLã‚’æ›´æ–°
                                    productData.booth_url = firstResult.url;
                                    
                                    if (boothSearchResult.highConfidence !== false) {
                                        try {
                                            const thumbnailResult = await window.electronAPI.fetch.thumbnail(firstResult.url);
                                            if (thumbnailResult.success && thumbnailResult.thumbnailUrl) {
                                                productData.thumbnail_url = thumbnailResult.thumbnailUrl;
                                            }
                                        } catch (thumbnailError) {
                                            // ã‚µãƒ ãƒã‚¤ãƒ«å–å¾—å¤±æ•—ã¯è‡´å‘½çš„ã§ã¯ãªã„
                                        }
                                    } else {
                                        // ä½ä¿¡é ¼åº¦ã®å ´åˆã¯ã‚µãƒ ãƒã‚¤ãƒ«ã‚’å–å¾—ã›ãšè­¦å‘Šè¡¨ç¤º
                                        console.warn('ä¿¡é ¼åº¦ãŒä½ã„ãƒãƒƒãƒã®ãŸã‚ã‚µãƒ ãƒã‚¤ãƒ«ã‚’å–å¾—ã—ã¾ã›ã‚“ã§ã—ãŸ:', firstResult.title);
                                    }
                                    
                                    // æ›´æ–°ã•ã‚ŒãŸå•†å“ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
                                    const products = await window.electronAPI.database.getProducts();
                                    const addedProduct = products[products.length - 1];
                                    if (addedProduct) {
                                        await window.electronAPI.database.updateProduct(addedProduct.id, {
                                            ...addedProduct,
                                            booth_url: productData.booth_url,
                                            thumbnail_url: productData.thumbnail_url
                                        });
                                    }
                                }
                            }
                        } catch (boothError) {
                            // Boothæ¤œç´¢å¤±æ•—ã¯è‡´å‘½çš„ã§ã¯ãªã„
                        }
                        
                        // è¨­å®šç¢ºèªå¾Œã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã«ç§»å‹•
                        const settings = await window.electronAPI.settings.get();
                        if (settings.autoArchive === true) {
                            const archiveResult = await window.electronAPI.fs.moveToArchive(productData.file_path);
                            if (archiveResult.success) {
                                // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æ›´æ–°
                                const products = await window.electronAPI.database.getProducts();
                                const addedProduct = products[products.length - 1]; // æœ€å¾Œã«è¿½åŠ ã•ã‚ŒãŸå•†å“
                                if (addedProduct) {
                                    await window.electronAPI.database.updateProduct(addedProduct.id, {
                                        ...addedProduct,
                                        file_path: archiveResult.newPath
                                    });
                                }
                            } else {
                                console.warn('ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ç§»å‹•ã«å¤±æ•—:', archiveResult.error);
                            }
                        } else {
                        }
                    }
                } catch (error) {
                    console.error('å•†å“è¿½åŠ ã‚¨ãƒ©ãƒ¼:', error);
                }
            }
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’å†èª­ã¿è¾¼ã¿
            await loadProducts();
            
            const successCount = files.length;
            
            // è¨­å®šã‚’ç¢ºèªã—ã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å¤‰æ›´
            const settings = await window.electronAPI.settings.get();
            if (settings.autoArchive === true) {
                alert(`${successCount}å€‹ã®å•†å“ã‚’è¿½åŠ ã—ã¾ã—ãŸï¼\nãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãƒ•ã‚©ãƒ«ãƒ€ã«ç§»å‹•ã•ã‚Œã¾ã—ãŸã€‚`);
            } else {
                alert(`${successCount}å€‹ã®å•†å“ã‚’è¿½åŠ ã—ã¾ã—ãŸï¼`);
            }
        }
        
        // è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆé–¢æ•°
        function switchToGridView() {
            isListView = false;
            selectedProducts.clear();
            updateViewButtons();
            filterProducts(); // ãƒ•ã‚£ãƒ«ã‚¿ã¨ä¸¦ã³é †ã‚’é©ç”¨ã—ã¦å†æç”»
            updateSelectionBlock();
        }
        
        function switchToListView() {
            isListView = true;
            updateViewButtons();
            filterProducts(); // ãƒ•ã‚£ãƒ«ã‚¿ã¨ä¸¦ã³é †ã‚’é©ç”¨ã—ã¦å†æç”»
        }
        
        function updateViewButtons() {
            const gridBtn = document.getElementById('gridViewBtn');
            const listBtn = document.getElementById('listViewBtn');
            
            if (isListView) {
                gridBtn.style.backgroundColor = '#6b7280';
                gridBtn.style.border = 'none';
                listBtn.style.backgroundColor = '#4b5563';
                listBtn.style.border = '1px solid #6b7280';
            } else {
                gridBtn.style.backgroundColor = '#4b5563';
                gridBtn.style.border = '1px solid #6b7280';
                listBtn.style.backgroundColor = '#6b7280';
                listBtn.style.border = 'none';
            }
        }
        
        // é¸æŠæ©Ÿèƒ½
        function toggleProductSelection(productId) {
            if (selectedProducts.has(productId)) {
                selectedProducts.delete(productId);
            } else {
                selectedProducts.add(productId);
            }
            
            // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®çŠ¶æ…‹ã ã‘ã‚’æ›´æ–°ï¼ˆå†ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã—ãªã„ï¼‰
            updateCheckboxStates();
            updateSelectionBlock();
        }
        
        function updateCheckboxStates() {
            // ç¾åœ¨è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®çŠ¶æ…‹ã‚’æ›´æ–°
            const checkboxes = document.querySelectorAll('.item-checkbox');
            checkboxes.forEach(checkbox => {
                const productId = parseInt(checkbox.parentElement.querySelector('[onclick*="toggleProductSelection"]').getAttribute('onclick').match(/\d+/)[0]);
                checkbox.checked = selectedProducts.has(productId);
            });
        }
        
        function updateSelectionBlock() {
            const selectionBlock = document.getElementById('selectionBlock');
            const selectedCount = document.getElementById('selectedCount');
            const productsContainer = document.getElementById('products');
            
            if (selectedProducts.size > 0) {
                selectedCount.textContent = selectedProducts.size;
                
                // é¸æŠã•ã‚ŒãŸå•†å“ã®å…±é€šã‚¿ã‚°ã‚’å–å¾—ã—ã¦ãƒ—ãƒªã‚»ãƒƒãƒˆ
                prefillCommonTags();
                
                // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ï¼šä¸‹ã‹ã‚‰ã‚¹ãƒ©ã‚¤ãƒ‰ã‚¢ãƒƒãƒ—ã—ãªãŒã‚‰è¡¨ç¤º
                selectionBlock.style.visibility = 'visible';
                selectionBlock.style.opacity = '1';
                selectionBlock.style.transform = 'translateY(0)';
                
                // ã‚¿ã‚°ç·¨é›†ãƒœãƒƒã‚¯ã‚¹ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹æ™‚ã¯ååˆ†ãªä½™ç™½ã‚’ç¢ºä¿
                productsContainer.style.paddingBottom = '200px';
            } else {
                // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆï¼šä¸‹ã«ã‚¹ãƒ©ã‚¤ãƒ‰ãƒ€ã‚¦ãƒ³ã—ãªãŒã‚‰éè¡¨ç¤º
                selectionBlock.style.opacity = '0';
                selectionBlock.style.transform = 'translateY(100%)';
                
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†å¾Œã«visibilityã‚’å¤‰æ›´
                setTimeout(() => {
                    if (selectedProducts.size === 0) {
                        selectionBlock.style.visibility = 'hidden';
                    }
                }, 300); // ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³æ™‚é–“ã¨åŒã˜
                
                // ã‚¿ã‚°ç·¨é›†ãƒœãƒƒã‚¯ã‚¹ãŒéè¡¨ç¤ºã®æ™‚ã¯é€šå¸¸ã®ä½™ç™½
                productsContainer.style.paddingBottom = '20px';
            }
        }
        
        // é¸æŠã•ã‚ŒãŸå•†å“ã®å…±é€šã‚¿ã‚°ã‚’ãƒ—ãƒªãƒ•ã‚£ãƒ«
        function prefillCommonTags() {
            if (selectedProducts.size === 0) return;
            
            const selectedProductsList = Array.from(selectedProducts).map(id => 
                products.find(p => p.id === id)
            ).filter(p => p);
            
            if (selectedProductsList.length === 0) return;
            
            // å„å•†å“ã®ã‚¿ã‚°ã‚’é…åˆ—ã¨ã—ã¦å–å¾—
            const productTagArrays = selectedProductsList.map(product => {
                return product.tags ? product.tags.split(',').map(tag => tag.trim()).filter(tag => tag) : [];
            });
            
            let commonTags = [];
            
            if (selectedProducts.size === 1) {
                // 1å€‹é¸æŠã®å ´åˆï¼šãã®ã‚¢ã‚¤ãƒ†ãƒ ã®ã™ã¹ã¦ã®ã‚¿ã‚°ã‚’è¡¨ç¤º
                commonTags = productTagArrays[0] || [];
            } else {
                // è¤‡æ•°é¸æŠã®å ´åˆï¼šã™ã¹ã¦ã®å•†å“ã«å…±é€šã™ã‚‹ã‚¿ã‚°ã®ã¿è¡¨ç¤º
                if (productTagArrays.length > 0) {
                    commonTags = productTagArrays[0].filter(tag => 
                        productTagArrays.every(tagArray => tagArray.includes(tag))
                    );
                }
            }
            
            // å…±é€šã‚¿ã‚°ã‚’ selectedTagsForEditing ã«è¿½åŠ 
            selectedTagsForEditing.clear();
            commonTags.forEach(tag => selectedTagsForEditing.add(tag));
            
            // ã‚¿ã‚°è¡¨ç¤ºã‚’æ›´æ–°
            updateTagsDisplay();
        }
        
        function clearSelection() {
            selectedProducts.clear();
            selectedTagsForEditing.clear();
            updateCheckboxStates();
            updateSelectionBlock();
            updateTagsDisplay();
        }
        
        // YouTubeé¢¨ã‚¿ã‚°ç·¨é›†æ©Ÿèƒ½
        let selectedTagsForEditing = new Set();
        let allAvailableTags = new Set();
        
        function updateTagsDisplay() {
            const selectedTagsArea = document.getElementById('selectedTagsArea');
            selectedTagsArea.innerHTML = '';
            
            selectedTagsForEditing.forEach(tag => {
                const tagChip = document.createElement('div');
                tagChip.style.cssText = `
                    display: inline-flex;
                    align-items: center;
                    background-color: #059669;
                    color: white;
                    padding: 4px 10px;
                    border-radius: 12px;
                    font-size: 13px;
                    gap: 5px;
                    font-weight: 500;
                `;
                
                tagChip.innerHTML = `
                    <span>${tag}</span>
                    <button onclick="removeTagFromSelection('${tag}')" style="
                        background: none;
                        border: none;
                        color: white;
                        cursor: pointer;
                        padding: 0;
                        width: 16px;
                        height: 16px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        border-radius: 50%;
                        font-size: 11px;
                        line-height: 1;
                    " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.2)'" onmouseout="this.style.backgroundColor='transparent'">Ã—</button>
                `;
                
                selectedTagsArea.appendChild(tagChip);
            });
        }
        
        // éãƒ¢ãƒ¼ãƒ€ãƒ«é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 
        function showNotification(message, type = 'info') {
            // æ—¢å­˜ã®é€šçŸ¥ãŒã‚ã‚Œã°å‰Šé™¤
            const existingNotification = document.getElementById('notification-toast');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            // æ–°ã—ã„é€šçŸ¥ã‚’ä½œæˆ
            const notification = document.createElement('div');
            notification.id = 'notification-toast';
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? '#10b981' : '#3b82f6'};
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                z-index: 10000;
                animation: slideIn 0.3s ease-out;
            `;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // 3ç§’å¾Œã«è‡ªå‹•çš„ã«å‰Šé™¤
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.animation = 'slideOut 0.3s ease-out';
                    setTimeout(() => notification.remove(), 300);
                }
            }, 3000);
        }
        
        function getAllTagsFromProducts() {
            const tags = new Set();
            products.forEach(product => {
                if (product.tags) {
                    product.tags.split(',').forEach(tag => {
                        const trimmed = tag.trim();
                        if (trimmed) tags.add(trimmed);
                    });
                }
            });
            return Array.from(tags).sort();
        }
        
        function showTagSuggestions(query) {
            const suggestionsDiv = document.getElementById('tagSuggestions');
            const allTags = getAllTagsFromProducts();
            
            if (!query.trim()) {
                // ç©ºã®å ´åˆã¯æ—¢å­˜ã®ã‚¿ã‚°ã‚’è¡¨ç¤º
                const filteredTags = allTags.filter(tag => !selectedTagsForEditing.has(tag));
                displayTagSuggestions(filteredTags.slice(0, 10));
                return;
            }
            
            const filteredTags = allTags.filter(tag => 
                tag.toLowerCase().includes(query.toLowerCase()) && 
                !selectedTagsForEditing.has(tag)
            );
            
            displayTagSuggestions(filteredTags.slice(0, 10));
        }
        
        function displayTagSuggestions(tags) {
            const suggestionsDiv = document.getElementById('tagSuggestions');
            
            if (tags.length === 0) {
                suggestionsDiv.style.display = 'none';
                return;
            }
            
            suggestionsDiv.innerHTML = '';
            tags.forEach(tag => {
                const suggestion = document.createElement('div');
                suggestion.style.cssText = `
                    padding: 3px 4px;
                    cursor: pointer;
                    color: white;
                    font-size: 11px;
                    border-bottom: 1px solid #6b7280;
                `;
                suggestion.textContent = tag;
                suggestion.onmouseover = () => suggestion.style.backgroundColor = '#6b7280';
                suggestion.onmouseout = () => suggestion.style.backgroundColor = 'transparent';
                suggestion.onmousedown = (e) => {
                    e.preventDefault(); // blurã‚¤ãƒ™ãƒ³ãƒˆã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                    addTagToSelection(tag);
                };
                
                suggestionsDiv.appendChild(suggestion);
            });
            
            suggestionsDiv.style.display = 'block';
        }
        
        function hideTagSuggestions() {
            setTimeout(() => {
                document.getElementById('tagSuggestions').style.display = 'none';
            }, 200);
        }
        
        function handleTagInput(event) {
            
            // Enterã‚­ãƒ¼ã®å‡¦ç†ã®ã¿
            if (event.key === 'Enter') {
                event.preventDefault();
                event.stopPropagation();
                
                const input = event.target;
                const tag = input.value.trim();
                
                if (tag && !selectedTagsForEditing.has(tag)) {
                    addTagToSelection(tag);
                }
                
                input.value = '';
                hideTagSuggestions();
                return;
            }
            
            // ãƒãƒƒã‚¯ã‚¹ãƒšãƒ¼ã‚¹å‡¦ç†
            if (event.key === 'Backspace' && event.target.value === '') {
                // å…¥åŠ›ãŒç©ºã§ãƒãƒƒã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã‚’æŠ¼ã—ãŸå ´åˆã€æœ€å¾Œã®ã‚¿ã‚°ã‚’å‰Šé™¤
                const tagsArray = Array.from(selectedTagsForEditing);
                if (tagsArray.length > 0) {
                    removeTagFromSelection(tagsArray[tagsArray.length - 1]);
                }
                return;
            }
        }
        
        // Store the last seen input value globally
        window.lastTagInputValue = '';
        
        function addTagFromInput() {
            const input = document.getElementById('tagInput');
            
            if (!input) {
                alert('å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                return;
            }
            
            // Try multiple methods to get the input value
            let tag = input.value ? input.value.trim() : '';
            
            // Fallback: try using getAttribute
            if (!tag) {
                const attrValue = input.getAttribute('value');
                tag = attrValue ? attrValue.trim() : '';
            }
            
            // Fallback: use last known value from global storage
            if (!tag && window.lastTagInputValue) {
                tag = window.lastTagInputValue.trim();
            }
            
            // Final fallback: try to get value through different property access
            if (!tag) {
                try {
                    const currentValue = input['value'] || '';
                    tag = currentValue.trim();
                } catch (e) {
                    // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
                }
            }
            
            if (!tag) {
                alert('ã‚¿ã‚°ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            if (selectedTagsForEditing.has(tag)) {
                alert('ã“ã®ã‚¿ã‚°ã¯æ—¢ã«è¿½åŠ ã•ã‚Œã¦ã„ã¾ã™');
                return;
            }
            
            addTagToSelection(tag);
            
            // Clear the stored value
            window.lastTagInputValue = '';
            
            // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«æˆ»ã™
            setTimeout(() => {
                const tagInput = document.getElementById('tagInput');
                if (tagInput) {
                    tagInput.focus();
                }
            }, 50);
        }
        
        function addTagToSelection(tag) {
            // ç„¡åŠ¹ãªå…¥åŠ›ã‚’é˜²ã
            if (!tag || typeof tag !== 'string' || tag.trim().length === 0) {
                return;
            }
            
            const trimmedTag = tag.trim();
            
            selectedTagsForEditing.add(trimmedTag);
            updateTagsDisplay();
            
            // Clear input field ONLY if called from addTagFromInput
            const currentStack = new Error().stack;
            if (currentStack.includes('addTagFromInput')) {
                const tagInputElement = document.getElementById('tagInput');
                if (tagInputElement) {
                    tagInputElement.value = '';
                }
            }
            
            hideTagSuggestions();
        }
        
        function removeTagFromSelection(tag) {
            selectedTagsForEditing.delete(tag);
            updateTagsDisplay();
        }
        
        async function applyTagsToSelected() {
            if (selectedProducts.size === 0) {
                alert('å•†å“ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            
            const tagsArray = Array.from(selectedTagsForEditing);
            const tagsString = tagsArray.join(', ');
            
            let successful = 0;
            let failed = 0;
            
            // å„é¸æŠå•†å“ã®ã‚¿ã‚°ã‚’æ›´æ–°
            for (const productId of selectedProducts) {
                try {
                    const product = products.find(p => p.id === productId);
                    if (product) {
                        // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’æ›´æ–°
                        const updatedProduct = {
                            ...product,
                            tags: tagsString
                        };
                        
                        if (window.electronAPI && window.electronAPI.database) {
                            await window.electronAPI.database.updateProduct(productId, updatedProduct);
                            successful++;
                            
                            // ãƒ­ãƒ¼ã‚«ãƒ«ã®productsé…åˆ—ã‚‚æ›´æ–°
                            const productIndex = products.findIndex(p => p.id === productId);
                            if (productIndex !== -1) {
                                products[productIndex] = updatedProduct;
                            }
                        }
                    }
                } catch (error) {
                    console.error('Failed to update product tags:', error);
                    failed++;
                }
            }
            
            // UIæ›´æ–°
            if (successful > 0) {
                // å•†å“ä¸€è¦§ã‚’å†æç”»
                await loadProducts();
                
                // ã‚¿ã‚°ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã®é¸æŠè‚¢ã‚’æ›´æ–°
                updateTagFilterSelect();
                
                // ã‚¿ã‚°ä¸€è¦§ã¯ã‚¯ãƒªã‚¢ã—ãªã„ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ‰‹å‹•ã§ã‚¯ãƒªã‚¢ã™ã‚‹ï¼‰
                // selectedTagsForEditing.clear();
                // updateTagsDisplay();
                
                // alertå‰ã«å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®çŠ¶æ…‹ã‚’ä¿å­˜
                const tagInputBeforeAlert = document.getElementById('tagInput');
                const tagInputValue = tagInputBeforeAlert ? tagInputBeforeAlert.value : '';
                
                // alertã®ä»£ã‚ã‚Šã«éãƒ¢ãƒ¼ãƒ€ãƒ«ãªé€šçŸ¥ã‚’è¡¨ç¤ºï¼ˆå…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œãªã„ï¼‰
                showNotification(`${successful}å€‹ã®å•†å“ã«ã‚¿ã‚°ã‚’é©ç”¨ã—ã¾ã—ãŸ`, 'success');
                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šshowNotificationãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„å ´åˆã¯alertã‚’ä½¿ç”¨
                if (typeof showNotification === 'undefined') {
                    alert(`${successful}å€‹ã®å•†å“ã«ã‚¿ã‚°ã‚’é©ç”¨ã—ã¾ã—ãŸ`);
                }
                
                // alertã®å¾Œã€ã™ãã«å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å¾©å…ƒ
                const tagInput = document.getElementById('tagInput');
                if (tagInput) {
                    // å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ãƒªã‚»ãƒƒãƒˆ
                    tagInput.disabled = false;
                    tagInput.readOnly = false;
                    tagInput.style.pointerEvents = 'auto';
                    tagInput.style.userSelect = 'text';
                    tagInput.style.cursor = 'text';
                    tagInput.tabIndex = 0;
                    tagInput.value = tagInputValue;
                    
                    // å³åº§ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’è¨­å®š
                    tagInput.focus();
                    
                    // è¿½åŠ ã®é…å»¶ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ï¼ˆä¿é™ºï¼‰
                    setTimeout(() => {
                        tagInput.focus();
                        tagInput.click();
                    }, 100);
                }
                
                // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ›´æ–°ã¯æ—¢ã«è¡Œã‚ã‚Œã¦ã„ã‚‹ãŸã‚ã€ã“ã“ã§ã®é‡è¤‡æ›´æ–°ã¯å‰Šé™¤
            }
            
            if (failed > 0) {
                alert(`${failed}å€‹ã®å•†å“ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ`);
            }
        }
        
        function deleteSelectedProducts() {
            if (selectedProducts.size === 0) return;
            
            const selectedProductsList = Array.from(selectedProducts).map(id => {
                const product = products.find(p => p.id === id);
                return product ? product.name : `ID: ${id}`;
            }).join('\nãƒ»');
            
            if (confirm(`ä»¥ä¸‹ã®${selectedProducts.size}å€‹ã®å•†å“ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\n\nãƒ»${selectedProductsList}`)) {
                const deletePromises = Array.from(selectedProducts).map(async (productId) => {
                    try {
                        await window.electronAPI.database.deleteProduct(productId);
                        return { success: true, id: productId };
                    } catch (error) {
                        console.error(`Failed to delete product ${productId}:`, error);
                        return { success: false, id: productId, error };
                    }
                });
                
                Promise.all(deletePromises).then(results => {
                    const successful = results.filter(r => r.success);
                    const failed = results.filter(r => !r.success);
                    
                    if (successful.length > 0) {
                        alert(`${successful.length}å€‹ã®å•†å“ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚`);
                        selectedProducts.clear();
                        loadProducts(); // ãƒ‡ãƒ¼ã‚¿ã‚’å†èª­ã¿è¾¼ã¿
                    }
                    
                    if (failed.length > 0) {
                        alert(`${failed.length}å€‹ã®å•†å“ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸã€‚`);
                    }
                });
            }
        }
        
        // å•†å“è¿½åŠ ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
        function openProductModal() {
            currentEditingProductId = null;
            document.getElementById('modalTitle').textContent = 'å•†å“ã‚’è¿½åŠ ';
            document.getElementById('productForm').reset();
            document.getElementById('thumbnailPreview').style.display = 'none';
            document.getElementById('multipleFilesArea').style.display = 'none';
            document.getElementById('selectedFileInfo').textContent = '';
            window.multipleFileData = null; // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
            selectedTagsForEditing.clear();
            updateTagsDisplay();
            document.getElementById('productModal').style.display = 'block';
            
            // ãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã®ã™ã¹ã¦ã®å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å®Œå…¨ã«ä¿®æ­£
            setTimeout(() => {
                const modalInputs = document.querySelectorAll('#productModal input[type="text"], #productModal input[type="url"], #productModal textarea');
                
                modalInputs.forEach((field, index) => {
                    // åŸºæœ¬ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¨­å®š
                    field.disabled = false;
                    field.readOnly = false;
                    field.tabIndex = 0;
                    
                    // CSSã‚’å®Œå…¨ã«ãƒªã‚»ãƒƒãƒˆ
                    field.style.cssText = field.style.cssText + '; pointer-events: auto !important; user-select: text !important; cursor: text !important;';
                    
                    // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ã‚¯ãƒªã‚¢
                    field.onclick = null;
                    field.onmousedown = null;
                    field.onfocus = null;
                    field.onblur = null;
                    
                    // æ–°ã—ã„ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
                    field.addEventListener('click', function(e) {
                        e.stopPropagation();
                        this.focus();
                    }, true);
                    
                    field.addEventListener('mousedown', function(e) {
                        e.stopPropagation();
                    }, true);
                });
            }, 100);
            
            // ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤ºå¾Œã«æœ€åˆã®å…¥åŠ›æ¬„ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
            setTimeout(() => {
                document.getElementById('productName').focus();
            }, 100);
        }
        
        // WebKit Entry APIã‚’ä½¿ã£ãŸãƒ•ã‚©ãƒ«ãƒ€å‡¦ç†ï¼ˆé¸æŠè‚¢ä»˜ãï¼‰
        async function processFolderDropEntryWithOptions(entry) {
            if (!entry.isDirectory) return;
            
            
            // Entry APIã‹ã‚‰å–å¾—ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã¯ä»®æƒ³ãƒ‘ã‚¹ã§å®Ÿéš›ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ãƒ‘ã‚¹ã¨ç•°ãªã‚‹ãŸã‚ã€
            // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªé¸æŠãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã„ã¦æ­£ç¢ºãªãƒ‘ã‚¹ã‚’å–å¾—ã™ã‚‹
            alert('ãƒ•ã‚©ãƒ«ãƒ€ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚æ­£ç¢ºãªãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
            selectDirectoryForDrop();
        }
        
        // Entry APIã§ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’å‡¦ç†ï¼ˆæ”¹è‰¯ç‰ˆï¼‰
        async function processDirectoryEntry(entry) {
            if (!entry.isDirectory) return;
            
            
            try {
                const unityPackageFiles = [];
                const reader = entry.createReader();
                
                const readEntries = () => {
                    return new Promise((resolve, reject) => {
                        reader.readEntries((entries) => {
                            resolve(entries);
                        }, reject);
                    });
                };
                
                const entries = await readEntries();
                
                // .unitypackageãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œç´¢
                for (const fileEntry of entries) {
                    if (!fileEntry.isDirectory && fileEntry.name.toLowerCase().endsWith('.unitypackage')) {
                        
                        // Fileã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—ã—ã¦ãƒ‘ã‚¹ã‚’å¾—ã‚‹
                        const file = await new Promise((resolve, reject) => {
                            fileEntry.file(resolve, reject);
                        });
                        
                        // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æ§‹ç¯‰ï¼ˆfile.pathãŒåˆ©ç”¨ã§ããªã„å ´åˆã®ä»£æ›¿æ‰‹æ®µï¼‰
                        const filePath = file.path || `${entry.name}/${fileEntry.name}`;
                        unityPackageFiles.push(filePath);
                    }
                }
                
                if (unityPackageFiles.length > 0) {
                    
                    if (unityPackageFiles.length > 1) {
                        // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆã¯é¸æŠè‚¢ã‚’æä¾›
                        showFolderOptionDialog(unityPackageFiles, entry.name);
                    } else {
                        // å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆ
                        processFilesAsSeparateProducts(unityPackageFiles, entry.name);
                    }
                } else {
                    // ãƒ•ã‚©ãƒ«ãƒ€ãŒè¦‹ã¤ã‹ã£ãŸãŒã€Unity packageãƒ•ã‚¡ã‚¤ãƒ«ãŒãªã„å ´åˆã¯
                    // main processã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªé¸æŠã‚’ä½¿ç”¨
                    alert('ãƒ•ã‚©ãƒ«ãƒ€å†…ã«.unitypackageãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚æ­£ç¢ºãªãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                    selectDirectoryForDrop();
                }
                
            } catch (error) {
                console.error('Entry APIå‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                // Entry APIã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                alert('ãƒ•ã‚©ãƒ«ãƒ€ã®å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ­£ç¢ºãªãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                selectDirectoryForDrop();
            }
        }

        // ãƒ‰ãƒ­ãƒƒãƒ—ç”¨ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªé¸æŠ
        async function selectDirectoryForDrop() {
            try {
                if (window.electronAPI) {
                    const result = await window.electronAPI.dialog.selectDirectory();
                    if (result && result.files && result.files.length > 0) {
                        
                        if (result.files.length > 1) {
                            // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆã¯é¸æŠè‚¢ã‚’æä¾›
                            showFolderOptionDialog(result.files, result.folderName);
                        } else if (result.files.length === 1) {
                            // å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆ
                            processFilesAsSeparateProducts(result.files, result.folderName);
                        } else {
                            alert('é¸æŠã•ã‚ŒãŸãƒ•ã‚©ãƒ«ãƒ€å†…ã«.unitypackageãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚');
                        }
                    }
                }
            } catch (error) {
                console.error('ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªé¸æŠã‚¨ãƒ©ãƒ¼:', error);
                alert('ãƒ•ã‚©ãƒ«ãƒ€ã®é¸æŠã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
            }
        }
        
        // ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰ã‚«ãƒ†ã‚´ãƒªã‚’æ¨æ¸¬
        function detectCategoryFromFileName(fileName) {
            if (!fileName) return 'ãã®ä»–';
            
            const lowerName = fileName.toLowerCase();
            
            // è¡£è£…é–¢é€£ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
            if (lowerName.includes('cloth') || lowerName.includes('wear') || lowerName.includes('outfit') || 
                lowerName.includes('dress') || lowerName.includes('shirt') || lowerName.includes('pants') ||
                lowerName.includes('skirt') || lowerName.includes('jacket') || lowerName.includes('coat') ||
                lowerName.includes('è¡£è£…') || lowerName.includes('æœ') || lowerName.includes('ãƒ‰ãƒ¬ã‚¹') ||
                lowerName.includes('ã‚·ãƒ£ãƒ„') || lowerName.includes('ãƒ‘ãƒ³ãƒ„') || lowerName.includes('ã‚¹ã‚«ãƒ¼ãƒˆ')) {
                return 'è¡£è£…';
            }
            
            // ã‚¢ã‚¯ã‚»ã‚µãƒªãƒ¼é–¢é€£ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
            if (lowerName.includes('accessory') || lowerName.includes('hat') || lowerName.includes('glasses') ||
                lowerName.includes('bag') || lowerName.includes('jewelry') || lowerName.includes('earring') ||
                lowerName.includes('necklace') || lowerName.includes('bracelet') || lowerName.includes('ring') ||
                lowerName.includes('ã‚¢ã‚¯ã‚»ã‚µãƒªãƒ¼') || lowerName.includes('å¸½å­') || lowerName.includes('çœ¼é¡') ||
                lowerName.includes('ãƒãƒƒã‚°') || lowerName.includes('ãƒ”ã‚¢ã‚¹') || lowerName.includes('ãƒãƒƒã‚¯ãƒ¬ã‚¹')) {
                return 'ã‚¢ã‚¯ã‚»ã‚µãƒªãƒ¼';
            }
            
            // ã‚¢ãƒã‚¿ãƒ¼æœ¬ä½“é–¢é€£ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
            if (lowerName.includes('avatar') || lowerName.includes('body') || lowerName.includes('base') ||
                lowerName.includes('character') || lowerName.includes('model') ||
                lowerName.includes('ã‚¢ãƒã‚¿ãƒ¼') || lowerName.includes('æœ¬ä½“') || lowerName.includes('ãƒ™ãƒ¼ã‚¹') ||
                lowerName.includes('ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼') || lowerName.includes('ãƒ¢ãƒ‡ãƒ«')) {
                return 'ã‚¢ãƒã‚¿ãƒ¼æœ¬ä½“';
            }
            
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ã€Œãã®ä»–ã€
            return 'ãã®ä»–';
        }

        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’1ã¤ã®å•†å“ã¨ã—ã¦çµ±åˆå‡¦ç†
        async function processFilesAsOneProduct(filePaths, folderName) {
            
            if (filePaths.length === 0) return;
            
            // å•†å“åã¯å…ƒã®ãƒ•ã‚©ãƒ«ãƒ€åã‚’ä½¿ç”¨
            const productName = folderName || 'Unity Package Bundle';
            
            // ãƒ¡ã‚¤ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã¯æœ€åˆã®ãƒ•ã‚¡ã‚¤ãƒ«
            const mainFilePath = filePaths[0];
            
            // å„ãƒ•ã‚¡ã‚¤ãƒ«ã®è¡¨ç¤ºåã‚’ç”Ÿæˆ
            const displayNames = filePaths.map(filePath => {
                const fileName = filePath.split(/[/\\]/).pop().replace('.unitypackage', '');
                return fileName;
            });
            
            let productData = {
                name: productName,
                category: '',
                booth_url: '',
                thumbnail_url: '',
                file_path: mainFilePath,
                description: `${folderName}`,
                author: '',
                avatar_ids: '',
                tags: '',
                file_paths: filePaths.join('|'),
                display_names: displayNames.join('|')
            };
            
            // è³¼å…¥å±¥æ­´ã‹ã‚‰å€™è£œã‚’æ¤œç´¢ï¼ˆãƒ•ã‚©ãƒ«ãƒ€åã‚’ZIPåã¨ã—ã¦æ‰±ã†ï¼‰
            const purchaseHistoryData = JSON.parse(localStorage.getItem('boothPurchaseHistory') || '[]');
            let foundFromPurchaseHistory = false;
            
            if (purchaseHistoryData.length > 0) {
                // ãƒ•ã‚©ãƒ«ãƒ€åã‚’ZIPåã¨ã—ã¦æ¤œç´¢
                const folderAsZip = folderName + '.zip';
                const candidates = findCandidatesForFile(folderAsZip);
                
                if (candidates.length > 0) {
                    const topCandidate = candidates[0];
                    const matchPercentage = Math.round(topCandidate.matchScore * 100);
                    
                    // 70%ä»¥ä¸Šãªã‚‰è‡ªå‹•é©ç”¨
                    if (topCandidate.matchScore >= 0.7) {
                        
                        // è³¼å…¥å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã§æ›´æ–°
                        productData.name = topCandidate.title;
                        productData.booth_url = topCandidate.boothUrl;
                        productData.thumbnail_url = topCandidate.thumbnailUrl;
                        productData.author = topCandidate.author;
                        productData.description = `${folderName} (ãƒ•ã‚©ãƒ«ãƒ€ä¸€æ‹¬ãƒãƒƒãƒ ${matchPercentage}%: ${topCandidate.bestMatch})`;
                        
                        foundFromPurchaseHistory = true;
                    }
                }
            }
            
            try {
                if (window.electronAPI) {
                    await window.electronAPI.database.addProduct(productData);
                    
                    if (foundFromPurchaseHistory) {
                    } else {
                        // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰è‡ªå‹•ã§Booth URLå–å¾—ã¨ã‚µãƒ ãƒã‚¤ãƒ«è¨­å®šï¼ˆå…¨ãƒ•ã‚¡ã‚¤ãƒ«ã§æ¤œç´¢ã‚’è©¦è¡Œï¼‰
                        let foundResult = null;
                        let foundSearchResult = null;
                    
                    for (let i = 0; i < filePaths.length && !foundResult; i++) {
                        const fileName = filePaths[i].split(/[/\\]/).pop();
                        
                        try {
                            const boothSearchResult = await window.electronAPI.booth.searchByFilename(fileName);
                            
                            if (boothSearchResult.success && boothSearchResult.results && boothSearchResult.results.length > 0) {
                                const firstResult = boothSearchResult.results[0];
                                if (firstResult.url && firstResult.url.includes('booth.pm') && firstResult.url.includes('/items/')) {
                                    foundResult = firstResult;
                                    foundSearchResult = boothSearchResult;
                                    break;
                                }
                            }
                        } catch (boothError) {
                            // æ¤œç´¢å¤±æ•—ã¯ç„¡è¦–
                        }
                    }
                    
                    if (foundResult) {
                        // Booth URLã‚’æ›´æ–°
                        productData.booth_url = foundResult.url;
                        
                        if (foundSearchResult.highConfidence !== false) {
                            try {
                                const thumbnailResult = await window.electronAPI.fetch.thumbnail(foundResult.url);
                                if (thumbnailResult.success && thumbnailResult.thumbnailUrl) {
                                    productData.thumbnail_url = thumbnailResult.thumbnailUrl;
                                } else {
                                }
                            } catch (thumbnailError) {
                                console.error('ğŸ–¼ï¸ ã‚µãƒ ãƒã‚¤ãƒ«å–å¾—ã‚¨ãƒ©ãƒ¼:', thumbnailError);
                                // ã‚µãƒ ãƒã‚¤ãƒ«å–å¾—å¤±æ•—ã¯ç„¡è¦–
                            }
                        } else {
                            // ä½ä¿¡é ¼åº¦ã®å ´åˆã¯ã‚µãƒ ãƒã‚¤ãƒ«ã‚’å–å¾—ã›ãšè­¦å‘Šè¡¨ç¤º
                            console.warn('ğŸ–¼ï¸ ä¿¡é ¼åº¦ãŒä½ã„ãƒãƒƒãƒã®ãŸã‚ã‚µãƒ ãƒã‚¤ãƒ«ã‚’å–å¾—ã—ã¾ã›ã‚“ã§ã—ãŸ:', foundResult.title);
                        }
                        
                        // æ›´æ–°ã•ã‚ŒãŸå•†å“ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
                        const products = await window.electronAPI.database.getProducts();
                        const addedProduct = products[products.length - 1];
                        if (addedProduct) {
                            await window.electronAPI.database.updateProduct(addedProduct.id, {
                                ...addedProduct,
                                booth_url: productData.booth_url,
                                thumbnail_url: productData.thumbnail_url
                            });
                        }
                    }
                    }
                    
                    // è¨­å®šç¢ºèªå¾Œã€ãƒ•ã‚©ãƒ«ãƒ€ã”ã¨ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã«ç§»å‹•
                    const settings = await window.electronAPI.settings.get();
                    if (settings.autoArchive === true) {
                        const products = await window.electronAPI.database.getProducts();
                        const addedProduct = products[products.length - 1]; // æœ€å¾Œã«è¿½åŠ ã•ã‚ŒãŸå•†å“
                        
                        // ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹ã‚’å–å¾—ï¼ˆéšå±¤ã®æœ€ä¸Šä½ã‚’ç‰¹å®šï¼‰
                        const firstFilePath = filePaths[0];
                        const folderPath = findRootFolderPath(firstFilePath, folderName);
                        console.log('çµ±åˆå•†å“ç”¨ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹:', folderPath, 'from:', firstFilePath);
                        
                        console.log('çµ±åˆå•†å“ãƒ•ã‚©ãƒ«ãƒ€ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å‡¦ç†é–‹å§‹:', folderPath);
                        
                        try {
                            // ãƒ•ã‚©ãƒ«ãƒ€ã”ã¨ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã«ç§»å‹•
                            const archiveResult = await window.electronAPI.fs.moveFolderToArchive(folderPath);
                            console.log('çµ±åˆå•†å“ãƒ•ã‚©ãƒ«ãƒ€ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–çµæœ:', archiveResult);
                            
                            if (archiveResult.success) {
                                // ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å¾Œã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’è¨ˆç®—
                                const archivedFiles = filePaths.map(filePath => {
                                    const relativePath = filePath.substring(folderPath.length);
                                    return archiveResult.newPath + relativePath;
                                });
                                
                                console.log('çµ±åˆå•†å“ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹æ›´æ–°:', archivedFiles);
                                
                                // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æ›´æ–°
                                if (addedProduct) {
                                    await window.electronAPI.database.updateProduct(addedProduct.id, {
                                        ...addedProduct,
                                        file_path: archivedFiles[0], // ãƒ¡ã‚¤ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
                                        file_paths: archivedFiles.join('|') // å…¨ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
                                    });
                                }
                            } else {
                                console.error('çµ±åˆå•†å“ãƒ•ã‚©ãƒ«ãƒ€ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å¤±æ•—:', archiveResult.error);
                                // ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯å€‹åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç§»å‹•ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
                                const archivedFiles = [];
                                let archiveSuccessCount = 0;
                                
                                for (const filePath of filePaths) {
                                    try {
                                        const fileArchiveResult = await window.electronAPI.fs.moveToArchive(filePath);
                                        if (fileArchiveResult.success) {
                                            archivedFiles.push(fileArchiveResult.newPath);
                                            archiveSuccessCount++;
                                        } else {
                                            archivedFiles.push(filePath);
                                        }
                                    } catch (error) {
                                        archivedFiles.push(filePath);
                                    }
                                }
                                
                                // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æ›´æ–°
                                if (addedProduct && archiveSuccessCount > 0) {
                                    await window.electronAPI.database.updateProduct(addedProduct.id, {
                                        ...addedProduct,
                                        file_path: archivedFiles[0],
                                        file_paths: archivedFiles.join('|')
                                    });
                                }
                            }
                        } catch (error) {
                            console.error('çµ±åˆå•†å“ãƒ•ã‚©ãƒ«ãƒ€ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚¨ãƒ©ãƒ¼:', error);
                        }
                        
                        // çµ±åˆå•†å“è¿½åŠ å®Œäº†
                    } else {
                        // çµ±åˆå•†å“è¿½åŠ å®Œäº†
                    }
                    loadProducts(); // å•†å“ãƒªã‚¹ãƒˆã‚’å†èª­ã¿è¾¼ã¿
                }
            } catch (error) {
                console.error('çµ±åˆå•†å“è¿½åŠ ã‚¨ãƒ©ãƒ¼:', error);
                alert('çµ±åˆå•†å“ã®è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
            }
        }

        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å€‹åˆ¥ã®å•†å“ã¨ã—ã¦å‡¦ç†
        async function processFilesAsSeparateProducts(filePaths, folderName = '') {
            
            let successCount = 0;
            
            for (const filePath of filePaths) {
                const fileName = filePath.split(/[/\\]/).pop().replace('.unitypackage', '');
                const actualFileName = filePath.split(/[/\\]/).pop();
                
                const productName = folderName ? `${folderName} - ${fileName}` : fileName;
                
                let productData = {
                    name: productName,
                    category: '',
                    booth_url: '',
                    thumbnail_url: '',
                    file_path: filePath,
                    description: `${fileName}`,
                    author: '',
                    avatar_ids: '',
                    tags: '',
                    file_paths: '',
                    display_names: ''
                };
                
                // è³¼å…¥å±¥æ­´ã‹ã‚‰å€™è£œã‚’æ¤œç´¢
                const purchaseHistoryData = JSON.parse(localStorage.getItem('boothPurchaseHistory') || '[]');
                let foundFromPurchaseHistory = false;
                
                if (purchaseHistoryData.length > 0) {
                    const candidates = findCandidatesForFile(actualFileName);
                    
                    if (candidates.length > 0) {
                        const topCandidate = candidates[0];
                        const matchPercentage = Math.round(topCandidate.matchScore * 100);
                        
                        // 70%ä»¥ä¸Šãªã‚‰è‡ªå‹•é©ç”¨
                        if (topCandidate.matchScore >= 0.7) {
                            
                            // è³¼å…¥å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã§æ›´æ–°
                            productData.name = topCandidate.title;
                            productData.booth_url = topCandidate.boothUrl;
                            productData.thumbnail_url = topCandidate.thumbnailUrl;
                            productData.author = topCandidate.author;
                            productData.description = `${fileName} (unitypackageãƒãƒƒãƒ ${matchPercentage}%: ${topCandidate.bestMatch})`;
                            
                            foundFromPurchaseHistory = true;
                        }
                    }
                }
                
                try {
                    if (window.electronAPI) {
                        await window.electronAPI.database.addProduct(productData);
                        successCount++;
                        
                        if (foundFromPurchaseHistory) {
                        } else {
                                // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰è‡ªå‹•ã§Booth URLå–å¾—ã¨ã‚µãƒ ãƒã‚¤ãƒ«è¨­å®š
                            try {
                                const boothSearchResult = await window.electronAPI.booth.searchByFilename(actualFileName);
                            
                            if (boothSearchResult.success && boothSearchResult.results && boothSearchResult.results.length > 0) {
                                const firstResult = boothSearchResult.results[0];
                                if (firstResult.url && firstResult.url.includes('booth.pm') && firstResult.url.includes('/items/')) {
                                    // Booth URLã‚’æ›´æ–°
                                    productData.booth_url = firstResult.url;
                                    
                                    if (boothSearchResult.highConfidence !== false) {
                                        try {
                                            const thumbnailResult = await window.electronAPI.fetch.thumbnail(firstResult.url);
                                            if (thumbnailResult.success && thumbnailResult.thumbnailUrl) {
                                                productData.thumbnail_url = thumbnailResult.thumbnailUrl;
                                            }
                                        } catch (thumbnailError) {
                                            // ã‚µãƒ ãƒã‚¤ãƒ«å–å¾—å¤±æ•—ã¯ç„¡è¦–
                                        }
                                    } else {
                                        // ä½ä¿¡é ¼åº¦ã®å ´åˆã¯ã‚µãƒ ãƒã‚¤ãƒ«ã‚’å–å¾—ã›ãšè­¦å‘Šè¡¨ç¤º
                                        console.warn('ä¿¡é ¼åº¦ãŒä½ã„ãƒãƒƒãƒã®ãŸã‚ã‚µãƒ ãƒã‚¤ãƒ«ã‚’å–å¾—ã—ã¾ã›ã‚“ã§ã—ãŸ:', firstResult.title);
                                    }
                                    
                                    // æ›´æ–°ã•ã‚ŒãŸå•†å“ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
                                    const products = await window.electronAPI.database.getProducts();
                                    const addedProduct = products[products.length - 1];
                                    if (addedProduct) {
                                        await window.electronAPI.database.updateProduct(addedProduct.id, {
                                            ...addedProduct,
                                            booth_url: productData.booth_url,
                                            thumbnail_url: productData.thumbnail_url
                                        });
                                    }
                                }
                            }
                        } catch (boothError) {
                                // Boothæ¤œç´¢å¤±æ•—ã¯ç„¡è¦–
                            }
                        }
                    }
                } catch (error) {
                    console.error('å•†å“è¿½åŠ ã‚¨ãƒ©ãƒ¼:', error);
                }
            }
            
            if (successCount > 0) {
                // è¨­å®šã‚’ç¢ºèªã—ã¦ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å‡¦ç†ã¨æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å¤‰æ›´
                const settings = await window.electronAPI.settings.get();
                if (settings.autoArchive === true) {
                    // ãƒ•ã‚©ãƒ«ãƒ€ã”ã¨ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã«ç§»å‹•
                    let archiveSuccessCount = 0;
                    const products = await window.electronAPI.database.getProducts();
                    
                    const processedFolders = new Set(); // å‡¦ç†æ¸ˆã¿ãƒ•ã‚©ãƒ«ãƒ€ã‚’è¨˜éŒ²
                    
                    for (let i = 0; i < successCount; i++) {
                        const addedProduct = products[products.length - successCount + i]; // è¿½åŠ ã•ã‚ŒãŸå•†å“ã‚’é †ç•ªã«å–å¾—
                        if (addedProduct && addedProduct.file_path) {
                            const originalFilePath = addedProduct.file_path;
                            
                            // ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹ã‚’å–å¾—ï¼ˆéšå±¤ã®æœ€ä¸Šä½ã‚’ç‰¹å®šï¼‰
                            const folderPath = findRootFolderPath(originalFilePath, folderName);
                            console.log('ç‰¹å®šã•ã‚ŒãŸãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹:', folderPath, 'from:', originalFilePath);
                            
                            if (folderPath && !processedFolders.has(folderPath)) {
                                processedFolders.add(folderPath);
                                
                                try {
                                    console.log('ãƒ•ã‚©ãƒ«ãƒ€ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å‡¦ç†é–‹å§‹:', folderPath);
                                    // ãƒ•ã‚©ãƒ«ãƒ€ã”ã¨ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã«ç§»å‹•
                                    const archiveResult = await window.electronAPI.fs.moveFolderToArchive(folderPath);
                                    console.log('ãƒ•ã‚©ãƒ«ãƒ€ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–çµæœ:', archiveResult);
                                    
                                    if (archiveResult.success) {
                                        archiveSuccessCount++;
                                        console.log('ãƒ•ã‚©ãƒ«ãƒ€ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–æˆåŠŸã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹æ›´æ–°ä¸­...');
                                        
                                        // ã“ã®ãƒ•ã‚©ãƒ«ãƒ€å†…ã®ã™ã¹ã¦ã®å•†å“ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æ›´æ–°
                                        for (let j = 0; j < successCount; j++) {
                                            const productToUpdate = products[products.length - successCount + j];
                                            if (productToUpdate && productToUpdate.file_path && 
                                                productToUpdate.file_path.startsWith(folderPath)) {
                                                
                                                console.log('æ›´æ–°å¯¾è±¡å•†å“:', productToUpdate.name, 'ãƒ‘ã‚¹:', productToUpdate.file_path);
                                                
                                                // æ–°ã—ã„ãƒ‘ã‚¹ã‚’è¨ˆç®—
                                                const relativePath = productToUpdate.file_path.substring(folderPath.length);
                                                const newFilePath = archiveResult.newPath + relativePath;
                                                
                                                console.log('æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹:', newFilePath);
                                                
                                                // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æ›´æ–°
                                                await window.electronAPI.database.updateProduct(productToUpdate.id, {
                                                    ...productToUpdate,
                                                    file_path: newFilePath
                                                });
                                            }
                                        }
                                    } else {
                                        console.error('ãƒ•ã‚©ãƒ«ãƒ€ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–å¤±æ•—:', archiveResult.error);
                                    }
                                } catch (error) {
                                    console.error('ãƒ•ã‚©ãƒ«ãƒ€ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚¨ãƒ©ãƒ¼:', error);
                                    // ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯å€‹åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç§»å‹•
                                    try {
                                        const fileArchiveResult = await window.electronAPI.fs.moveToArchive(originalFilePath);
                                        if (fileArchiveResult.success) {
                                            await window.electronAPI.database.updateProduct(addedProduct.id, {
                                                ...addedProduct,
                                                file_path: fileArchiveResult.newPath
                                            });
                                            archiveSuccessCount++;
                                        }
                                    } catch (fileError) {
                                        console.error('ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚¨ãƒ©ãƒ¼:', fileError);
                                    }
                                }
                            }
                        }
                    }
                    
                    alert(`${successCount}å€‹ã®å•†å“ã‚’è¿½åŠ ã—ã¾ã—ãŸï¼\nãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãƒ•ã‚©ãƒ«ãƒ€ã«ç§»å‹•ã•ã‚Œã¾ã—ãŸã€‚`);
                } else {
                    alert(`${successCount}å€‹ã®å•†å“ã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚`);
                }
                loadProducts(); // å•†å“ãƒªã‚¹ãƒˆã‚’å†èª­ã¿è¾¼ã¿
            }
        }
        
        // ãƒ•ã‚©ãƒ«ãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã‹ã‚‰å‡¦ç†ï¼ˆwebkitRelativePathã‚’ä½¿ç”¨ï¼‰
        async function processFolderFilesWithOptions(folderFiles) {
            
            // .unitypackageãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿ã‚’æŠ½å‡º
            const unityPackageFiles = folderFiles.filter(file => 
                file.name.toLowerCase().endsWith('.unitypackage')
            );
            
            if (unityPackageFiles.length === 0) {
                alert('ãƒ•ã‚©ãƒ«ãƒ€å†…ã«.unitypackageãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚');
                return;
            }
            
            
            // ãƒ•ã‚©ãƒ«ãƒ€åã‚’å–å¾—ï¼ˆæœ€åˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã®webkitRelativePathã‹ã‚‰ï¼‰
            const firstFilePath = unityPackageFiles[0].webkitRelativePath;
            const folderName = firstFilePath.split('/')[0];
            
            // å®Ÿéš›ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’å–å¾—ã™ã‚‹ãŸã‚ã€ä¸€æ™‚çš„ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜
            const realFilePaths = [];
            for (const file of unityPackageFiles) {
                // ãƒ•ã‚¡ã‚¤ãƒ«ã®å®Ÿéš›ã®ãƒ‘ã‚¹ã¯ç›´æ¥å–å¾—ã§ããªã„ãŸã‚ã€
                // main processã§ãƒ•ã‚¡ã‚¤ãƒ«ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã®çµæœã¨ç…§åˆã™ã‚‹æ–¹æ³•ã‚’ä½¿ç”¨
                // ä»®ã®ãƒ‘ã‚¹ã¨ã—ã¦ã€ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ä½¿ç”¨ï¼ˆå¾Œã§ä¿®æ­£ãŒå¿…è¦ï¼‰
                realFilePaths.push(file.name);
            }
            
            if (unityPackageFiles.length > 1) {
                // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆã¯é¸æŠè‚¢ã‚’æä¾›
                // å¸¸ã«çµ±åˆå‡¦ç†ã‚’è¡Œã†
                processFilesAsOneProduct(unityPackageFiles, folderName);
            } else {
                // å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆ
                processFilesAsSeparateProducts(unityPackageFiles, folderName);
            }
        }

        // main processã§ãƒ•ã‚©ãƒ«ãƒ€ã‚’ã‚¹ã‚­ãƒ£ãƒ³ã™ã‚‹
        async function processFolderDropWithMainProcess(folder) {
            
            try {
                // main processã®selectDirectoryã‚’ä½¿ã£ã¦ã€ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸãƒ•ã‚©ãƒ«ãƒ€ã®å†…å®¹ã‚’å–å¾—
                // ãŸã ã—ã€å®Ÿéš›ã«ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é¸æŠã—ã¦ã‚‚ã‚‰ã†å¿…è¦ãŒã‚ã‚‹
                alert('ãƒ•ã‚©ãƒ«ãƒ€ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚æ­£ç¢ºãªãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                selectDirectoryForDrop();
            } catch (error) {
                console.error('ãƒ•ã‚©ãƒ«ãƒ€å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                alert('ãƒ•ã‚©ãƒ«ãƒ€ã®å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
            }
        }
        
        // WebKit Entry APIã‚’ä½¿ã£ãŸãƒ•ã‚©ãƒ«ãƒ€å‡¦ç†
        async function processFolderDropEntry(entry) {
            if (!entry.isDirectory) return;
            
            
            try {
                const unityPackageFiles = [];
                
                // ãƒ•ã‚©ãƒ«ãƒ€å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å†å¸°çš„ã«èª­ã¿å–ã‚Š
                const reader = entry.createReader();
                
                const readEntries = () => {
                    return new Promise((resolve, reject) => {
                        reader.readEntries((entries) => {
                            resolve(entries);
                        }, reject);
                    });
                };
                
                const entries = await readEntries();
                
                // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å®Ÿéš›ã«èª­ã¿å–ã£ã¦ã€ãƒ‘ã‚¹ã‚’å–å¾—
                const filePromises = [];
                
                for (const fileEntry of entries) {
                    if (!fileEntry.isDirectory && fileEntry.name.toLowerCase().endsWith('.unitypackage')) {
                        filePromises.push(
                            new Promise((resolve) => {
                                fileEntry.file((file) => {
                                    // Fileã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ãƒ‘ã‚¹ã‚’å–å¾—
                                    resolve({
                                        name: file.name,
                                        path: file.path || file.webkitRelativePath || fileEntry.fullPath
                                    });
                                }, (error) => {
                                    console.error('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿å–ã‚Šã‚¨ãƒ©ãƒ¼:', error);
                                    resolve(null);
                                });
                            })
                        );
                    }
                }
                
                const fileResults = await Promise.all(filePromises);
                const validFiles = fileResults.filter(f => f !== null);
                
                for (const fileInfo of validFiles) {
                    unityPackageFiles.push(fileInfo);
                }
                
                if (unityPackageFiles.length > 0) {
                    
                    // å•†å“è¿½åŠ ãƒ•ã‚©ãƒ¼ãƒ ã‚’é–‹ã
                    openProductModal();
                    
                    // ãƒ•ã‚¡ã‚¤ãƒ«åã®é…åˆ—ã‚’ä½œæˆ
                    const fileNames = unityPackageFiles.map(f => f.name);
                    
                    // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã®è¡¨ç¤ºï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åã®ã¿è¡¨ç¤ºï¼‰
                    displayMultipleFiles(fileNames);
                    
                    // æœ€åˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ¡ã‚¤ãƒ³ã¨ã—ã¦è¨­å®šï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åã®ã¿ï¼‰
                    document.getElementById('productFilePath').value = fileNames[0];
                    
                    // ãƒ•ã‚©ãƒ«ãƒ€åã‹ã‚‰å•†å“åã‚’æ¨æ¸¬
                    document.getElementById('productName').value = entry.name;
                    
                    alert(`ãƒ•ã‚©ãƒ«ãƒ€å†…ã«${unityPackageFiles.length}å€‹ã®.unitypackageãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚å•†å“æƒ…å ±ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚`);
                } else {
                    alert('ãƒ•ã‚©ãƒ«ãƒ€å†…ã«.unitypackageãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚');
                }
            } catch (error) {
                console.error('ãƒ•ã‚©ãƒ«ãƒ€å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                alert('ãƒ•ã‚©ãƒ«ãƒ€ã®å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
            }
        }
        
        // ãƒ•ã‚©ãƒ«ãƒ€ãŒãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸæ™‚ã®å‡¦ç†
        async function processFolderDrop(folder) {
            try {
                // ãƒ•ã‚©ãƒ«ãƒ€ã®ãƒ‘ã‚¹ã‚’å–å¾—
                const folderPath = folder.path;
                
                // Node.jsã®fsãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã£ã¦ãƒ•ã‚©ãƒ«ãƒ€å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾—
                if (window.electronAPI && window.electronAPI.shell) {
                    // Electronã®main processã«ãƒ•ã‚©ãƒ«ãƒ€ã‚¹ã‚­ãƒ£ãƒ³ã‚’ä¾é ¼
                    const fs = require('fs');
                    const path = require('path');
                    
                    if (fs && fs.readdirSync) {
                        try {
                            const files = fs.readdirSync(folderPath);
                            const unityPackageFiles = files
                                .filter(file => file.toLowerCase().endsWith('.unitypackage'))
                                .map(file => path.join(folderPath, file));
                            
                            if (unityPackageFiles.length > 0) {
                                const folderName = path.basename(folderPath);
                                
                                // è³¼å…¥å±¥æ­´ã‹ã‚‰å€™è£œã‚’æ¤œç´¢ï¼ˆãƒ•ã‚©ãƒ«ãƒ€åã‚’ZIPãƒ•ã‚¡ã‚¤ãƒ«åã¨ã—ã¦æ‰±ã†ï¼‰
                                const purchaseHistoryData = JSON.parse(localStorage.getItem('boothPurchaseHistory') || '[]');
                                
                                let foundFromPurchaseHistory = false;
                                let productData = {
                                    name: folderName,
                                    category: '',
                                    tags: '',
                                    description: folderName,
                                    booth_url: '',
                                    thumbnail_url: '',
                                    file_path: unityPackageFiles[0],
                                    file_paths: unityPackageFiles.join('|'),
                                    display_names: unityPackageFiles.map(f => path.basename(f)).join('|'),
                                    author: '',
                                    avatar_ids: ''
                                };
                                
                                if (purchaseHistoryData.length > 0) {
                                    // ãƒ•ã‚©ãƒ«ãƒ€åã‚’ZIPåã¨ã—ã¦æ¤œç´¢
                                    const folderAsZip = folderName + '.zip';
                                    const candidates = findCandidatesForFile(folderAsZip);
                                    
                                    if (candidates.length > 0) {
                                        const topCandidate = candidates[0];
                                        const matchPercentage = Math.round(topCandidate.matchScore * 100);
                                        
                                        // 70%ä»¥ä¸Šãªã‚‰è‡ªå‹•é©ç”¨
                                        if (topCandidate.matchScore >= 0.7) {
                                            
                                            // è³¼å…¥å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã§æ›´æ–°
                                            productData.name = topCandidate.title;
                                            productData.booth_url = topCandidate.boothUrl;
                                            productData.thumbnail_url = topCandidate.thumbnailUrl;
                                            productData.author = topCandidate.author;
                                            productData.description = `${folderName} (ãƒ•ã‚©ãƒ«ãƒ€ãƒãƒƒãƒ ${matchPercentage}%: ${topCandidate.bestMatch})`;
                                            
                                            foundFromPurchaseHistory = true;
                                        }
                                    }
                                }
                                
                                if (foundFromPurchaseHistory) {
                                    // 70%ä»¥ä¸Šãƒãƒƒãƒã®å ´åˆã¯è‡ªå‹•ç™»éŒ²
                                    try {
                                        const addResult = await window.electronAPI.database.addProduct(productData);
                                        
                                        // å•†å“ãƒªã‚¹ãƒˆã‚’æ›´æ–°
                                        updateProductList();
                                    } catch (error) {
                                        console.error('ãƒ•ã‚©ãƒ«ãƒ€è‡ªå‹•ç™»éŒ²ã‚¨ãƒ©ãƒ¼:', error);
                                        alert(`è‡ªå‹•ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
                                    }
                                } else {
                                    // å€™è£œãªã—ã¾ãŸã¯ä½ä¿¡é ¼åº¦ã®å ´åˆã¯æ‰‹å‹•å…¥åŠ›
                                    
                                    // å•†å“è¿½åŠ ãƒ•ã‚©ãƒ¼ãƒ ã‚’é–‹ã
                                    openProductModal();
                                    
                                    // è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã®è¡¨ç¤º
                                    displayMultipleFiles(unityPackageFiles);
                                    
                                    // ãƒ•ã‚©ãƒ«ãƒ€æƒ…å ±ã‚’ãƒ•ã‚©ãƒ¼ãƒ ã«è¨­å®š
                                    document.getElementById('productFilePath').value = unityPackageFiles[0];
                                    document.getElementById('productName').value = productData.name;
                                    document.getElementById('boothUrl').value = productData.booth_url;
                                    document.getElementById('thumbnailUrl').value = productData.thumbnail_url;
                                    document.getElementById('author').value = productData.author;
                                    
                                    alert(`ãƒ•ã‚©ãƒ«ãƒ€å†…ã«${unityPackageFiles.length}å€‹ã®.unitypackageãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚å•†å“æƒ…å ±ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚`);
                                }
                            } else {
                                alert('ãƒ•ã‚©ãƒ«ãƒ€å†…ã«.unitypackageãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚');
                            }
                        } catch (error) {
                            console.error('ãƒ•ã‚©ãƒ«ãƒ€èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                            alert('ãƒ•ã‚©ãƒ«ãƒ€ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                        }
                    }
                }
            } catch (error) {
                console.error('ãƒ•ã‚©ãƒ«ãƒ€ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                alert('ãƒ•ã‚©ãƒ«ãƒ€ã®å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
            }
        }
        
        function getFilteredProducts() {
            // ç¾åœ¨ã®ãƒ•ã‚£ãƒ«ã‚¿æ¡ä»¶ã«åŸºã¥ã„ã¦å•†å“ã‚’å–å¾—
            let filtered = products.slice();
            
            // ã‚«ãƒ†ã‚´ãƒªãƒ•ã‚£ãƒ«ã‚¿
            const categoryCheckboxes = document.querySelectorAll('[id^="filter_"]:checked');
            const selectedCategories = Array.from(categoryCheckboxes).map(cb => cb.value);
            if (selectedCategories.length > 0) {
                filtered = filtered.filter(product => selectedCategories.includes(product.category));
            }
            
            // æ¤œç´¢ãƒ•ã‚£ãƒ«ã‚¿
            if (searchQuery) {
                const query = searchQuery.toLowerCase();
                filtered = filtered.filter(product => 
                    product.name.toLowerCase().includes(query) ||
                    (product.description && product.description.toLowerCase().includes(query))
                );
            }
            
            return filtered;
        }
        
        // åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', function() {
            loadProducts();
            initDragAndDrop();
            updateViewButtons();
            
            // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
            setupGlobalEventListeners();
            
            
            // ä¸¦ã³é †ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¨­å®š
            const orderSelect = document.getElementById('orderSelect');
            if (orderSelect) {
                orderSelect.value = 'created_desc';
                currentSortOrder = 'created_desc';
            }
            
            // ã‚µãƒ ãƒã‚¤ãƒ«å–å¾—ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
            const thumbnailBtn = document.getElementById('thumbnailFetchBtn');
            if (thumbnailBtn) {
                thumbnailBtn.addEventListener('click', async function(e) {
                    e.preventDefault();
                    // stopPropagationã‚’å‰Šé™¤ - ã“ã‚ŒãŒã‚¤ãƒ™ãƒ³ãƒˆä¼æ’­ã‚’å¦¨ã’ã¦ã„ã‚‹å¯èƒ½æ€§
                    await fetchThumbnail();
                });
            } else {
                console.error('Thumbnail button not found');
            }
        });

        // ãƒ˜ãƒ«ãƒ—ãƒ¢ãƒ¼ãƒ€ãƒ«é–¢æ•°
        function showHelpModal() {
            document.getElementById('helpModal').style.display = 'block';
        }

        function closeHelpModal() {
            document.getElementById('helpModal').style.display = 'none';
        }

        // è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«é–¢æ•°
        async function showSettingsModal() {
            document.getElementById('settingsModal').style.display = 'block';
            
            // ç¾åœ¨ã®è¨­å®šã‚’èª­ã¿è¾¼ã‚“ã§ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã«åæ˜ 
            try {
                const settings = await window.electronAPI.settings.get();
                document.getElementById('autoArchiveCheckbox').checked = settings.autoArchive === true; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ç„¡åŠ¹
            } catch (error) {
                console.error('è¨­å®šã®èª­ã¿è¾¼ã¿ã«å¤±æ•—:', error);
                document.getElementById('autoArchiveCheckbox').checked = false; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
            }
        }

        function closeSettingsModal() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        async function saveSettings() {
            try {
                const autoArchive = document.getElementById('autoArchiveCheckbox').checked;
                await window.electronAPI.settings.update({ 
                    autoArchive
                });
                closeSettingsModal();
            } catch (error) {
                console.error('è¨­å®šã®ä¿å­˜ã«å¤±æ•—:', error);
                alert('è¨­å®šã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
            }
        }


        // ãƒ¢ãƒ¼ãƒ€ãƒ«å¤–ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
        window.onclick = function(event) {
            const helpModal = document.getElementById('helpModal');
            const settingsModal = document.getElementById('settingsModal');
            
            if (event.target === helpModal) {
                closeHelpModal();
            } else if (event.target === settingsModal) {
                closeSettingsModal();
            }
        }
    </script>

    <!-- ãƒ˜ãƒ«ãƒ—ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="helpModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5);">
        <div style="background-color: #374151; margin: 5% auto; padding: 30px; border-radius: 6px; width: 90%; max-width: 800px; color: white; position: relative; max-height: 80vh; overflow-y: auto;">
            <button onclick="closeHelpModal()" style="position: absolute; top: 15px; right: 20px; background: none; border: none; color: #9ca3af; cursor: pointer; font-size: 24px; font-weight: bold;">&times;</button>
            
            <h2 style="margin-top: 0; color: #60a5fa; font-size: 20px;">ğŸ“˜ VRChat Boothå•†å“ç®¡ç† - ä½¿ã„æ–¹</h2>
            
            <div style="line-height: 1.6; font-size: 14px;">
                <h3 style="color: #34d399; font-size: 16px; margin-top: 25px; margin-bottom: 10px;">ğŸ¯ åŸºæœ¬æ“ä½œ</h3>
                <ul style="margin-left: 20px;">
                    <li><strong>å•†å“è¿½åŠ :</strong> ã€Œå•†å“ã‚’è¿½åŠ ã€ãƒœã‚¿ãƒ³ã‹ã‚‰æ–°ã—ã„å•†å“ã‚’ç™»éŒ²</li>
                    <li><strong>ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—:</strong> .unitypackageãƒ•ã‚¡ã‚¤ãƒ«ã‚„ãƒ•ã‚©ãƒ«ãƒ€ã‚’ç›´æ¥ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ä¸€æ‹¬è¿½åŠ </li>
                    <li><strong>ç·¨é›†:</strong> å„å•†å“ã®ã€Œç·¨é›†ã€ãƒœã‚¿ãƒ³ã‹ã‚‰æƒ…å ±ã‚’ä¿®æ­£</li>
                    <li><strong>å‰Šé™¤:</strong> å•†å“ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ã€Œé¸æŠã—ãŸã‚¢ã‚¤ãƒ†ãƒ ã‚’å‰Šé™¤ã€ã§ä¸€æ‹¬å‰Šé™¤</li>
                </ul>

                <h3 style="color: #34d399; font-size: 16px; margin-top: 25px; margin-bottom: 10px;">ğŸ“ è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†</h3>
                <ul style="margin-left: 20px;">
                    <li><strong>è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ç™»éŒ²:</strong> ä¸€ã¤ã®å•†å“ã«è¤‡æ•°ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–¢é€£ä»˜ã‘</li>
                    <li><strong>è¡¨ç¤ºåè¨­å®š:</strong> å„ãƒ•ã‚¡ã‚¤ãƒ«ã«åˆ†ã‹ã‚Šã‚„ã™ã„åå‰ã‚’è¨­å®š</li>
                    <li><strong>å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ:</strong> Unityãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æ™‚ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</li>
                </ul>

                <h3 style="color: #34d399; font-size: 16px; margin-top: 25px; margin-bottom: 10px;">ğŸ·ï¸ ã‚¿ã‚°æ©Ÿèƒ½</h3>
                <ul style="margin-left: 20px;">
                    <li><strong>ã‚¿ã‚°ä½œæˆ:</strong> ã€Œã‚¿ã‚°ã‚’è¿½åŠ ã€ã§æ–°ã—ã„ã‚¿ã‚°ã‚’ä½œæˆ</li>
                    <li><strong>ä¸€æ‹¬ã‚¿ã‚°ä»˜ã‘:</strong> è¤‡æ•°ã®å•†å“ã‚’é¸æŠã—ã¦ä¸€æ‹¬ã§ã‚¿ã‚°ã‚’é©ç”¨</li>
                    <li><strong>ã‚¿ã‚°ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼:</strong> ã‚¿ã‚°ã§å•†å“ã‚’çµã‚Šè¾¼ã¿è¡¨ç¤º</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="settingsModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5);">
        <div style="background-color: #374151; margin: 10% auto; padding: 30px; border-radius: 6px; width: 90%; max-width: 500px; color: white; position: relative;">
            <button onclick="closeSettingsModal()" style="position: absolute; top: 15px; right: 20px; background: none; border: none; color: #9ca3af; cursor: pointer; font-size: 24px; font-weight: bold;">&times;</button>
            
            <h2 style="margin-top: 0; color: #60a5fa; font-size: 20px;">âš™ï¸ è¨­å®š</h2>
            
            <div style="line-height: 1.6; font-size: 14px;">
                <div style="margin-bottom: 20px;">
                    <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                        <input type="checkbox" id="autoArchiveCheckbox" style="width: 16px; height: 16px;">
                        <div>
                            <div style="font-weight: 600; color: #d1d5db;">è‡ªå‹•ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–æ©Ÿèƒ½</div>
                            <div style="font-size: 12px; color: #9ca3af; margin-top: 2px;">
                                å•†å“ç™»éŒ²æ™‚ã«UnityPackageãƒ•ã‚¡ã‚¤ãƒ«ã‚’è‡ªå‹•çš„ã«ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãƒ•ã‚©ãƒ«ãƒ€ã«ç§»å‹•ã—ã€<br>
                                ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ«ãƒ€ãªã©ã‹ã‚‰å‰Šé™¤ã—ã¾ã™
                            </div>
                        </div>
                    </label>
                </div>
                
                <div style="border-top: 1px solid #4b5563; padding-top: 15px; margin-top: 20px;">
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button onclick="closeSettingsModal()" style="padding: 8px 16px; background-color: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                        <button onclick="saveSettings()" style="padding: 8px 16px; background-color: #059669; color: white; border: none; border-radius: 4px; cursor: pointer;">ä¿å­˜</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- è³¼å…¥å±¥æ­´å€™è£œé¸æŠãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="boothCandidatesModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5);">
        <div style="background-color: #374151; margin: 5% auto; padding: 30px; border-radius: 6px; width: 90%; max-width: 700px; color: white; position: relative; max-height: 80vh; overflow-y: auto;">
            <button onclick="closeBoothCandidatesModal()" style="position: absolute; top: 15px; right: 20px; background: none; border: none; color: #9ca3af; cursor: pointer; font-size: 24px; font-weight: bold;">&times;</button>
            
            <h2 style="margin-top: 0; color: #60a5fa; font-size: 20px;">ğŸ” è³¼å…¥å±¥æ­´ã‹ã‚‰ãƒãƒƒãƒãƒ³ã‚°å€™è£œ</h2>
            
            <div id="boothSearchInfo" style="margin-bottom: 20px; padding: 10px; background-color: #4b5563; border-radius: 4px; font-size: 14px;">
                <div><strong>ãƒ•ã‚¡ã‚¤ãƒ«å:</strong> <span id="searchFilename"></span></div>
                <div><strong>æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰:</strong> <span id="searchKeywords"></span></div>
            </div>
            
            <div style="margin-bottom: 20px;">
                <div style="font-size: 14px; color: #d1d5db; margin-bottom: 10px;">è©²å½“ã™ã‚‹å•†å“ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼š</div>
                <div id="boothCandidatesList" style="max-height: 400px; overflow-y: auto;">
                    <!-- å€™è£œãŒã“ã“ã«å‹•çš„ã«è¿½åŠ ã•ã‚Œã‚‹ -->
                </div>
            </div>
            
            <div style="border-top: 1px solid #4b5563; padding-top: 15px; margin-top: 20px;">
                <div style="display: flex; gap: 10px; justify-content: space-between;">
                    <button onclick="selectManualEntry()" style="padding: 8px 16px; background-color: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer;">æ‰‹å‹•å…¥åŠ›</button>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="closeBoothCandidatesModal()" style="padding: 8px 16px; background-color: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                        <button id="selectBoothCandidate" style="padding: 8px 16px; background-color: #059669; color: white; border: none; border-radius: 4px; cursor: pointer;" disabled>é¸æŠ</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- è³¼å…¥å±¥æ­´ã‚¤ãƒ³ãƒãƒ¼ãƒˆ & å€™è£œé¸æŠæ©Ÿèƒ½ -->
    <script>
        // è³¼å…¥å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
        let purchaseHistoryData = [];
        
        // è³¼å…¥å±¥æ­´ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½
        async function importPurchaseHistory() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const data = JSON.parse(text);
                    
                    if (data.data && Array.isArray(data.data)) {
                        purchaseHistoryData = data.data;
                        
                        // LocalStorageã«ä¿å­˜
                        localStorage.setItem('boothPurchaseHistory', JSON.stringify(purchaseHistoryData));
                        
                        // ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
                        const clearBtn = document.getElementById('clearHistoryBtn');
                        if (clearBtn) {
                            clearBtn.style.display = 'inline-block';
                        }
                        
                        alert(`âœ… ${data.data.length}ä»¶ã®è³¼å…¥å±¥æ­´ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸï¼\n\nä»Šå¾ŒZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã™ã‚‹ã¨ã€è‡ªå‹•çš„ã«å€™è£œãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚`);
                    } else {
                        throw new Error('ç„¡åŠ¹ãªJSONãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™');
                    }
                } catch (error) {
                    console.error('è³¼å…¥å±¥æ­´ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼:', error);
                    alert('âŒ è³¼å…¥å±¥æ­´ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
                }
            };
            input.click();
        }
        
        // è³¼å…¥å±¥æ­´ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹æ©Ÿèƒ½
        function clearPurchaseHistory() {
            if (confirm('è³¼å…¥å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚')) {
                // LocalStorageã‹ã‚‰å‰Šé™¤
                localStorage.removeItem('boothPurchaseHistory');
                
                // ãƒ¡ãƒ¢ãƒªä¸Šã®ãƒ‡ãƒ¼ã‚¿ã‚‚ã‚¯ãƒªã‚¢
                purchaseHistoryData = [];
                
                // ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤º
                const clearBtn = document.getElementById('clearHistoryBtn');
                if (clearBtn) {
                    clearBtn.style.display = 'none';
                }
                
                alert('âœ… è³¼å…¥å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸã€‚\næ–°ã—ãJSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦å‹•ä½œç¢ºèªãŒã§ãã¾ã™ã€‚');
            }
        }
        
        // Boothãƒ©ã‚¤ãƒ–ãƒ©ãƒªåé›†ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹æ©Ÿèƒ½
        function clearBoothLibraryData() {
            const stored = localStorage.getItem('boothLibraryData');
            if (!stored) {
                alert('åé›†ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
                return;
            }
            
            const data = JSON.parse(stored);
            const itemCount = data ? data.length : 0;
            
            if (confirm(`Boothãƒ©ã‚¤ãƒ–ãƒ©ãƒªåé›†ãƒ‡ãƒ¼ã‚¿ï¼ˆ${itemCount}ä»¶ï¼‰ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ\n\nã“ã‚Œã¯ãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã§åé›†ã—ãŸãƒ‡ãƒ¼ã‚¿ã§ã™ã€‚\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚`)) {
                // LocalStorageã‹ã‚‰å‰Šé™¤
                localStorage.removeItem('boothLibraryData');
                
                // ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤º
                const clearLibraryBtn = document.getElementById('clearLibraryBtn');
                if (clearLibraryBtn) {
                    clearLibraryBtn.style.display = 'none';
                }
                
                alert(`âœ… Boothãƒ©ã‚¤ãƒ–ãƒ©ãƒªåé›†ãƒ‡ãƒ¼ã‚¿ï¼ˆ${itemCount}ä»¶ï¼‰ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸã€‚\n\nãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚’ä½¿ã£ã¦æ–°ã—ãåé›†ã§ãã¾ã™ã€‚`);
            }
        }
        
        // ã‚¢ãƒ—ãƒªèµ·å‹•æ™‚ã«è³¼å…¥å±¥æ­´ã¨Boothãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
        document.addEventListener('DOMContentLoaded', () => {
            // è³¼å…¥å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã®ãƒã‚§ãƒƒã‚¯
            try {
                const stored = localStorage.getItem('boothPurchaseHistory');
                if (stored) {
                    purchaseHistoryData = JSON.parse(stored);
                    
                    // è³¼å…¥å±¥æ­´ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
                    if (purchaseHistoryData && purchaseHistoryData.length > 0) {
                        const clearBtn = document.getElementById('clearHistoryBtn');
                        if (clearBtn) {
                            clearBtn.style.display = 'inline-block';
                        }
                    }
                }
            } catch (error) {
                console.warn('è³¼å…¥å±¥æ­´å¾©å…ƒã‚¨ãƒ©ãƒ¼:', error);
                localStorage.removeItem('boothPurchaseHistory');
            }
            
            // Boothãƒ©ã‚¤ãƒ–ãƒ©ãƒªåé›†ãƒ‡ãƒ¼ã‚¿ã®ãƒã‚§ãƒƒã‚¯
            try {
                const libraryData = localStorage.getItem('boothLibraryData');
                if (libraryData) {
                    const data = JSON.parse(libraryData);
                    if (data && data.length > 0) {
                        const clearLibraryBtn = document.getElementById('clearLibraryBtn');
                        if (clearLibraryBtn) {
                            clearLibraryBtn.style.display = 'inline-block';
                        }
                    }
                }
            } catch (error) {
                console.warn('Boothãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ‡ãƒ¼ã‚¿å¾©å…ƒã‚¨ãƒ©ãƒ¼:', error);
            }
        });
        
        // ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰å€™è£œã‚’æ¤œç´¢ã™ã‚‹é–¢æ•°ï¼ˆZIPãƒ•ã‚¡ã‚¤ãƒ«åæœ€å„ªå…ˆæ¤œç´¢ï¼‰- ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã«ç§»å‹•
        function findCandidatesForFile(fileName) {
            if (!fileName || !purchaseHistoryData || purchaseHistoryData.length === 0) {
                return [];
            }
            
            const cleanFileName = fileName.replace(/\.(zip|unitypackage|rar|7z)$/i, '');
            
            // 1. æœ€å„ªå…ˆ: ZIPãƒ•ã‚¡ã‚¤ãƒ«åã§ã®å®Œå…¨ä¸€è‡´æ¤œç´¢
            for (const item of purchaseHistoryData) {
                if (item.zipFiles && item.zipFiles.length > 0) {
                    for (const zipFile of item.zipFiles) {
                        const cleanZipName = zipFile.replace(/\.(zip|unitypackage|rar|7z)$/i, '');
                        
                        // å®Œå…¨ä¸€è‡´ - å³åº§ã«è¿”å´
                        if (cleanFileName === cleanZipName) {
                            return [{
                                ...item,
                                matchScore: 1.0,
                                matchType: 'exact_zip_match',
                                bestMatch: zipFile,
                                matchDetails: {
                                    score: 1.0,
                                    type: 'exact_zip_match',
                                    bestMatch: zipFile,
                                    availableZipFiles: item.zipFiles || []
                                }
                            }];
                        }
                    }
                }
            }
            
            
            // 2. ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: éƒ¨åˆ†ä¸€è‡´ãƒ»é¡ä¼¼åº¦æ¤œç´¢
            const candidates = [];
            
            for (const item of purchaseHistoryData) {
                let score = 0;
                let matchType = '';
                let bestMatch = '';
                
                // ZIPãƒ•ã‚¡ã‚¤ãƒ«åã§ã®éƒ¨åˆ†ä¸€è‡´ãƒ»é¡ä¼¼åº¦ãƒã‚§ãƒƒã‚¯
                if (item.zipFiles && item.zipFiles.length > 0) {
                    for (const zipFile of item.zipFiles) {
                        const cleanZipName = zipFile.replace(/\.(zip|unitypackage|rar|7z)$/i, '');
                        
                        // éƒ¨åˆ†ä¸€è‡´ï¼ˆé«˜ã‚¹ã‚³ã‚¢ï¼‰
                        if (cleanFileName.includes(cleanZipName) || cleanZipName.includes(cleanFileName)) {
                            const partialScore = Math.min(cleanFileName.length, cleanZipName.length) / Math.max(cleanFileName.length, cleanZipName.length);
                            if (partialScore > 0.7 && partialScore > score) {
                                score = 0.9 * partialScore;
                                matchType = 'partial_zip_match';
                                bestMatch = zipFile;
                            }
                        }
                        
                        // ZIPåã¨ã®é¡ä¼¼åº¦ãƒã‚§ãƒƒã‚¯
                        const zipSimilarity = calculateSimilarity(cleanFileName, cleanZipName);
                        if (zipSimilarity > 0.6 && zipSimilarity > score) {
                            score = 0.8 * zipSimilarity;
                            matchType = 'zip_similarity';
                            bestMatch = zipFile;
                        }
                    }
                }
                
                // ã‚¿ã‚¤ãƒˆãƒ«ã¨ã®ä¸€è‡´ï¼ˆZIPãƒãƒƒãƒãŒãªã„å ´åˆã®ã¿ï¼‰
                if (score < 0.5) {
                    const keywords = extractKeywords(fileName);
                    const titleKeywords = extractKeywords(item.title);
                    
                    // å…±é€šã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒã‚§ãƒƒã‚¯
                    const commonKeywords = keywords.filter(k => 
                        titleKeywords.some(tk => tk.includes(k) || k.includes(tk))
                    );
                    const keywordScore = commonKeywords.length * 0.3;
                    
                    // ã‚¿ã‚¤ãƒˆãƒ«ã¨ã®æ–‡å­—åˆ—é¡ä¼¼åº¦
                    const titleSimilarity = calculateSimilarity(fileName, item.title);
                    const titleScore = titleSimilarity * 0.6;
                    
                    // ä½œè€…åã‚‚ãƒã‚§ãƒƒã‚¯ï¼ˆãƒœãƒ¼ãƒŠã‚¹ï¼‰
                    let authorScore = 0;
                    if (item.author) {
                        const authorSimilarity = calculateSimilarity(fileName, item.author);
                        authorScore = authorSimilarity * 0.2;
                    }
                    
                    const totalTitleScore = keywordScore + titleScore + authorScore;
                    if (totalTitleScore > score) {
                        score = totalTitleScore;
                        matchType = 'title_match';
                        bestMatch = item.title;
                    }
                }
                
                if (score > 0.2) {
                    candidates.push({
                        ...item,
                        matchScore: score,
                        matchType: matchType,
                        bestMatch: bestMatch,
                        matchDetails: {
                            score: score,
                            type: matchType,
                            bestMatch: bestMatch,
                            availableZipFiles: item.zipFiles || []
                        }
                    });
                }
            }
            
            // ã‚¹ã‚³ã‚¢é †ã§ã‚½ãƒ¼ãƒˆã€ä¸Šä½8ä»¶
            return candidates.sort((a, b) => b.matchScore - a.matchScore).slice(0, 8);
        }
        
        // å€™è£œé¸æŠãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
        function showBoothCandidates(fileName, candidates, onSelect) {
            document.getElementById('searchFilename').textContent = fileName;
            document.getElementById('searchKeywords').textContent = extractKeywords(fileName).join(', ');
            
            const candidatesList = document.getElementById('boothCandidatesList');
            candidatesList.innerHTML = '';
            
            if (candidates.length === 0) {
                candidatesList.innerHTML = '<div style="text-align: center; color: #9ca3af; padding: 20px;">å€™è£œãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ</div>';
            } else {
                candidates.forEach((candidate, index) => {
                    const candidateDiv = document.createElement('div');
                    candidateDiv.style.cssText = `
                        display: flex; align-items: center; padding: 10px; 
                        border: 2px solid #4b5563; border-radius: 6px; margin-bottom: 10px; 
                        cursor: pointer; transition: all 0.2s;
                    `;
                    candidateDiv.dataset.index = index;
                    
                    candidateDiv.innerHTML = `
                        <div style="width: 60px; height: 60px; margin-right: 15px; flex-shrink: 0;">
                            ${candidate.thumbnailUrl ? 
                                `<img src="${candidate.thumbnailUrl}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 4px;">` : 
                                '<div style="width: 100%; height: 100%; background: #374151; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 24px;">ğŸ–¼ï¸</div>'
                            }
                        </div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; margin-bottom: 5px;">${candidate.title}</div>
                            <div style="color: #9ca3af; font-size: 14px; margin-bottom: 2px;">${candidate.author}</div>
                            <div style="color: #60a5fa; font-size: 12px; margin-bottom: 2px;">
                                ãƒãƒƒãƒåº¦: ${Math.round(candidate.matchScore * 100)}% 
                                ${candidate.matchType === 'exact_zip_match' ? '(å®Œå…¨ä¸€è‡´)' : 
                                  candidate.matchType === 'partial_zip_match' ? '(éƒ¨åˆ†ä¸€è‡´)' :
                                  candidate.matchType === 'zip_similarity' ? '(ZIPé¡ä¼¼)' : '(ã‚¿ã‚¤ãƒˆãƒ«)'}
                            </div>
                            ${candidate.bestMatch ? `<div style="color: #10b981; font-size: 11px;">ä¸€è‡´: ${candidate.bestMatch.length > 40 ? candidate.bestMatch.substring(0, 40) + '...' : candidate.bestMatch}</div>` : ''}
                            ${candidate.zipFiles && candidate.zipFiles.length > 0 ? 
                                `<div style="color: #6b7280; font-size: 11px;">${candidate.zipFiles.length}å€‹ã®ZIPãƒ•ã‚¡ã‚¤ãƒ«</div>` : ''
                            }
                        </div>
                    `;
                    
                    candidateDiv.addEventListener('click', () => {
                        // é¸æŠçŠ¶æ…‹ã‚’æ›´æ–°
                        candidatesList.querySelectorAll('[data-index]').forEach(el => {
                            el.style.borderColor = '#4b5563';
                            el.style.backgroundColor = 'transparent';
                        });
                        candidateDiv.style.borderColor = '#10b981';
                        candidateDiv.style.backgroundColor = '#065f46';
                        
                        // é¸æŠãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
                        const selectBtn = document.getElementById('selectBoothCandidate');
                        selectBtn.disabled = false;
                        selectBtn.dataset.selectedIndex = index;
                    });
                    
                    candidatesList.appendChild(candidateDiv);
                });
            }
            
            // é¸æŠãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
            const selectBtn = document.getElementById('selectBoothCandidate');
            selectBtn.disabled = true;
            selectBtn.onclick = () => {
                const selectedIndex = selectBtn.dataset.selectedIndex;
                if (selectedIndex !== undefined) {
                    const selected = candidates[parseInt(selectedIndex)];
                    onSelect(selected);
                    closeBoothCandidatesModal();
                }
            };
            
            // ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤º
            document.getElementById('boothCandidatesModal').style.display = 'block';
        }
        
        function closeBoothCandidatesModal() {
            document.getElementById('boothCandidatesModal').style.display = 'none';
        }
        
        function selectManualEntry() {
            closeBoothCandidatesModal();
            // æ‰‹å‹•å…¥åŠ›ã®å ´åˆã¯å€™è£œé¸æŠã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦å•†å“ç™»éŒ²ã‚’ç¶™ç¶š
            if (window.pendingProductData) {
                registerProduct(window.pendingProductData);
                window.pendingProductData = null;
            }
        }
        
        // ãƒ¢ãƒ¼ãƒ€ãƒ«å‡¦ç†ã‚­ãƒ¥ãƒ¼
        let modalQueue = [];
        let isModalProcessing = false;
        
        async function processModalQueue() {
            if (isModalProcessing || modalQueue.length === 0) return;
            
            isModalProcessing = true;
            const { fileName, candidates, productData } = modalQueue.shift();
            
            
            return new Promise((resolve) => {
                showBoothCandidates(fileName, candidates, async (selected) => {
                    // é¸æŠã•ã‚ŒãŸå•†å“æƒ…å ±ã‚’è¨­å®š
                    productData.booth_url = selected.boothUrl;
                    productData.thumbnail_url = selected.thumbnailUrl;
                    productData.author = selected.author;
                    productData.name = selected.title;
                    
                    if (selected.matchDetails) {
                    }
                    
                    // ã‚µãƒ ãƒã‚¤ãƒ«ãŒç„¡åŠ¹ãªå ´åˆã¯Boothã‹ã‚‰å†å–å¾—ã‚’è©¦è¡Œ
                    if (selected.boothUrl && (!selected.thumbnailUrl || selected.thumbnailUrl.includes('placeholder'))) {
                        try {
                            const thumbnailResult = await window.electronAPI.fetch.thumbnail(selected.boothUrl);
                            if (thumbnailResult.success && thumbnailResult.thumbnailUrl) {
                                productData.thumbnail_url = thumbnailResult.thumbnailUrl;
                            } else {
                            }
                        } catch (error) {
                        }
                    }
                    
                    await registerProduct(productData);
                    isModalProcessing = false;
                    resolve();
                    
                    // æ¬¡ã®ã‚­ãƒ¥ãƒ¼ã‚’å‡¦ç†
                    setTimeout(() => processModalQueue(), 100);
                });
                
                // æ‰‹å‹•å…¥åŠ›ã®å ´åˆã®å‡¦ç†ã‚‚æ›´æ–°
                const originalSelectManualEntry = window.selectManualEntry;
                window.selectManualEntry = () => {
                    closeBoothCandidatesModal();
                    registerProduct(productData);
                    isModalProcessing = false;
                    resolve();
                    
                    // æ¬¡ã®ã‚­ãƒ¥ãƒ¼ã‚’å‡¦ç†
                    setTimeout(() => processModalQueue(), 100);
                    
                    // å…ƒã®é–¢æ•°ã«æˆ»ã™
                    window.selectManualEntry = originalSelectManualEntry;
                };
            });
        }
        
        // å•†å“ç™»éŒ²å‡¦ç†ã‚’å…±é€šåŒ–
        async function registerProduct(productData) {
            try {
                const addResult = await window.electronAPI.database.addProduct(productData);
            } catch (dbError) {
                console.error('å•†å“ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¿½åŠ ã‚¨ãƒ©ãƒ¼:', dbError);
                alert(`ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¿½åŠ ã‚¨ãƒ©ãƒ¼: ${dbError.message}\n\næŠ½å‡ºã¯å®Œäº†ã—ã¦ã„ã¾ã™ãŒã€å•†å“ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸã€‚`);
                return;
            }
            
            // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ï¼ˆbooth_urlãŒã‚ã‚‹å ´åˆã®ã¿ï¼‰
            if (productData.booth_url) {
                try {
                    const fileName = productData.description.split('\n')[0] || productData.name;
                    await window.electronAPI.booth.learnMapping(fileName, productData.booth_url);
                } catch (learningError) {
                    console.error('å­¦ç¿’ãƒ‡ãƒ¼ã‚¿æ›´æ–°ã‚¨ãƒ©ãƒ¼:', learningError);
                }
            }
            
            try {
                // å•†å“ãƒªã‚¹ãƒˆã‚’æ›´æ–°
                await loadProducts();
            } catch (loadError) {
                console.error('å•†å“ãƒªã‚¹ãƒˆæ›´æ–°ã‚¨ãƒ©ãƒ¼:', loadError);
            }
        }
    </script>
</body>
</html>