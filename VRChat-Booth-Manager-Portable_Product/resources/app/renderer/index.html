<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VRChat Booth商品管理</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1f2937;
            color: white;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            background-color: #374151;
            padding: 12px 16px;
            border-radius: 6px;
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 60px;
        }
        .header h1 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: white;
        }
        
        /* レスポンシブ対応 */
        @media (max-width: 1000px) {
            .header {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
                padding: 16px;
            }
        }
        
        @media (max-width: 600px) {
            .header {
                padding: 12px;
            }
            .header h1 {
                font-size: 16px;
            }
        }
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
            60% {
                transform: translateY(-5px);
            }
        }
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
            }
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
        }
        .list {
            display: grid;
            grid-template-columns: 1fr;
            gap: 3px;
        }
        @media (min-width: 1000px) {
            .list {
                grid-template-columns: 1fr 1fr;
                gap: 8px;
            }
        }
        .list-item {
            background-color: #374151;
            border-radius: 4px;
            padding: 6px;
            display: flex;
            align-items: flex-start;
            gap: 6px;
            min-height: 52px;
            position: relative;
        }
        .list-item .item-checkbox {
            position: absolute;
            top: 4px;
            left: 4px;
            width: 12px;
            height: 12px;
        }
        .list-item .item-thumbnail {
            width: 60px;
            height: 48px;
            background-color: #4b5563;
            border-radius: 4px;
            flex-shrink: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 10px;
            margin-top: 2px;
        }
        .list-item .item-content {
            flex: 1;
            min-width: 0;
        }
        .list-item .item-title {
            font-size: 14px;
            font-weight: bold;
            margin: 0 0 2px 0;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            line-height: 1.3;
            word-break: break-word;
        }
        .list-item .item-info {
            font-size: 12px;
            color: #9ca3af;
            margin: 0;
        }
        .list-item .item-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
            align-self: center;
        }
        .list-item .item-actions button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .card {
            background-color: #374151;
            border-radius: 6px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s;
            position: relative;
        }
        .card:hover {
            transform: translateY(-2px);
        }
        .card-image {
            width: 100%;
            height: 150px;
            background-color: #4b5563;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        .card-image img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .card-content {
            padding: 15px;
            background-color: #374151;
            height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .card-title {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
            line-height: 1.3;
            min-height: 36px;
            max-height: 52px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            word-break: break-word;
        }
        .buttons {
            display: flex;
            gap: 5px;
        }
        .btn {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: white;
            min-width: 50px;
        }
        .btn-blue { background-color: #2563eb; }
        .btn-yellow { background-color: #d97706; }
        .btn-red { background-color: #dc2626; }
        .btn:hover { opacity: 0.8; }
        .add-btn {
            background-color: #16a34a;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            overflow-y: auto;
        }
        .modal-content {
            position: relative;
            margin: 50px auto;
            background-color: #374151;
            padding: 20px;
            border-radius: 6px;
            width: 800px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #4b5563;
            border-radius: 4px;
            background-color: #4b5563;
            color: white !important;
            caret-color: white !important;
            box-sizing: border-box;
        }
        
        /* 入力フィールドの可視性確保 */
        input[type="text"], input[type="url"], textarea {
            color: white !important;
            background-color: #374151 !important;
            caret-color: white !important;
            opacity: 1 !important;
            font-size: 14px !important;
            line-height: 1.4 !important;
        }
        
        /* プレースホルダーテキストの可視性 */
        input::placeholder, textarea::placeholder {
            color: #9ca3af !important;
            opacity: 0.7 !important;
        }
        .form-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .form-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .form-btn-cancel {
            background-color: #6b7280;
            color: white;
        }
        .form-btn-submit {
            background-color: #2563eb;
            color: white;
        }
        
        /* スマートマッチングUI */
        .smart-matching-modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
        }
        .smart-matching-content {
            position: relative;
            background-color: #1f2937;
            margin: 2% auto;
            padding: 20px;
            width: 95%;
            height: 90%;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
        }
        .matching-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #374151;
        }
        .matching-body {
            display: flex;
            flex: 1;
            gap: 20px;
            min-height: 0;
        }
        .matching-panel {
            flex: 1;
            background-color: #374151;
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
        }
        .panel-header {
            font-weight: bold;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #4b5563;
            border-radius: 6px;
            display: flex;
            justify-content: between;
            align-items: center;
        }
        .file-item, .purchase-item {
            background-color: #4b5563;
            margin: 10px 0;
            padding: 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        .file-item:hover, .purchase-item:hover {
            background-color: #6b7280;
            transform: translateY(-2px);
        }
        .file-item.selected, .purchase-item.selected {
            border-color: #3b82f6;
            background-color: #1e40af;
        }
        .file-item.matched, .purchase-item.matched {
            border-color: #10b981;
            background-color: #065f46;
        }
        .item-name {
            font-weight: bold;
            margin-bottom: 5px;
            word-break: break-word;
        }
        .item-details {
            font-size: 12px;
            color: #d1d5db;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .item-thumbnail {
            width: 48px;
            height: 48px;
            border-radius: 4px;
            object-fit: cover;
            margin-right: 10px;
            float: left;
        }
        .match-actions {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        .match-button {
            background-color: #10b981;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        .match-button:hover {
            background-color: #059669;
        }
        .match-button:disabled {
            background-color: #6b7280;
            cursor: not-allowed;
        }
        .progress-info {
            background-color: #374151;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" style="flex-wrap: wrap; gap: 15px;">
            <!-- タイトル行 -->
            <div style="display: flex; align-items: center; gap: 10px; flex-shrink: 0;">
                <h1 style="font-size: clamp(1.2rem, 2.5vw, 1.5rem); white-space: nowrap;">VRChat Booth商品管理</h1>
                <button onclick="showHelpModal()" style="width: 24px; height: 24px; border-radius: 50%; background-color: #6b7280; color: white; border: none; cursor: pointer; font-size: 14px; font-weight: bold; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s; flex-shrink: 0;" title="使い方を表示" onmouseover="this.style.backgroundColor='#4b5563'" onmouseout="this.style.backgroundColor='#6b7280'">?</button>
                <button onclick="showSettingsModal()" style="width: 24px; height: 24px; border-radius: 50%; background-color: #6b7280; color: white; border: none; cursor: pointer; font-size: 12px; font-weight: bold; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s; flex-shrink: 0;" title="設定" onmouseover="this.style.backgroundColor='#4b5563'" onmouseout="this.style.backgroundColor='#6b7280'">⚙</button>
            </div>
            
            <!-- 検索・操作行 -->
            <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap; flex: 1; min-width: 0;">
                <div style="position: relative; flex: 1; min-width: 200px; max-width: 300px;">
                    <input type="text" id="searchInput" placeholder="商品名・説明文で検索..." onkeyup="searchProducts()" style="padding: 6px 12px; background-color: #4b5563; color: white; border: 1px solid #6b7280; border-radius: 4px; font-size: 13px; width: 100%; height: 32px; box-sizing: border-box;">
                    <button onclick="clearSearch()" style="position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: none; border: none; color: #9ca3af; cursor: pointer; font-size: 16px;">×</button>
                </div>
                
                <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                    <button class="add-btn" onclick="importPurchaseHistory()" style="background-color: #10b981; font-size: 12px; padding: 6px 10px; white-space: nowrap;" title="購入履歴をインポート">📥 履歴</button>
                    <button class="add-btn" onclick="clearPurchaseHistory()" style="background-color: #6b7280; font-size: 12px; padding: 6px 10px; display: none; white-space: nowrap;" id="clearHistoryBtn" title="購入履歴をクリア">🗑️ 履歴</button>
                    <button class="add-btn" onclick="clearBoothLibraryData()" style="background-color: #9333ea; font-size: 12px; padding: 6px 10px; display: none; white-space: nowrap;" id="clearLibraryBtn" title="Boothライブラリ収集データをクリア">📚 収集</button>
                    <button class="add-btn" onclick="addProduct()" style="font-size: 12px; padding: 6px 10px; white-space: nowrap;">➕ 追加</button>
                </div>
            </div>
        </div>
        
        <div style="margin-bottom: 20px; display: flex; align-items: flex-start; gap: 25px; flex-wrap: wrap;">
            <div>
                <label style="color: white; font-weight: bold; display: block; margin-bottom: 6px;">表示カテゴリ:</label>
                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                    <label style="display: flex; align-items: center; gap: 4px; color: white; cursor: pointer;">
                        <input type="checkbox" id="filter_avatar" value="アバター本体" onchange="filterProducts()" checked style="width: 14px; height: 14px;">
                        <span style="font-size: 13px;">アバター本体</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; color: white; cursor: pointer;">
                        <input type="checkbox" id="filter_costume" value="衣装" onchange="filterProducts()" checked style="width: 14px; height: 14px;">
                        <span style="font-size: 13px;">衣装</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; color: white; cursor: pointer;">
                        <input type="checkbox" id="filter_accessory" value="アクセサリー" onchange="filterProducts()" checked style="width: 14px; height: 14px;">
                        <span style="font-size: 13px;">アクセサリー</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; color: white; cursor: pointer;">
                        <input type="checkbox" id="filter_hair" value="髪型" onchange="filterProducts()" checked style="width: 14px; height: 14px;">
                        <span style="font-size: 13px;">髪型</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; color: white; cursor: pointer;">
                        <input type="checkbox" id="filter_tool" value="ツール" onchange="filterProducts()" checked style="width: 14px; height: 14px;">
                        <span style="font-size: 13px;">ツール</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; color: white; cursor: pointer;">
                        <input type="checkbox" id="filter_pose" value="ポーズ" onchange="filterProducts()" checked style="width: 14px; height: 14px;">
                        <span style="font-size: 13px;">ポーズ</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; color: white; cursor: pointer;">
                        <input type="checkbox" id="filter_world" value="ワールド" onchange="filterProducts()" checked style="width: 14px; height: 14px;">
                        <span style="font-size: 13px;">ワールド</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 4px; color: white; cursor: pointer;">
                        <input type="checkbox" id="filter_other" value="その他" onchange="filterProducts()" checked style="width: 14px; height: 14px;">
                        <span style="font-size: 13px;">その他</span>
                    </label>
                </div>
            </div>
            <div style="display: flex; flex-wrap: wrap; justify-content: space-between; align-items: flex-start; gap: 12px; width: 100%;">
                <div style="display: flex; flex-wrap: wrap; gap: 12px; align-items: center; flex: 1; min-width: 0;">
                    <div style="display: flex; align-items: center; gap: 6px; min-width: fit-content;">
                        <label for="avatarSelect" style="color: white; font-size: 13px; font-weight: 500; white-space: nowrap;">対応アバター:</label>
                        <select id="avatarSelect" onchange="filterProducts()" style="padding: 6px 10px; background-color: #374151; color: white; border: 1px solid #4b5563; border-radius: 4px; font-size: 13px; min-width: 120px; height: 32px;">
                            <option value="all">すべて</option>
                            <!-- アバターオプションがここに追加されます -->
                        </select>
                    </div>
                    <div style="display: flex; align-items: center; gap: 6px; min-width: fit-content;">
                        <label for="tagSelect" style="color: white; font-size: 13px; font-weight: 500; white-space: nowrap;">タグ:</label>
                        <select id="tagSelect" onchange="filterProducts()" style="padding: 6px 10px; background-color: #374151; color: white; border: 1px solid #4b5563; border-radius: 4px; font-size: 13px; min-width: 120px; height: 32px;">
                            <option value="all">すべて</option>
                            <!-- タグオプションがここに追加されます -->
                        </select>
                    </div>
                    <div style="display: flex; align-items: center; gap: 6px; min-width: fit-content;">
                        <label for="orderSelect" style="color: white; font-size: 13px; font-weight: 500; white-space: nowrap;">並び順:</label>
                        <select id="orderSelect" onchange="filterProducts()" style="padding: 6px 10px; background-color: #374151; color: white; border: 1px solid #4b5563; border-radius: 4px; font-size: 13px; min-width: 120px; height: 32px;">
                            <option value="created_desc">新しい順</option>
                            <option value="created_asc">古い順</option>
                        </select>
                    </div>
                </div>
                <div style="display: flex; align-items: center; gap: 4px; flex-shrink: 0;">
                    <button id="gridViewBtn" onclick="switchToGridView()" style="padding: 6px; background-color: #4b5563; color: white; border: 1px solid #6b7280; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; width: 32px; height: 32px;" title="グリッド表示">
                        <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                            <rect x="1" y="1" width="6" height="6" rx="1"/>
                            <rect x="9" y="1" width="6" height="6" rx="1"/>
                            <rect x="1" y="9" width="6" height="6" rx="1"/>
                            <rect x="9" y="9" width="6" height="6" rx="1"/>
                        </svg>
                    </button>
                    <button id="listViewBtn" onclick="switchToListView()" style="padding: 6px; background-color: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; width: 32px; height: 32px;" title="リスト表示">
                        <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
                            <rect x="2" y="3" width="2" height="2" rx="1"/>
                            <rect x="6" y="3" width="8" height="2" rx="1"/>
                            <rect x="2" y="7" width="2" height="2" rx="1"/>
                            <rect x="6" y="7" width="8" height="2" rx="1"/>
                            <rect x="2" y="11" width="2" height="2" rx="1"/>
                            <rect x="6" y="11" width="8" height="2" rx="1"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- ドラッグ&ドロップエリア -->
        <div id="dropZone" style="border: 2px dashed #4b5563; border-radius: 6px; padding: 40px; text-align: center; margin-bottom: 20px; background-color: #374151; display: none; transition: all 0.3s ease;">
            <div style="font-size: 48px; margin-bottom: 16px;">⬇️</div>
            <p style="color: #9ca3af; margin: 0; font-size: 18px; font-weight: 600;">📦 ここにドロップして商品を登録</p>
            <p style="color: #6b7280; margin: 8px 0 0 0; font-size: 14px;">.unitypackageファイルまたはフォルダをドロップ</p>
        </div>

        <!-- ドラッグ中のフルスクリーンオーバーレイ -->
        <div id="dragOverlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 9999; display: none; pointer-events: none;">
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white;">
                <div style="font-size: 80px; margin-bottom: 20px; animation: bounce 1s infinite;">📦</div>
                <h2 style="font-size: 28px; margin: 0 0 10px 0; color: #60a5fa;">ファイルをドロップして登録</h2>
                <p style="font-size: 16px; margin: 0; color: #d1d5db;">.unitypackageファイルまたはフォルダを離してください</p>
            </div>
        </div>
        
        
        <!-- 選択時のタグ編集ブロック（下部固定） -->
        <div id="selectionBlock" style="opacity: 0; visibility: hidden; transform: translateY(100%); position: fixed; bottom: 0; left: 0; right: 0; background-color: #374151; padding: 12px; border-top: 2px solid #4b5563; box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.4); z-index: 100; transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out, visibility 0.3s;">
            <!-- ヘッダー行 -->
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                <span style="color: white; font-weight: 600; font-size: 13px;"><span id="selectedCount">0</span>個選択中</span>
                <div style="display: flex; gap: 6px;">
                    <button onclick="deleteSelectedProducts()" style="padding: 6px 12px; background-color: #dc2626; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; height: 32px; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#b91c1c'" onmouseout="this.style.backgroundColor='#dc2626'">選択したアイテムを削除</button>
                    <button onclick="clearSelection()" style="padding: 6px 12px; background-color: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; height: 32px; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#4b5563'" onmouseout="this.style.backgroundColor='#6b7280'">選択を解除</button>
                </div>
            </div>
            
            <!-- タグ編集エリア -->
            <div style="background-color: #4b5563; border-radius: 4px; padding: 8px;">
                <label style="color: #d1d5db; font-size: 11px; margin-bottom: 6px; display: block; font-weight: 500;">タグ編集</label>
                
                <!-- 選択済みタグ表示エリア -->
                <div id="selectedTagsArea" style="display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 8px; min-height: 20px; align-items: flex-start; background-color: #374151; border-radius: 3px; padding: 6px; border: 1px solid #6b7280;">
                </div>
                
                <!-- タグ入力エリア -->
                <div style="display: flex; gap: 6px; align-items: center;">
                    <div style="position: relative; flex: 1; max-width: 250px;">
                        <input type="text" id="tagInput" placeholder="タグを入力してEnterまたは+ボタン" style="width: 100%; padding: 6px 8px; background-color: #374151; color: white; border: 1px solid #6b7280; border-radius: 4px; font-size: 12px; box-sizing: border-box; transition: border-color 0.2s;" 
                               onkeydown="handleTagInput(event)" 
                               oninput="showTagSuggestions(this.value)"
                               onfocus="showTagSuggestions(this.value); this.style.borderColor='#059669'"
                               onblur="setTimeout(() => hideTagSuggestions(), 100); this.style.borderColor='#6b7280'">
                        
                        <!-- タグ候補ドロップダウン（上向き表示） -->
                        <div id="tagSuggestions" style="display: none; position: absolute; bottom: 100%; left: 0; right: 0; background-color: #374151; border: 1px solid #6b7280; border-radius: 4px; max-height: 150px; overflow-y: auto; z-index: 200; margin-bottom: 2px; box-shadow: 0 -4px 6px rgba(0, 0, 0, 0.3);">
                        </div>
                    </div>
                    
                    <!-- タグ追加ボタン -->
                    <button onclick="this.blur(); addTagFromInput();" style="padding: 6px 12px; background-color: #0369a1; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 500; height: 32px; transition: background-color 0.2s; display: flex; align-items: center; gap: 2px;" onmouseover="this.style.backgroundColor='#0284c7'" onmouseout="this.style.backgroundColor='#0369a1'">
                        <span style="font-size: 14px; line-height: 1;">+</span>追加
                    </button>
                    
                    <!-- 適用ボタン -->
                    <button onclick="this.blur(); applyTagsToSelected();" style="padding: 6px 12px; background-color: #059669; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#047857'" onmouseout="this.style.backgroundColor='#059669'">
                        選択した商品にタグを適用
                    </button>
                </div>
            </div>
        </div>
        
        <div id="products" class="grid" style="padding-bottom: 20px;">
            <!-- 商品がここに表示されます -->
        </div>
    </div>

    <!-- 商品追加・編集モーダル -->
    <div id="productModal" class="modal">
        <div class="modal-content">
            <h2 id="modalTitle">商品を追加</h2>
            <form id="productForm">
                <div class="form-group">
                    <label for="productName">商品名 *</label>
                    <input type="text" id="productName" name="name" required>
                </div>
                <div class="form-group">
                    <label for="productCategory">カテゴリ</label>
                    <select id="productCategory" name="category" onchange="handleCategoryChange()">
                        <option value="アバター本体">アバター本体</option>
                        <option value="衣装">衣装</option>
                        <option value="アクセサリー">アクセサリー</option>
                        <option value="髪型">髪型</option>
                        <option value="ツール">ツール</option>
                        <option value="ポーズ">ポーズ</option>
                        <option value="ワールド">ワールド</option>
                        <option value="その他">その他</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="productBoothUrl">Booth URL</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="url" id="productBoothUrl" name="booth_url" placeholder="https://booth.pm/..." style="flex: 1;">
                        <button type="button" onclick="searchBoothForCurrentFile()" class="form-btn" style="background-color: #2563eb; color: white;">①BOOTH検索</button>
                        <button type="button" id="thumbnailFetchBtn" class="form-btn form-btn-submit">②サムネイル取得</button>
                    </div>
                </div>
                <div class="form-group">
                    <label for="productThumbnailUrl">サムネイル URL</label>
                    <input type="url" id="productThumbnailUrl" name="thumbnail_url" oninput="showThumbnailPreview(this.value)" onchange="showThumbnailPreview(this.value)">
                    <!-- サムネイル プレビュー -->
                    <div id="thumbnailPreview" style="margin-top: 8px; display: none;">
                        <img id="thumbnailImage" style="max-width: 200px; max-height: 200px; border-radius: 4px; border: 1px solid #6b7280;" alt="サムネイル プレビュー" draggable="false">
                    </div>
                </div>
                <div class="form-group">
                    <label for="productFilePath">ファイル <span id="selectedFileInfo" style="font-size: 11px; color: #9ca3af;"></span></label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="productFilePath" name="file_path" style="flex: 1;" readonly placeholder="ファイルを選択してください（複数選択可）">
                        <button type="button" onclick="selectMultipleFiles()" class="form-btn form-btn-submit" style="min-width: 120px;">
                            📄 ファイル選択
                        </button>
                    </div>
                    <!-- 複数ファイル表示エリア -->
                    <div id="multipleFilesArea" style="margin-top: 12px; display: none;">
                        <label style="font-size: 13px; color: #d1d5db; margin-bottom: 8px; display: block; font-weight: 500;">
                            📁 ファイル一覧 
                            <span style="font-size: 11px; color: #9ca3af; font-weight: normal;">（各ファイルの表示名を自由に編集できます）</span>
                        </label>
                        <div id="filesList" style="max-height: 150px; overflow-y: auto; border: 1px solid #6b7280; border-radius: 6px; padding: 8px; background-color: #374151;">
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <label for="productAvatars">対応アバター</label>
                    <div id="avatarCheckboxes" style="max-height: 150px; overflow-y: auto; border: 1px solid #4b5563; border-radius: 4px; padding: 10px; background-color: #4b5563;">
                        <!-- アバターのチェックボックスがここに表示されます -->
                    </div>
                </div>
                <div class="form-group">
                    <label for="productTags">タグ</label>
                    <div id="tagCheckboxes" style="max-height: 120px; overflow-y: auto; border: 1px solid #4b5563; border-radius: 4px; padding: 10px; background-color: #4b5563; margin-bottom: 10px;">
                        <!-- タグのチェックボックスがここに表示されます -->
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="newTagInput" placeholder="新しいタグを追加" onkeypress="if(event.key==='Enter'){addNewTag();}" style="flex: 1; padding: 6px 8px; border: 1px solid #4b5563; border-radius: 4px; background-color: #4b5563; color: white; font-size: 12px;">
                        <button type="button" onclick="addNewTag()" style="padding: 6px 12px; background-color: #16a34a; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">追加</button>
                    </div>
                </div>
                <div class="form-group">
                    <label for="productDescription">説明</label>
                    <textarea id="productDescription" name="description" rows="3"></textarea>
                </div>
                <div class="form-buttons">
                    <button type="button" onclick="closeModal()" class="form-btn form-btn-cancel">キャンセル</button>
                    <button type="submit" class="form-btn form-btn-submit">保存</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        let products = [];
        let avatars = [];
        let currentSort = 'created_desc';
        let currentSortOrder = 'created_desc'; // 現在の並び順を保持
        let searchQuery = '';
        let isListView = false;
        let selectedProducts = new Set();

        // Electronからデータを取得
        async function loadProducts() {
            try {
                if (window.electronAPI) {
                    const rawProducts = await window.electronAPI.database.getProducts();
                    products = rawProducts.map(cleanupInvalidAvatarIds);
                    avatars = await window.electronAPI.database.getAvatars();
                    
                    // アバターフィルタの選択肢を更新
                    updateAvatarFilterOptions();
                    
                    filterProducts();
                    
                    // 入力フィールドの基本設定を適用
                    setTimeout(() => {
                        const inputFields = document.querySelectorAll('input[type="text"], input[type="url"], textarea');
                        inputFields.forEach(field => {
                            field.style.pointerEvents = 'auto';
                            field.style.userSelect = 'text';
                            field.disabled = false;
                            field.readOnly = false;
                        });
                    }, 100);
                }
            } catch (error) {
                console.error('Failed to load products:', error);
            }
        }

        // 全アバターリストを取得
        function getAllAvatars() {
            console.log('getAllAvatars() 実行開始');
            // avatars配列と「アバター本体」カテゴリの商品からアバターを取得
            const allAvatars = [...avatars];
            console.log('avatars配列:', avatars);
            
            // 「アバター本体」カテゴリの商品をアバターとして追加
            const avatarProducts = products.filter(product => product.category === 'アバター本体');
            console.log('アバター本体カテゴリの商品:', avatarProducts);
            
            avatarProducts.forEach(product => {
                // 既に同じIDまたは同じ名前のアバターが存在しない場合のみ追加
                if (!allAvatars.find(avatar => avatar.id === product.id || avatar.name === product.name)) {
                    allAvatars.push({
                        id: product.id,
                        name: product.name,
                        thumbnail_url: product.thumbnail_url
                    });
                    console.log('アバターを追加:', product.name);
                }
            });
            
            console.log('getAllAvatars() 結果:', allAvatars);
            return allAvatars;
        }

        // アバターフィルタの選択肢を更新
        function updateAvatarFilterOptions() {
            console.log('updateAvatarFilterOptions() 実行開始');
            const avatarSelect = document.getElementById('avatarSelect');
            if (!avatarSelect) {
                console.log('avatarSelect要素が見つかりません');
                return;
            }
            
            // 現在選択されているアバターを保持
            const currentSelectedAvatar = avatarSelect.value;
            console.log('現在選択されているアバター:', currentSelectedAvatar);
            
            // 現在の選択肢をクリア（「すべて」オプションは保持）
            avatarSelect.innerHTML = '<option value="all">すべて</option>';
            
            // 利用可能なアバターを取得
            const allAvatars = getAllAvatars();
            console.log('利用可能なアバター一覧:', allAvatars);
            
            // 新しい選択肢を追加
            allAvatars.forEach(avatar => {
                const option = document.createElement('option');
                option.value = avatar.id.toString();
                option.textContent = avatar.name;
                avatarSelect.appendChild(option);
            });
            
            // 以前の選択を復元（そのアバターがまだ存在する場合）
            const avatarExists = allAvatars.some(avatar => avatar.id.toString() === currentSelectedAvatar);
            console.log('以前選択されていたアバターがまだ存在するか:', avatarExists);
            if (avatarExists) {
                avatarSelect.value = currentSelectedAvatar;
                console.log('以前の選択を復元しました');
            } else {
                // 削除されたアバターが選択されていた場合は「すべて」にリセット
                avatarSelect.value = 'all';
                console.log('削除されたアバターが選択されていたため「すべて」にリセットしました');
            }
            
            console.log('updateAvatarFilterOptions() 実行完了');
        }

        
        // 検索ボックステスト用
        function testInput() {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.style.border = '3px solid red';
                searchInput.focus();
                alert('画面上部の検索ボックス（赤枠）で文字入力を試してください。入力できるか確認してから次のステップに進みます。');
                
                // 5秒後にボーダーを元に戻す
                setTimeout(() => {
                    searchInput.style.border = '1px solid #6b7280';
                }, 5000);
            }
        }

        // ファイル名を正規化する統一関数
        function normalizeFileName(fileName) {
            // 拡張子を除去（.unitypackage, .zip, .rar, .7z など）
            let name = fileName.replace(/\.(unitypackage|zip|rar|7z|tar|gz)$/i, '');
            
            // バージョン番号、日付、修正情報を除去
            name = name
                .replace(/_?v?\d+\.\d+.*$/i, '') // バージョン番号
                .replace(/_?\d{8}.*$/i, '') // 日付
                .replace(/_?(fix|final|update|patch).*$/i, '') // 修正・更新情報
                .replace(/[\[\]()（）]/g, '') // 括弧除去
                .replace(/[_-]+/g, ' ') // アンダースコアとハイフンをスペースに統一
                .replace(/\s+/g, ' ') // 連続スペースを単一スペースに
                .trim(); // 前後の空白除去
                
            return name;
        }
        
        // 検索用キーワードを抽出する関数
        function extractSearchKeywords(fileName) {
            const normalizedName = normalizeFileName(fileName);
            const keywords = normalizedName.split(/\s+/).filter(word => word.length > 1);
            return {
                normalizedName: normalizedName,
                keywords: keywords,
                originalFileName: fileName
            };
        }
        
        // ファイル名の類似度を計算する関数（あいまい検索用）
        function calculateSimilarity(str1, str2) {
            // 両方を正規化して比較
            const norm1 = normalizeFileName(str1).toLowerCase();
            const norm2 = normalizeFileName(str2).toLowerCase();
            
            // 完全一致
            if (norm1 === norm2) return 1.0;
            
            // キーワードベースの類似度計算
            const words1 = norm1.split(/\s+/).filter(w => w.length > 1);
            const words2 = norm2.split(/\s+/).filter(w => w.length > 1);
            
            if (words1.length === 0 || words2.length === 0) return 0;
            
            let matchCount = 0;
            for (const word1 of words1) {
                for (const word2 of words2) {
                    // 完全一致または部分一致
                    if (word1.includes(word2) || word2.includes(word1)) {
                        matchCount++;
                        break;
                    }
                }
            }
            
            return matchCount / Math.max(words1.length, words2.length);
        }

        // ファイル名からキーワードを抽出する関数
        function extractKeywords(text) {
            const keywords = [];
            
            // 日本語・英語・数字を抽出
            const matches = text.match(/[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF\w]+/g) || [];
            
            for (const match of matches) {
                // 3文字以上で、数字のみでないもの
                if (match.length >= 3 && !/^\d+$/.test(match)) {
                    keywords.push(match.toLowerCase());
                }
            }
            
            return keywords;
        }
        
        // 学習データとのあいまい検索を行う関数
        async function searchWithFuzzyMatching(targetFileName) {
            try {
                // バックエンドの検索機能を使用（既にファジーマッチング機能が実装済み）
                const result = await window.electronAPI.booth.searchByFilename(targetFileName);
                return result;
                
            } catch (error) {
                return { success: false, results: [], error: error.message };
            }
        }

        // グローバルイベントリスナー（tagInput値保存用）
        function setupGlobalEventListeners() {
            document.addEventListener('input', function(e) {
                // tagInputの場合は値を保存（フォールバック用）
                if (e.target.id === 'tagInput') {
                    window.lastTagInputValue = e.target.value;
                    return;
                }
            }, true);
        }

        // 商品の無効なアバターIDをクリーンアップ
        function cleanupInvalidAvatarIds(product) {
            if (!product.avatar_ids || product.avatar_ids.trim() === '') return product;
            
            const validAvatarIds = getAllAvatars().map(avatar => avatar.id.toString());
            const currentAvatarIds = product.avatar_ids.split(',').map(id => id.trim()).filter(id => id);
            const cleanedAvatarIds = currentAvatarIds.filter(id => validAvatarIds.includes(id));
            
            return {
                ...product,
                avatar_ids: cleanedAvatarIds.join(',')
            };
        }

        // アバター選択肢を更新
        function updateAvatarSelects() {
            const allAvatars = getAllAvatars();
            
            // 商品登録フォーム内のアバターチェックボックスを更新
            const avatarCheckboxes = document.getElementById('avatarCheckboxes');
            avatarCheckboxes.innerHTML = '';
            
            if (allAvatars.length === 0) {
                avatarCheckboxes.innerHTML = '<p style="color: #9ca3af; margin: 0;">アバターが登録されていません</p>';
            } else {
                allAvatars.forEach(avatar => {
                    const label = document.createElement('label');
                    label.style.display = 'flex';
                    label.style.alignItems = 'center';
                    label.style.gap = '8px';
                    label.style.color = 'white';
                    label.style.cursor = 'pointer';
                    label.style.marginBottom = '5px';
                    
                    label.innerHTML = `
                        <input type="checkbox" value="${avatar.id}" style="width: 16px; height: 16px;">
                        <span>${avatar.name}</span>
                    `;
                    
                    avatarCheckboxes.appendChild(label);
                });
            }
            
            updateTagCheckboxes();
            updateAvatarFilterSelect();
        }
        
        // カテゴリ変更時の処理
        function handleCategoryChange() {
            const categorySelect = document.getElementById('productCategory');
            const selectedCategory = categorySelect.value;
            
            // カテゴリがアバター本体の場合、アバターリストを更新してモーダルに反映
            if (selectedCategory === 'アバター本体') {
                // 現在編集中の商品情報があるか確認
                const productIdInput = document.querySelector('#productForm input[name="id"]');
                const currentProductId = productIdInput ? productIdInput.value : null;
                
                // 商品名を取得
                const productNameInput = document.getElementById('productName');
                const productName = productNameInput ? productNameInput.value : '';
                
                if (productName && !currentProductId) {
                    // 新規登録でアバター本体カテゴリの場合、アバターマスターに追加
                    const newAvatar = {
                        id: Date.now(),
                        name: productName,
                        created_at: new Date().toISOString()
                    };
                    
                    // ローカルのアバター配列に追加
                    if (!avatars.some(a => a.name === productName)) {
                        avatars.push(newAvatar);
                        
                        // アバターマスターに登録（非同期）
                        if (window.electronAPI && window.electronAPI.database) {
                            window.electronAPI.database.addAvatar(newAvatar).then(() => {
                                console.log('アバターマスターに追加:', productName);
                            }).catch(error => {
                                console.error('アバター追加エラー:', error);
                            });
                        }
                    }
                }
                
                // アバターチェックボックスを即座に更新
                updateAvatarCheckboxesImmediate();
            }
        }
        
        // アバターチェックボックスを即座に更新する関数
        function updateAvatarCheckboxesImmediate() {
            const allAvatars = getAllAvatars();
            const avatarCheckboxes = document.getElementById('avatarCheckboxes');
            
            // 現在選択されているアバターIDを保持
            const selectedAvatarIds = [];
            const currentCheckboxes = document.querySelectorAll('#avatarCheckboxes input[type="checkbox"]:checked');
            currentCheckboxes.forEach(checkbox => {
                selectedAvatarIds.push(checkbox.value);
            });
            
            // チェックボックスを再構築
            avatarCheckboxes.innerHTML = '';
            
            if (allAvatars.length === 0) {
                avatarCheckboxes.innerHTML = '<p style="color: #9ca3af; margin: 0;">アバターが登録されていません</p>';
            } else {
                allAvatars.forEach(avatar => {
                    const label = document.createElement('label');
                    label.style.display = 'flex';
                    label.style.alignItems = 'center';
                    label.style.gap = '8px';
                    label.style.color = 'white';
                    label.style.cursor = 'pointer';
                    label.style.marginBottom = '5px';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = avatar.id;
                    checkbox.style.width = '16px';
                    checkbox.style.height = '16px';
                    
                    // 以前選択されていたものは選択状態を維持
                    if (selectedAvatarIds.includes(avatar.id.toString())) {
                        checkbox.checked = true;
                    }
                    
                    const span = document.createElement('span');
                    span.textContent = avatar.name;
                    
                    label.appendChild(checkbox);
                    label.appendChild(span);
                    avatarCheckboxes.appendChild(label);
                });
            }
        }
        
        // タグチェックボックスを更新
        function updateTagCheckboxes() {
            const allTags = getAllTags();
            
            // 商品登録フォーム内のタグチェックボックスを更新
            const tagCheckboxes = document.getElementById('tagCheckboxes');
            tagCheckboxes.innerHTML = '';
            
            if (allTags.length === 0) {
                tagCheckboxes.innerHTML = '<p style="color: #9ca3af; margin: 0;">まだタグが登録されていません</p>';
            } else {
                allTags.forEach(tag => {
                    const label = document.createElement('label');
                    label.style.display = 'flex';
                    label.style.alignItems = 'center';
                    label.style.gap = '8px';
                    label.style.color = 'white';
                    label.style.cursor = 'pointer';
                    label.style.marginBottom = '5px';
                    
                    label.innerHTML = `
                        <input type="checkbox" value="${tag}" style="width: 16px; height: 16px;">
                        <span>${tag}</span>
                    `;
                    
                    tagCheckboxes.appendChild(label);
                });
            }
        }
        
        // フィルタ用のアバター選択肢のみを更新
        function updateAvatarFilterSelect() {
            const allAvatars = getAllAvatars();
            
            // フィルタ用のアバター選択肢を更新
            const avatarSelect = document.getElementById('avatarSelect');
            const currentValue = avatarSelect.value; // 現在選択されている値を保持
            avatarSelect.innerHTML = '<option value="all">すべて</option>';
            
            allAvatars.forEach(avatar => {
                const option = document.createElement('option');
                option.value = avatar.id;
                option.textContent = avatar.name;
                avatarSelect.appendChild(option);
            });
            
            // 選択値を復元
            if (currentValue) {
                avatarSelect.value = currentValue;
            }
        }
        
        // 全商品からタグリストを取得
        function getAllTags() {
            const allTags = new Set();
            
            products.forEach(product => {
                if (product.tags && product.tags.trim() !== '') {
                    const productTags = product.tags.split(',').map(tag => tag.trim()).filter(tag => tag);
                    productTags.forEach(tag => allTags.add(tag));
                }
            });
            
            return Array.from(allTags).sort();
        }
        
        // タグフィルタ選択肢を更新
        function updateTagFilterSelect() {
            const allTags = getAllTags();
            
            // タグフィルタの選択肢を更新
            const tagSelect = document.getElementById('tagSelect');
            const currentValue = tagSelect.value; // 現在選択されている値を保持
            tagSelect.innerHTML = '<option value="all">すべて</option>';
            
            allTags.forEach(tag => {
                const option = document.createElement('option');
                option.value = tag;
                option.textContent = tag;
                tagSelect.appendChild(option);
            });
            
            // 選択値を復元
            if (currentValue && allTags.includes(currentValue)) {
                tagSelect.value = currentValue;
            }
        }

        // フィルタ・ソート機能
        function filterProducts() {
            // チェックされているカテゴリを取得
            const checkedCategories = [];
            const checkboxes = ['filter_avatar', 'filter_costume', 'filter_accessory', 'filter_hair', 'filter_other', 'filter_tool', 'filter_pose', 'filter_world', 'filter_zip_extracted'];
            
            checkboxes.forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox && checkbox.checked) {
                    checkedCategories.push(checkbox.value);
                }
            });
            
            
            // カテゴリフィルタリング
            let filteredProducts = products.filter(product => {
                // カテゴリが空の場合は「その他」として扱う
                const productCategory = product.category || 'その他';
                const hasCategory = checkedCategories.includes(productCategory);
                if (!hasCategory && product.category === '') {
                }
                return hasCategory;
            });
            
            
            // 検索フィルタリング
            if (searchQuery) {
                filteredProducts = filteredProducts.filter(product => {
                    const searchFields = [
                        product.name || '',
                        product.description || '',
                        product.tags || ''
                    ].join(' ').toLowerCase();
                    
                    return searchFields.includes(searchQuery);
                });
            }
            
            // アバターフィルタリング
            const selectedAvatar = document.getElementById('avatarSelect')?.value;
            if (selectedAvatar && selectedAvatar !== 'all') {
                const validAvatarIds = getAllAvatars().map(avatar => avatar.id.toString());
                filteredProducts = filteredProducts.filter(product => {
                    if (!product.avatar_ids || product.avatar_ids.trim() === '') return false;
                    const avatarIds = product.avatar_ids.split(',').map(id => id.trim()).filter(id => id && validAvatarIds.includes(id));
                    return avatarIds.includes(selectedAvatar);
                });
            }
            
            // タグフィルタリング
            const selectedTag = document.getElementById('tagSelect')?.value;
            if (selectedTag && selectedTag !== 'all') {
                filteredProducts = filteredProducts.filter(product => {
                    if (!product.tags || product.tags.trim() === '') return false;
                    const productTags = product.tags.split(',').map(tag => tag.trim()).filter(tag => tag);
                    return productTags.includes(selectedTag);
                });
            }
            
            // 並び順適用
            const orderSelect = document.getElementById('orderSelect');
            if (orderSelect) {
                currentSortOrder = orderSelect.value; // 現在の並び順を保存
            }
            const orderType = currentSortOrder || 'created_desc';
            
            filteredProducts.sort((a, b) => {
                switch (orderType) {
                    case 'created_desc':
                        return new Date(b.created_at) - new Date(a.created_at);
                    case 'created_asc':
                        return new Date(a.created_at) - new Date(b.created_at);
                    default:
                        return 0;
                }
            });
            
            renderProducts(filteredProducts);
            
            // フィルタ用の選択肢は常に更新
            updateAvatarFilterSelect();
            updateTagFilterSelect();
            
            // モーダルが開いていない場合のみフォーム内のアバターチェックボックスを更新
            const productModal = document.getElementById('productModal');
            if (!productModal || productModal.style.display !== 'block') {
                updateAvatarSelects();
            }
        }

        // 商品一覧を表示
        function renderProducts(productsToRender = products) {
            const container = document.getElementById('products');
            container.innerHTML = '';
            container.className = isListView ? 'list' : 'grid';
            
            productsToRender.forEach(product => {
                const item = document.createElement('div');
                item.className = isListView ? 'list-item' : 'card';
                item.setAttribute('data-product-id', product.id);
                
                if (isListView) {
                    item.innerHTML = `
                        <input type="checkbox" class="item-checkbox" ${selectedProducts.has(product.id) ? 'checked' : ''} readonly>
                        <div class="item-thumbnail" onclick="toggleProductSelection(${product.id})">
                            ${product.thumbnail_url ? 
                                `<img src="${product.thumbnail_url}" alt="${product.name}" style="width: 100%; height: 100%; object-fit: cover;" draggable="false">` : 
                                '<div style="display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; color: #9ca3af; font-size: 11px;">画像なし</div>'
                            }
                        </div>
                        <div class="item-content" onclick="openProductDetail(${product.id})">
                            <div class="item-title" title="${product.name}">${product.name}</div>
                            <div class="item-info">カテゴリ: ${product.category}</div>
                        </div>
                        <div class="item-actions">
                            ${product.file_path ? 
                                `<button class="btn btn-blue" onclick="openFile(event, '${product.file_path.replace(/\\/g, '\\\\')}', ${product.id})">Unity${product.file_paths && product.file_paths.includes('|') ? ' ▼' : ''}</button>` : ''
                            }
                            <button class="btn btn-yellow" onclick="editProduct(event, ${product.id})">編集</button>
                            <button class="btn btn-red" onclick="deleteProduct(event, ${product.id})">削除</button>
                        </div>
                    `;
                } else {
                    item.innerHTML = `
                        <input type="checkbox" class="item-checkbox" ${selectedProducts.has(product.id) ? 'checked' : ''} readonly style="position: absolute; top: 8px; left: 8px; width: 16px; height: 16px; z-index: 10;">
                        <div class="card-image" onclick="toggleProductSelection(${product.id})">
                            ${product.thumbnail_url ? 
                                `<img src="${product.thumbnail_url}" alt="${product.name}" draggable="false">` : 
                                '<span style="color: #9ca3af;">画像なし</span>'
                            }
                        </div>
                        <div class="card-content" onclick="openProductDetail(${product.id})">
                            <div class="card-title" title="${product.name}">${product.name}</div>
                            <div class="buttons">
                                ${product.file_path ? 
                                    `<button class="btn btn-blue" onclick="openFile(event, '${product.file_path.replace(/\\/g, '\\\\')}', ${product.id})">Unity${product.file_paths && product.file_paths.includes('|') ? ' ▼' : ''}</button>` : ''
                                }
                                <button class="btn btn-yellow" onclick="editProduct(event, ${product.id})">編集</button>
                                <button class="btn btn-red" onclick="deleteProduct(event, ${product.id})">削除</button>
                            </div>
                        </div>
                    `;
                }
                
                container.appendChild(item);
            });
            
            updateSelectionBlock();
        }

        // ファイルを開く
        async function openFile(event, filePath, productId) {
            if (event) event.stopPropagation();
            
            
            if (!filePath || filePath.trim() === '') {
                alert('ファイルパスが設定されていません');
                return;
            }
            
            // 複数ファイルを持つ商品の場合、選択メニューを表示
            if (productId) {
                try {
                    const products = await window.electronAPI.database.getProducts();
                    const product = products.find(p => p.id === productId);
                    if (product && product.file_paths && product.file_paths.includes('|')) {
                        // 複数ファイルの場合、選択メニューを表示
                        showFileSelectionMenu(event, product);
                        return;
                    }
                } catch (error) {
                    console.error('商品データ取得エラー:', error);
                }
            }
            
            if (window.electronAPI) {
                try {
                    
                    // ファイル存在確認
                    const fileExists = await window.electronAPI.fs.exists(filePath);
                    
                    if (!fileExists) {
                        alert(`ファイルが見つかりません: ${filePath}`);
                        return;
                    }
                    
                    await window.electronAPI.shell.openFile(filePath);
                } catch (error) {
                    console.error('ファイルオープンエラー:', error);
                    console.error('Failed file path:', filePath);
                    
                    // エラーメッセージをより分かりやすく表示
                    if (error.message && error.message.includes('Unity')) {
                        alert(error.message);
                    } else {
                        alert(`ファイルを開けませんでした:\n${error.message || error}\n\n対処法:\n1. Unity Hubがインストールされているか確認\n2. Unityプロジェクトを開いてから再度お試しください`);
                    }
                }
            } else {
                alert('Electron APIが利用できません');
            }
        }

        let currentEditingProductId = null;
        
        // 新しいタグを追加
        function addNewTag() {
            const newTagInput = document.getElementById('newTagInput');
            const newTag = newTagInput.value.trim();
            
            if (newTag === '') {
                alert('タグ名を入力してください');
                return;
            }
            
            // 既存タグとの重複チェック
            const allTags = getAllTags();
            if (allTags.includes(newTag)) {
                alert('既に存在するタグです');
                return;
            }
            
            // 新しいタグを手動でチェックボックスリストに追加
            const tagCheckboxes = document.getElementById('tagCheckboxes');
            
            // 既存のメッセージを削除
            if (tagCheckboxes.innerHTML.includes('まだタグが登録されていません')) {
                tagCheckboxes.innerHTML = '';
            }
            
            // 新しいタグのチェックボックスを作成
            const label = document.createElement('label');
            label.style.display = 'flex';
            label.style.alignItems = 'center';
            label.style.gap = '8px';
            label.style.color = 'white';
            label.style.cursor = 'pointer';
            label.style.marginBottom = '5px';
            
            label.innerHTML = `
                <input type="checkbox" value="${newTag}" checked style="width: 16px; height: 16px;">
                <span>${newTag}</span>
            `;
            
            tagCheckboxes.appendChild(label);
            
            // 入力欄をクリア
            newTagInput.value = '';
            
        }
        
        // 検索機能
        function searchProducts() {
            searchQuery = document.getElementById('searchInput').value.toLowerCase().trim();
            filterProducts();
        }
        
        // 検索をクリア
        function clearSearch() {
            document.getElementById('searchInput').value = '';
            searchQuery = '';
            filterProducts();
        }

        // 詳細画面から編集
        function editProductFromDetail(event, productId) {
            event.stopPropagation();
            closeDetailModal(); // 詳細モーダルを閉じる
            editProduct(event, productId);
        }

        // 商品を編集
        function editProduct(event, productId) {
            event.stopPropagation();
            const product = products.find(p => p.id === productId);
            if (product) {
                currentEditingProductId = productId;
                document.getElementById('modalTitle').textContent = '商品を編集';
                document.getElementById('productName').value = product.name || '';
                document.getElementById('productCategory').value = product.category || '';
                document.getElementById('productBoothUrl').value = product.booth_url || '';
                document.getElementById('productThumbnailUrl').value = product.thumbnail_url || '';
                showThumbnailPreview(product.thumbnail_url || '');
                document.getElementById('productFilePath').value = product.file_path || '';
                
                // 複数ファイルがある場合の表示
                
                if (product.file_paths && product.file_paths.includes('|')) {
                    const filePaths = product.file_paths.split('|').filter(path => path.trim());
                    const displayNames = product.display_names ? product.display_names.split('|').filter(name => name.trim()) : null;
                    displayMultipleFiles(filePaths, displayNames);
                } else if (product.file_paths && product.file_paths.trim()) {
                    // file_pathsがあるが区切り文字がない場合（単一ファイル）
                    const filePaths = [product.file_paths.trim()];
                    const displayNames = product.display_names ? [product.display_names.trim()] : null;
                    displayMultipleFiles(filePaths, displayNames);
                } else {
                    // 単一ファイルの場合は複数ファイルエリアを非表示
                    document.getElementById('multipleFilesArea').style.display = 'none';
                }
                
                document.getElementById('productDescription').value = product.description || '';
                
                // 対応アバターのチェックボックスを設定
                const productAvatarIds = product.avatar_ids ? product.avatar_ids.split(',').map(id => id.trim()).filter(id => id) : [];
                const avatarCheckboxes = document.querySelectorAll('#avatarCheckboxes input[type="checkbox"]');
                avatarCheckboxes.forEach(checkbox => {
                    checkbox.checked = productAvatarIds.includes(checkbox.value);
                });
                
                // タグのチェックボックスを設定
                const productTags = product.tags ? product.tags.split(',').map(tag => tag.trim()).filter(tag => tag) : [];
                const tagCheckboxes = document.querySelectorAll('#tagCheckboxes input[type="checkbox"]');
                tagCheckboxes.forEach(checkbox => {
                    checkbox.checked = productTags.includes(checkbox.value);
                });
                
                // 編集用タグセットを初期化
                selectedTagsForEditing.clear();
                productTags.forEach(tag => selectedTagsForEditing.add(tag));
                
                document.getElementById('productModal').style.display = 'block';
                
                // タグ表示を更新
                setTimeout(() => {
                    updateTagsDisplay();
                    // タグ入力フィールドを修正
                    const tagInput = document.getElementById('tagInput');
                    if (tagInput) {
                        tagInput.style.pointerEvents = 'auto';
                        tagInput.style.userSelect = 'text';
                        tagInput.disabled = false;
                        tagInput.readOnly = false;
                        tagInput.value = '';
                        tagInput.focus();
                    }
                }, 50);
            
            // モーダル内のすべての入力フィールドを完全に修正
            setTimeout(() => {
                const modalInputs = document.querySelectorAll('#productModal input[type="text"], #productModal input[type="url"], #productModal textarea');
                
                modalInputs.forEach((field, index) => {
                    // 基本プロパティを設定
                    field.disabled = false;
                    field.readOnly = false;
                    field.tabIndex = 0;
                    
                    // CSSを完全にリセット
                    field.style.cssText = field.style.cssText + '; pointer-events: auto !important; user-select: text !important; cursor: text !important;';
                    
                    // 既存のイベントリスナーをクリア
                    field.onclick = null;
                    field.onmousedown = null;
                    field.onfocus = null;
                    field.onblur = null;
                    
                    // 新しいイベントリスナーを追加
                    field.addEventListener('click', function(e) {
                        e.stopPropagation();
                        this.focus();
                    }, true);
                    
                    field.addEventListener('mousedown', function(e) {
                        e.stopPropagation();
                    }, true);
                });
            }, 100);
                
                // モーダル表示後に最初の入力欄にフォーカス
                setTimeout(() => {
                    const nameInput = document.getElementById('productName');
                    if (nameInput) {
                        nameInput.focus();
                        nameInput.select(); // 編集時は全選択
                    }
                }, 100);
            }
        }

        // 商品を削除
        async function deleteProduct(event, productId) {
            event.stopPropagation();
            if (confirm('この商品を削除しますか？')) {
                try {
                    if (window.electronAPI) {
                        // 削除前に商品情報を保持
                        const deletedProduct = products.find(p => p.id === productId);
                        console.log('削除する商品:', deletedProduct);
                        
                        await window.electronAPI.database.deleteProduct(productId);
                        
                        // アバター本体が削除された場合は、avatars配列とデータベースからも削除
                        if (deletedProduct && deletedProduct.category === 'アバター本体') {
                            console.log('アバター本体を削除しました。avatars配列とデータベースからも削除します。');
                            
                            // avatars配列から該当するアバターを削除
                            const avatarIndex = avatars.findIndex(avatar => 
                                avatar.id === deletedProduct.id || avatar.name === deletedProduct.name
                            );
                            if (avatarIndex !== -1) {
                                console.log('avatars配列からアバターを削除:', avatars[avatarIndex]);
                                const avatarToDelete = avatars[avatarIndex];
                                
                                // データベースからもアバターを削除
                                try {
                                    await window.electronAPI.database.deleteAvatar(avatarToDelete.id);
                                    console.log('データベースからアバターを削除しました:', avatarToDelete.id);
                                } catch (error) {
                                    console.error('データベースからアバター削除エラー:', error);
                                }
                                
                                // ローカル配列からも削除
                                avatars.splice(avatarIndex, 1);
                            }
                        }
                        
                        await loadProducts();
                        
                        // アバター本体が削除された場合はアバター関連のUI要素を更新
                        if (deletedProduct && deletedProduct.category === 'アバター本体') {
                            console.log('アバターUI要素を更新します。');
                            
                            // 少し遅延させてからUI更新
                            setTimeout(() => {
                                // アバターチェックボックスを更新
                                updateAvatarCheckboxesImmediate();
                                
                                // フィルタのアバター選択肢を更新
                                updateAvatarFilterOptions();
                                
                                console.log('アバターUI要素の更新完了');
                            }, 100);
                        }
                    }
                } catch (error) {
                    console.error('Failed to delete product:', error);
                    alert('削除に失敗しました: ' + error);
                }
            }
        }

        // 商品を追加
        function addProduct() {
            currentEditingProductId = null;
            document.getElementById('modalTitle').textContent = '商品を追加';
            document.getElementById('productForm').reset();
            
            // サムネイル プレビューを非表示にする
            document.getElementById('thumbnailPreview').style.display = 'none';
            
            // 複数ファイルエリアを非表示にする
            document.getElementById('multipleFilesArea').style.display = 'none';
            
            // アバターチェックボックスをリセット
            const avatarCheckboxes = document.querySelectorAll('#avatarCheckboxes input[type="checkbox"]');
            avatarCheckboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // タグチェックボックスをリセット
            const tagCheckboxes = document.querySelectorAll('#tagCheckboxes input[type="checkbox"]');
            tagCheckboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // 編集用タグセットを初期化
            selectedTagsForEditing.clear();
            
            document.getElementById('productModal').style.display = 'block';
            
            // タグ表示を更新
            setTimeout(() => {
                updateTagsDisplay();
                // タグ入力フィールドを修正
                const tagInput = document.getElementById('tagInput');
                if (tagInput) {
                    tagInput.style.pointerEvents = 'auto';
                    tagInput.style.userSelect = 'text';
                    tagInput.disabled = false;
                    tagInput.readOnly = false;
                    tagInput.value = '';
                }
            }, 50);
            
            // モーダル内のすべての入力フィールドを完全に修正
            setTimeout(() => {
                const modalInputs = document.querySelectorAll('#productModal input[type="text"], #productModal input[type="url"], #productModal textarea');
                
                modalInputs.forEach((field, index) => {
                    // 基本プロパティを設定
                    field.disabled = false;
                    field.readOnly = false;
                    field.tabIndex = 0;
                    
                    // CSSを完全にリセット
                    field.style.cssText = field.style.cssText + '; pointer-events: auto !important; user-select: text !important; cursor: text !important;';
                    
                    // 既存のイベントリスナーをクリア
                    field.onclick = null;
                    field.onmousedown = null;
                    field.onfocus = null;
                    field.onblur = null;
                    
                    // 新しいイベントリスナーを追加
                    field.addEventListener('click', function(e) {
                        e.stopPropagation();
                        this.focus();
                    }, true);
                    
                    field.addEventListener('mousedown', function(e) {
                        e.stopPropagation();
                    }, true);
                });
            }, 100);
            
            // モーダル表示後に最初の入力欄にフォーカス
            setTimeout(() => {
                const nameInput = document.getElementById('productName');
                if (nameInput) {
                    nameInput.focus();
                }
            }, 100);
        }

        // モーダルを閉じる
        function closeModal() {
            document.getElementById('productModal').style.display = 'none';
            currentEditingProductId = null;
        }

        // フォルダオプション選択ダイアログ（自動統合版）
        function showFolderOptionDialog(unityPackageFiles, folderName) {
            // 常に統合（unify）を返す
            return Promise.resolve('unify');
        }

        // 複数ファイル選択メニューを表示
        function showFileSelectionMenu(event, product) {
            // 既存のメニューがあれば削除
            const existingMenu = document.getElementById('fileSelectionMenu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            // メニューを作成
            const menu = document.createElement('div');
            menu.id = 'fileSelectionMenu';
            menu.style.cssText = `
                position: absolute;
                background-color: #374151;
                border: 1px solid #4b5563;
                border-radius: 6px;
                padding: 8px 0;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
                z-index: 10000;
                min-width: 250px;
                max-width: 500px;
                white-space: nowrap;
            `;
            
            // ファイルパスと表示名を取得
            const filePaths = product.file_paths.split('|').filter(path => path.trim());
            const displayNames = product.display_names ? 
                product.display_names.split('|').filter(name => name.trim()) : 
                filePaths.map(path => path.split(/[/\\]/).pop().replace('.unitypackage', ''));
            
            // メニュー項目を追加
            filePaths.forEach((filePath, index) => {
                const menuItem = document.createElement('div');
                menuItem.style.cssText = `
                    padding: 10px 16px;
                    cursor: pointer;
                    color: white;
                    font-size: 14px;
                    transition: background-color 0.2s;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    white-space: nowrap;
                    overflow: hidden;
                `;
                
                // アイコンと表示名
                const icon = '📦';
                const displayName = displayNames[index] || `ファイル ${index + 1}`;
                
                // 長いファイル名を省略
                const truncatedName = displayName.length > 30 ? 
                    displayName.substring(0, 27) + '...' : 
                    displayName;
                
                menuItem.innerHTML = `
                    <span style="color: #9ca3af; font-size: 14px; flex-shrink: 0;">${icon}</span>
                    <span style="flex: 1; overflow: hidden; text-overflow: ellipsis;" title="${displayName}">${truncatedName}</span>
                `;
                
                // ホバー効果
                menuItem.addEventListener('mouseenter', () => {
                    menuItem.style.backgroundColor = '#4b5563';
                });
                menuItem.addEventListener('mouseleave', () => {
                    menuItem.style.backgroundColor = '';
                });
                
                // クリックでファイルを開く
                menuItem.addEventListener('click', async () => {
                    menu.remove();
                    
                    // ファイル存在確認
                    const fileExists = await window.electronAPI.fs.exists(filePath);
                    
                    if (!fileExists) {
                        alert(`ファイルが見つかりません: ${filePath}`);
                        return;
                    }
                    
                    await window.electronAPI.shell.openFile(filePath);
                });
                
                menu.appendChild(menuItem);
            });
            
            // メニューの位置を設定（ボタンの下に表示）
            const button = event.target;
            const rect = button.getBoundingClientRect();
            menu.style.left = `${rect.left}px`;
            menu.style.top = `${rect.bottom + 5}px`;
            
            // 画面外にはみ出る場合の調整
            document.body.appendChild(menu);
            const menuRect = menu.getBoundingClientRect();
            if (menuRect.right > window.innerWidth) {
                menu.style.left = `${window.innerWidth - menuRect.width - 10}px`;
            }
            if (menuRect.bottom > window.innerHeight) {
                menu.style.top = `${rect.top - menuRect.height - 5}px`;
            }
            
            // クリック外で閉じる
            setTimeout(() => {
                const closeMenu = (e) => {
                    if (!menu.contains(e.target) && e.target !== button) {
                        menu.remove();
                        document.removeEventListener('click', closeMenu);
                    }
                };
                document.addEventListener('click', closeMenu);
            }, 0);
        }
        
        // ファイル選択メニューの表示/非表示
        function toggleFileSelectMenu() {
            const menu = document.getElementById('fileSelectMenu');
            menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
        }
        
        function hideFileSelectMenu() {
            document.getElementById('fileSelectMenu').style.display = 'none';
        }
        
        // メニューの外をクリックしたら閉じる
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('fileSelectMenu');
            const button = e.target.closest('button[onclick*="toggleFileSelectMenu"]');
            if (!button && menu && !menu.contains(e.target)) {
                hideFileSelectMenu();
            }
        });
        
        // 複数ファイル選択（商品追加モーダル用）
        async function selectMultipleFiles() {
            if (window.electronAPI) {
                try {
                    const filePaths = await window.electronAPI.dialog.selectMultipleFiles();
                    if (filePaths && filePaths.length > 0) {
                        
                        // ファイル情報を表示
                        document.getElementById('selectedFileInfo').textContent = `(${filePaths.length}個のファイル)`;
                        
                        if (filePaths.length === 1) {
                            // 単一ファイルの場合
                            document.getElementById('productFilePath').value = filePaths[0];
                            document.getElementById('multipleFilesArea').style.display = 'none';
                        } else {
                            // 複数ファイルの場合
                            displayMultipleFiles(filePaths);
                            document.getElementById('productFilePath').value = filePaths[0]; // 最初のファイルをメインに設定
                        }
                    }
                } catch (error) {
                    console.error('Failed to select files:', error);
                    alert('ファイル選択に失敗しました: ' + error);
                }
            }
        }
        
        // ファイルまたはフォルダ選択（統合版）
        async function selectFilesOrFolders() {
            if (window.electronAPI && window.electronAPI.dialog.selectFilesOrFolders) {
                try {
                    const result = await window.electronAPI.dialog.selectFilesOrFolders();
                    
                    if (!result || !result.type) {
                        return;
                    }
                    
                    if (result.type === 'folder') {
                        // フォルダが選択された場合
                        if (result.files && result.files.length > 0) {
                            
                            // 複数ファイルの表示
                            displayMultipleFiles(result.files);
                            
                            // 最初のファイルをメインとして設定
                            document.getElementById('productFilePath').value = result.files[0];
                            
                            // フォルダ名から商品名を推測
                            if (!document.getElementById('productName').value) {
                                document.getElementById('productName').value = result.folderName;
                            }
                        } else {
                            alert('選択されたフォルダに.unitypackageファイルが見つかりませんでした。');
                        }
                    } else if (result.type === 'files') {
                        // ファイルが選択された場合
                        if (result.files && result.files.length > 0) {
                            if (result.files.length === 1) {
                                document.getElementById('productFilePath').value = result.files[0];
                                document.getElementById('multipleFilesArea').style.display = 'none';
                            } else {
                                displayMultipleFiles(result.files);
                                document.getElementById('productFilePath').value = result.files[0];
                            }
                        }
                    }
                } catch (error) {
                    console.error('Failed to select files or folders:', error);
                    alert('ファイル/フォルダ選択に失敗しました: ' + error);
                }
            }
        }
        
        // ファイル選択
        async function selectFile() {
            if (window.electronAPI) {
                try {
                    const filePaths = await window.electronAPI.dialog.selectMultipleFiles();
                    if (filePaths && filePaths.length > 0) {
                        if (filePaths.length === 1) {
                            document.getElementById('productFilePath').value = filePaths[0];
                            document.getElementById('multipleFilesArea').style.display = 'none';
                        } else {
                            displayMultipleFiles(filePaths);
                            document.getElementById('productFilePath').value = filePaths[0];
                        }
                    }
                } catch (error) {
                    console.error('Failed to select file:', error);
                    alert('ファイル選択に失敗しました: ' + error);
                }
            }
        }

        // フォルダ選択と複数ファイル処理
        async function selectFolder() {
            if (window.electronAPI) {
                try {
                    const result = await window.electronAPI.dialog.selectDirectory();
                    if (result && result.folderPath) {
                        if (result.files && result.files.length > 0) {
                            
                            // フォルダ情報を表示
                            document.getElementById('selectedFolderInfo').textContent = `(フォルダ: ${result.folderName})`;
                            
                            // 複数ファイルの表示
                            displayMultipleFiles(result.files);
                            
                            // 最初のファイルをメインとして設定
                            document.getElementById('productFilePath').value = result.files[0];
                            
                            // フォルダ名から商品名を推測
                            if (!document.getElementById('productName').value) {
                                document.getElementById('productName').value = result.folderName;
                            }
                            
                            // 詳細なメッセージを表示
                            const fileNames = result.files.map(f => f.split(/[/\\]/).pop()).join('\n・');
                            alert(`フォルダ "${result.folderName}" から${result.files.length}個の.unitypackageファイルが見つかりました。\n\n見つかったファイル:\n・${fileNames}\n\n商品情報を入力してください。`);
                        } else {
                            alert('選択したフォルダに.unitypackageファイルが見つかりません');
                        }
                        
                        if (result.error) {
                            console.error('フォルダ読み込みエラー:', result.error);
                        }
                    }
                } catch (error) {
                    console.error('Failed to select folder:', error);
                    alert('フォルダ選択に失敗しました: ' + error);
                }
            }
        }

        // 複数ファイルを表示する関数
        function displayMultipleFiles(filePaths, existingDisplayNames = null) {
            const multipleFilesArea = document.getElementById('multipleFilesArea');
            const filesList = document.getElementById('filesList');
            
            multipleFilesArea.style.display = 'block';
            filesList.innerHTML = '';
            
            // ファイル情報を保存する配列
            window.multipleFileData = filePaths.map((filePath, index) => {
                const originalName = filePath.split(/[/\\]/).pop();
                return {
                    path: filePath,
                    originalName: originalName,
                    displayName: existingDisplayNames && existingDisplayNames[index] ? existingDisplayNames[index] : originalName
                };
            });
            
            filePaths.forEach((filePath, index) => {
                const fileName = filePath.split(/[/\\]/).pop();
                const fileItem = document.createElement('div');
                fileItem.id = `fileItem_${index}`;
                fileItem.style.cssText = `
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    padding: 10px;
                    margin-bottom: 8px;
                    border-radius: 4px;
                    background-color: #4b5563;
                    transition: all 0.2s;
                `;
                
                // ファイルアイコン
                const fileIcon = document.createElement('span');
                fileIcon.textContent = '📦';
                fileIcon.style.cssText = 'font-size: 16px; flex-shrink: 0;';
                
                const contentDiv = document.createElement('div');
                contentDiv.style.cssText = 'flex: 1; display: flex; flex-direction: column; gap: 4px; min-width: 0;';
                
                const textInput = document.createElement('input');
                textInput.type = 'text';
                textInput.value = window.multipleFileData[index].displayName;
                textInput.id = `fileName_${index}`;
                textInput.dataset.index = index;
                textInput.onchange = () => updateFileName(index, textInput.value);
                // シンプルなフォーカス処理のみ
                textInput.addEventListener('click', () => textInput.focus());
                textInput.style.pointerEvents = 'auto';
                textInput.style.userSelect = 'text';
                textInput.onfocus = () => {
                    textInput.style.borderColor = '#10b981'; // フォーカス時に枠線の色を変更
                    textInput.style.outline = 'none'; // ブラウザのデフォルトアウトラインを無効化
                };
                textInput.onblur = () => {
                    textInput.style.borderColor = '#6b7280'; // フォーカスが外れたら元に戻す
                };
                textInput.style.cssText = 'flex: 1; padding: 4px 8px; background-color: #374151; color: white; border: 1px solid #6b7280; border-radius: 3px; font-size: 12px; transition: border-color 0.2s; caret-color: white; pointer-events: auto; user-select: text; cursor: text;';
                textInput.placeholder = '表示名を入力';
                
                contentDiv.appendChild(textInput);
                
                const originalNameSpan = document.createElement('span');
                originalNameSpan.style.cssText = 'font-size: 11px; color: #9ca3af; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;';
                originalNameSpan.title = fileName;
                originalNameSpan.textContent = `元のファイル名: ${fileName}`;
                
                contentDiv.appendChild(originalNameSpan);
                
                fileItem.appendChild(fileIcon);
                fileItem.appendChild(contentDiv);
                
                // ファイルアイテムをクリックしたときの処理（削除）
                
                // タブインデックスを設定してキーボードナビゲーションを改善
                textInput.tabIndex = 100 + index;
                
                fileItem.onmouseover = () => fileItem.style.backgroundColor = '#6b7280';
                fileItem.onmouseout = () => fileItem.style.backgroundColor = '#4b5563';
                
                filesList.appendChild(fileItem);
            });
            
            // 最初のファイルを設定（メインという概念は削除）
            if (filePaths.length > 0) {
                document.getElementById('productFilePath').value = filePaths[0];
            }
        }
        
        // ファイル名更新時の処理
        function updateFileName(index, newName) {
            if (window.multipleFileData && window.multipleFileData[index]) {
                window.multipleFileData[index].displayName = newName;
            }
        }
        
        function forceTextInputFocus(index) {
            const textInput = document.getElementById(`fileName_${index}`);
            if (textInput) {
                textInput.disabled = false;
                textInput.readOnly = false;
                textInput.style.pointerEvents = 'auto';
                setTimeout(() => {
                    textInput.focus();
                    textInput.select();
                }, 50);
            }
        }

        // サムネイル取得
        async function fetchThumbnail(isAutomatic = false) {
            const boothUrl = document.getElementById('productBoothUrl').value;
            if (!boothUrl) {
                if (!isAutomatic) {
                    // alertの代わりにBooth URLフィールドにフォーカス
                    const boothUrlField = document.getElementById('productBoothUrl');
                    if (boothUrlField) {
                        boothUrlField.style.borderColor = '#ef4444';
                        boothUrlField.placeholder = 'Booth URLを入力してください';
                        boothUrlField.focus();
                        setTimeout(() => {
                            boothUrlField.style.borderColor = '';
                            boothUrlField.placeholder = 'https://booth.pm/...';
                        }, 2000);
                    }
                }
                return;
            }

            if (!boothUrl.includes('booth.pm')) {
                if (!isAutomatic) {
                    // alertの代わりにフィールドをハイライト
                    const boothUrlField = document.getElementById('productBoothUrl');
                    if (boothUrlField) {
                        boothUrlField.style.borderColor = '#ef4444';
                        boothUrlField.select();
                        setTimeout(() => {
                            boothUrlField.style.borderColor = '';
                        }, 2000);
                    }
                }
                return;
            }

            // ボタンを直接取得（手動実行時）
            let button = null;
            let originalText = '';
            if (!isAutomatic) {
                const thumbnailButtons = document.querySelectorAll('button');
                for (let btn of thumbnailButtons) {
                    if (btn.textContent.includes('サムネイル取得')) {
                        button = btn;
                        originalText = btn.textContent;
                        btn.disabled = true;
                        btn.textContent = '取得中...';
                        break;
                    }
                }
            }

            try {
                if (window.electronAPI && window.electronAPI.fetch && window.electronAPI.fetch.thumbnail) {
                    const result = await window.electronAPI.fetch.thumbnail(boothUrl);
                    if (result && result.success && result.thumbnailUrl) {
                        const thumbnailUrlField = document.getElementById('productThumbnailUrl');
                        if (thumbnailUrlField) {
                            thumbnailUrlField.value = result.thumbnailUrl;
                        }
                        try {
                            showThumbnailPreview(result.thumbnailUrl);
                        } catch (previewError) {
                            console.error('Thumbnail preview error:', previewError);
                        }
                        // alertの代わりにボタンテキストで成功を表示
                        if (!isAutomatic && button) {
                            button.textContent = '✓ 取得成功';
                            button.style.backgroundColor = '#10b981';
                            setTimeout(() => {
                                button.textContent = originalText;
                                button.style.backgroundColor = '';
                            }, 2000);
                        }
                    } else {
                        // alertの代わりにボタンテキストで失敗を表示
                        if (!isAutomatic && button) {
                            button.textContent = '✗ 取得失敗';
                            button.style.backgroundColor = '#ef4444';
                            setTimeout(() => {
                                button.textContent = originalText;
                                button.style.backgroundColor = '';
                            }, 2000);
                        }
                    }
                } else {
                    if (!isAutomatic && button) {
                        button.textContent = '✗ 機能利用不可';
                        button.style.backgroundColor = '#ef4444';
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.style.backgroundColor = '';
                        }, 2000);
                    }
                }
            } catch (error) {
                console.error('Failed to fetch thumbnail:', error);
                // alertの代わりにボタンテキストでエラーを表示
                if (!isAutomatic && button) {
                    button.textContent = '✗ エラー';
                    button.style.backgroundColor = '#ef4444';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = '';
                    }, 2000);
                }
            } finally {
                // ボタンの状態のみをリセット（他の要素には触らない）
                if (button) {
                    button.disabled = false;
                    button.textContent = originalText;
                }
            }
        }

        // サムネイル プレビューを表示
        function showThumbnailPreview(thumbnailUrl) {
            try {
                const thumbnailPreview = document.getElementById('thumbnailPreview');
                const thumbnailImage = document.getElementById('thumbnailImage');
                
                if (!thumbnailPreview || !thumbnailImage) {
                    console.warn('Thumbnail preview elements not found');
                    return;
                }
                
                if (thumbnailUrl && thumbnailUrl.trim() !== '') {
                    thumbnailImage.src = thumbnailUrl;
                    thumbnailImage.onerror = function() {
                        // 画像の読み込みに失敗した場合は非表示にする
                        thumbnailPreview.style.display = 'none';
                    };
                    thumbnailImage.onload = function() {
                        // 画像の読み込みが成功した場合に表示
                        thumbnailPreview.style.display = 'block';
                    };
                } else {
                    thumbnailPreview.style.display = 'none';
                }
            } catch (error) {
                console.error('Error in showThumbnailPreview:', error);
            }
        }

        // フォーム送信
        document.getElementById('productForm').addEventListener('submit', async function(event) {
            event.preventDefault();
            
            const formData = new FormData(event.target);
            
            // 選択されたアバターIDを取得
            const selectedAvatarIds = [];
            const avatarCheckboxes = document.querySelectorAll('#avatarCheckboxes input[type="checkbox"]:checked');
            avatarCheckboxes.forEach(checkbox => {
                selectedAvatarIds.push(checkbox.value);
            });
            
            // 選択されたタグを取得
            const selectedTags = [];
            const tagCheckboxes = document.querySelectorAll('#tagCheckboxes input[type="checkbox"]:checked');
            tagCheckboxes.forEach(checkbox => {
                selectedTags.push(checkbox.value);
            });
            
            // 複数ファイルの表示名を保存
            let displayNames = '';
            let filePaths = '';
            if (window.multipleFileData && window.multipleFileData.length > 0) {
                displayNames = window.multipleFileData.map(f => f.displayName).join('|');
                filePaths = window.multipleFileData.map(f => f.path).join('|');
            }
            
            const productData = {
                name: formData.get('name'),
                category: formData.get('category'),
                booth_url: formData.get('booth_url'),
                thumbnail_url: formData.get('thumbnail_url'),
                file_path: formData.get('file_path'),
                description: formData.get('description'),
                author: '',
                avatar_ids: selectedAvatarIds.join(','),
                tags: selectedTags.join(','),
                file_paths: filePaths,
                display_names: displayNames
            };

            try {
                if (window.electronAPI) {
                    if (currentEditingProductId) {
                        // 編集
                        await window.electronAPI.database.updateProduct(currentEditingProductId, productData);
                        
                        // 学習機能：Booth URLが設定されている場合、ファイル名とのマッピングを学習（編集時）
                        if (productData.booth_url && productData.booth_url.includes('booth.pm') && productData.booth_url.includes('/items/') && productData.file_path) {
                            try {
                                const filename = productData.file_path.split(/[/\\]/).pop();
                                const learningResult = await window.electronAPI.booth.learnMapping(filename, productData.booth_url);
                            } catch (learningError) {
                                console.error('商品編集時の学習エラー:', learningError);
                            }
                        } else {
                        }
                    } else {
                        // 新規追加
                        await window.electronAPI.database.addProduct(productData);
                        
                        // 学習機能：Booth URLが設定されている場合、ファイル名とのマッピングを学習
                        if (productData.booth_url && productData.booth_url.includes('booth.pm') && productData.booth_url.includes('/items/') && productData.file_path) {
                            try {
                                const filename = productData.file_path.split(/[/\\]/).pop();
                                const learningResult = await window.electronAPI.booth.learnMapping(filename, productData.booth_url);
                            } catch (learningError) {
                                console.error('商品追加時の学習エラー:', learningError);
                            }
                        } else {
                        }
                        
                        // 設定確認後、メインファイルをアーカイブに移動
                        const settings = await window.electronAPI.settings.get();
                        if (settings.autoArchive === true && productData.file_path && productData.file_path.trim()) {
                            const archiveResult = await window.electronAPI.fs.moveToArchive(productData.file_path);
                            if (archiveResult.success) {
                                
                                // データベース内のファイルパスを更新
                                const products = await window.electronAPI.database.getProducts();
                                const addedProduct = products[products.length - 1]; // 最後に追加された商品
                                if (addedProduct) {
                                    let updatedData = { ...addedProduct, file_path: archiveResult.newPath };
                                    
                                    // 複数ファイルもアーカイブに移動
                                    if (window.multipleFileData && window.multipleFileData.length > 0) {
                                        const archivedFiles = [];
                                        for (const fileData of window.multipleFileData) {
                                            const result = await window.electronAPI.fs.moveToArchive(fileData.path);
                                            if (result.success) {
                                                archivedFiles.push({ ...fileData, path: result.newPath });
                                            } else {
                                                archivedFiles.push(fileData); // 移動失敗時は元のパスを保持
                                                console.warn('複数ファイルのアーカイブ移動に失敗:', result.error);
                                            }
                                        }
                                        
                                        updatedData.file_paths = archivedFiles.map(f => f.path).join('|');
                                        updatedData.display_names = archivedFiles.map(f => f.displayName).join('|');
                                    }
                                    
                                    await window.electronAPI.database.updateProduct(addedProduct.id, updatedData);
                                }
                            } else {
                                console.warn('メインファイルのアーカイブ移動に失敗:', archiveResult.error);
                            }
                        } else {
                        }
                    }
                    await loadProducts();
                    closeModal();
                }
            } catch (error) {
                console.error('Failed to save product:', error);
                alert('保存に失敗しました: ' + error);
            }
        });

        // モーダル外クリックで閉じる
        document.getElementById('productModal').addEventListener('click', function(event) {
            if (event.target === this) {
                closeModal();
            }
        });

        // 商品詳細を開く
        function openProductDetail(productOrId) {
            // IDの場合は商品オブジェクトを取得
            const product = typeof productOrId === 'number' ? 
                products.find(p => p.id === productOrId) : productOrId;
            
            if (!product) {
                console.error('Product not found:', productOrId);
                return;
            }
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            
            const modalContent = document.createElement('div');
            modalContent.className = 'modal-content';
            modalContent.style.width = '600px';
            modalContent.style.maxWidth = '90vw';
            
            // 対応アバター名を取得
            let avatarNames = '';
            if (product.avatar_ids) {
                const avatarIds = product.avatar_ids.split(',').map(id => id.trim()).filter(id => id);
                const matchedAvatars = avatars.filter(avatar => avatarIds.includes(avatar.id.toString()));
                avatarNames = matchedAvatars.map(avatar => avatar.name).join(', ');
            }
            
            modalContent.innerHTML = `
                <h2>${product.name}</h2>
                <div style="display: flex; gap: 20px; margin: 20px 0;">
                    <div style="flex-shrink: 0;">
                        ${product.thumbnail_url ? 
                            `<img src="${product.thumbnail_url}" alt="${product.name}" style="width: 150px; height: 150px; object-fit: cover; border-radius: 6px;" draggable="false">` : 
                            '<div style="width: 150px; height: 150px; background-color: #4b5563; display: flex; align-items: center; justify-content: center; border-radius: 6px; color: #9ca3af;">画像なし</div>'
                        }
                    </div>
                    <div style="flex: 1;">
                        <p><strong>カテゴリ:</strong> ${product.category || 'なし'}</p>
                        ${avatarNames ? `<p><strong>対応アバター:</strong> ${avatarNames}</p>` : ''}
                        ${product.tags && product.tags.trim() !== '' ? `<p><strong>タグ:</strong> ${product.tags.split(',').map(tag => `<span style="background-color: #4b5563; padding: 2px 6px; border-radius: 4px; margin-right: 4px; font-size: 12px;">${tag.trim()}</span>`).join('')}</p>` : ''}
                        ${product.booth_url ? `<p><strong>Booth URL:</strong> <a href="${product.booth_url}" target="_blank" style="color: #60a5fa;">${product.booth_url}</a></p>` : ''}
                        ${product.file_path ? `<p><strong>ファイルパス:</strong> ${product.file_path}</p>` : ''}
                        ${product.description ? `<p><strong>説明:</strong><br>${product.description}</p>` : ''}
                    </div>
                </div>
                <div class="form-buttons">
                    ${product.file_path ? `<button onclick="openFile(event, '${product.file_path.replace(/\\/g, '\\\\')}', ${product.id})" class="form-btn form-btn-submit">Unityで開く${product.file_paths && product.file_paths.includes('|') ? ' ▼' : ''}</button>` : ''}
                    <button onclick="editProductFromDetail(event, ${product.id})" class="form-btn form-btn-submit">編集</button>
                    <button onclick="closeDetailModal()" class="form-btn form-btn-cancel">閉じる</button>
                </div>
            `;
            
            modal.appendChild(modalContent);
            
            // モーダル外クリックで閉じる
            modal.addEventListener('click', function(event) {
                if (event.target === modal) {
                    closeDetailModal();
                }
            });
            
            document.body.appendChild(modal);
            window.currentDetailModal = modal;
        }
        
        // 詳細モーダルを閉じる
        function closeDetailModal() {
            if (window.currentDetailModal) {
                document.body.removeChild(window.currentDetailModal);
                window.currentDetailModal = null;
            }
        }


        // ESCキーでモーダルを閉じる
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                // 商品追加・編集モーダル
                const productModal = document.getElementById('productModal');
                if (productModal && productModal.style.display === 'block') {
                    closeModal();
                }
                
                // 商品詳細モーダル
                if (window.currentDetailModal) {
                    closeDetailModal();
                }
            }
        });

        // ドラッグ&ドロップ機能
        function initDragAndDrop() {
            const dropZone = document.getElementById('dropZone');
            const dragOverlay = document.getElementById('dragOverlay');
            const body = document.body;
            let dragCounter = 0;
            
            // ファイルがドラッグされた時にオーバーレイとドロップゾーンを表示
            body.addEventListener('dragenter', function(e) {
                e.preventDefault();
                dragCounter++;
                // ファイルがドラッグされている場合は常に表示（ファイル形式の判定は後で行う）
                if (e.dataTransfer && (e.dataTransfer.files.length > 0 || e.dataTransfer.types.includes('Files') || e.dataTransfer.types.includes('application/x-moz-file'))) {
                    dropZone.style.display = 'block';
                    dragOverlay.style.display = 'block';
                    // ドロップゾーンにパルス効果を追加
                    dropZone.style.animation = 'pulse 2s infinite';
                }
            });
            
            body.addEventListener('dragover', function(e) {
                e.preventDefault();
            });
            
            body.addEventListener('dragleave', function(e) {
                e.preventDefault();
                dragCounter--;
                // すべてのドラッグが終了した場合のみ非表示
                if (dragCounter === 0) {
                    dropZone.style.display = 'none';
                    dragOverlay.style.display = 'none';
                    dropZone.style.animation = '';
                }
            });
            
            body.addEventListener('drop', function(e) {
                e.preventDefault();
                dragCounter = 0;
                dropZone.style.display = 'none';
                dragOverlay.style.display = 'none';
                dropZone.style.animation = '';
                
                const files = Array.from(e.dataTransfer.files);
                
                // 混在ドロップ処理: フォルダ内ファイルと単体ファイルを分類
                processedMixedDrop(files, e.dataTransfer.items);
            });
            
            // ドロップゾーンのスタイル変更
            dropZone.addEventListener('dragover', function(e) {
                e.preventDefault();
                this.style.borderColor = '#16a34a';
                this.style.backgroundColor = '#065f46';
                this.style.borderWidth = '3px';
                this.style.transform = 'scale(1.02)';
            });
            
            dropZone.addEventListener('dragleave', function(e) {
                e.preventDefault();
                this.style.borderColor = '#4b5563';
                this.style.backgroundColor = '#374151';
                this.style.borderWidth = '2px';
                this.style.transform = 'scale(1)';
            });
            
            dropZone.addEventListener('drop', function(e) {
                this.style.borderColor = '#4b5563';
                this.style.backgroundColor = '#374151';
                this.style.borderWidth = '2px';
                this.style.transform = 'scale(1)';
            });
        }
        
        // .unitypackageファイルが含まれているかチェック
        function hasUnityPackageFiles(dataTransfer) {
            if (dataTransfer.items) {
                for (let item of dataTransfer.items) {
                    if (item.kind === 'file') {
                        const file = item.getAsFile();
                        if (file && file.name.toLowerCase().endsWith('.unitypackage')) {
                            return true;
                        }
                        // フォルダの場合もtrueを返す（後でフォルダ内をチェック）
                        if (file && file.type === '') {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        
        // 複数ファイルを1つの商品としてグループ処理
        async function processDroppedFilesAsGroup(files) {
            
            const firstFile = files[0];
            const { normalizedName } = extractSearchKeywords(firstFile.name);
            
            // ファイル名から商品名を推測（各単語の先頭を大文字に）
            const productName = normalizedName
                .replace(/\b\w/g, l => l.toUpperCase());
            
            // 自動でカテゴリを推測
            let category = 'その他';
            const lowerName = normalizedName.toLowerCase();
            if (lowerName.includes('avatar') || lowerName.includes('アバター')) {
                category = 'アバター本体';
            } else if (lowerName.includes('costume') || lowerName.includes('cloth') || lowerName.includes('衣装')) {
                category = '衣装';
            } else if (lowerName.includes('accessory') || lowerName.includes('アクセサリー')) {
                category = 'アクセサリー';
            } else if (lowerName.includes('hair') || lowerName.includes('髪')) {
                category = '髪型';
            } else if (lowerName.includes('tool') || lowerName.includes('ツール') || lowerName.includes('editor') || lowerName.includes('utility')) {
                category = 'ツール';
            } else if (lowerName.includes('pose') || lowerName.includes('ポーズ') || lowerName.includes('motion') || lowerName.includes('anim')) {
                category = 'ポーズ';
            } else if (lowerName.includes('world') || lowerName.includes('ワールド') || lowerName.includes('scene')) {
                category = 'ワールド';
            }
            
            // 全ファイルパスを保存用に準備
            const allFilePaths = files.map(file => file.path || file.name);
            
            const productData = {
                name: productName,
                category: category,
                booth_url: '',
                thumbnail_url: '',
                file_path: allFilePaths[0], // メインファイルパス
                file_paths: allFilePaths.join('|'), // 全ファイルパスを区切り文字で保存
                description: `複数ファイル: ${files.map(f => f.name).join(', ')}`,
                author: '',
                avatar_ids: '',
                tags: ''
            };
            
            try {
                if (window.electronAPI) {
                    await window.electronAPI.database.addProduct(productData);
                    
                    // 学習データから自動でBooth URL取得とサムネイル設定
                    const firstFileName = files[0].name;
                    try {
                        const boothSearchResult = await window.electronAPI.booth.searchByFilename(firstFileName);
                        if (boothSearchResult.success && boothSearchResult.results && boothSearchResult.results.length > 0) {
                            const firstResult = boothSearchResult.results[0];
                            if (firstResult.url && firstResult.url.includes('booth.pm') && firstResult.url.includes('/items/')) {
                                // Booth URLを更新
                                productData.booth_url = firstResult.url;
                                
                                if (boothSearchResult.highConfidence !== false) {
                                    try {
                                        const thumbnailResult = await window.electronAPI.fetch.thumbnail(firstResult.url);
                                        if (thumbnailResult.success && thumbnailResult.thumbnailUrl) {
                                            productData.thumbnail_url = thumbnailResult.thumbnailUrl;
                                        }
                                    } catch (thumbnailError) {
                                        // サムネイル取得失敗は致命的ではない
                                    }
                                } else {
                                    // 低信頼度の場合はサムネイルを取得せず警告表示
                                    console.warn('信頼度が低いマッチのためサムネイルを取得しませんでした:', firstResult.title);
                                }
                                
                                // 更新された商品データを保存
                                const products = await window.electronAPI.database.getProducts();
                                const addedProduct = products[products.length - 1];
                                if (addedProduct) {
                                    await window.electronAPI.database.updateProduct(addedProduct.id, {
                                        ...addedProduct,
                                        booth_url: productData.booth_url,
                                        thumbnail_url: productData.thumbnail_url
                                    });
                                }
                            }
                        }
                    } catch (boothError) {
                        // Booth検索失敗は致命的ではない
                    }
                    
                    loadProducts();
                }
            } catch (error) {
                console.error('グループ商品追加エラー:', error);
            }
        }
        
        // フォルダからunitypackageファイルを再帰的に抽出する関数
        async function extractFilesFromFolder(folderEntry) {
            return new Promise((resolve, reject) => {
                const files = [];
                let pendingOperations = 0;
                let totalEntries = 0;
                
                function processEntry(entry, depth = 0) {
                    if (entry.isFile && entry.name.toLowerCase().endsWith('.unitypackage')) {
                        pendingOperations++;
                        entry.file(file => {
                            const filePath = file.path || `${entry.fullPath}`;
                            files.push(filePath);
                            pendingOperations--;
                            
                            if (pendingOperations === 0) {
                                resolve(files);
                            }
                        }, error => {
                            console.error('ファイル取得エラー:', entry.name, error);
                            pendingOperations--;
                            if (pendingOperations === 0) {
                                resolve(files);
                            }
                        });
                    } else if (entry.isDirectory && depth < 3) { // 最大3階層まで
                        pendingOperations++;
                        const subReader = entry.createReader();
                        
                        function readSubEntries() {
                            subReader.readEntries(subEntries => {
                                if (subEntries.length > 0) {
                                    subEntries.forEach(subEntry => {
                                        processEntry(subEntry, depth + 1);
                                    });
                                    readSubEntries(); // 続きを読む
                                } else {
                                    pendingOperations--;
                                    if (pendingOperations === 0) {
                                        resolve(files);
                                    }
                                }
                            }, error => {
                                console.error('サブディレクトリ読み込みエラー:', entry.name, error);
                                pendingOperations--;
                                if (pendingOperations === 0) {
                                    resolve(files);
                                }
                            });
                        }
                        readSubEntries();
                    }
                }
                
                const dirReader = folderEntry.createReader();
                function readEntries() {
                    dirReader.readEntries(entries => {
                        totalEntries += entries.length;
                        
                        if (entries.length > 0) {
                            entries.forEach(entry => {
                                processEntry(entry, 0);
                            });
                            readEntries(); // 続きを読む
                        } else {
                            if (pendingOperations === 0) {
                                resolve(files);
                            }
                        }
                    }, error => {
                        console.error('ディレクトリ読み込みエラー:', folderEntry.name, error);
                        reject(error);
                    });
                }
                
                readEntries();
            });
        }
        
        // ZIPファイル処理関数
        async function processZipFile(zipFilePath) {
            try {
                // ZIPファイル名を取得
                const zipFileName = zipFilePath.split('\\').pop().split('/').pop();
                
                // ZIPファイル内のUnitypackageファイルを検索
                const zipResult = await window.electronAPI.zip.listUnitypackages(zipFilePath);
                
                console.log('ZIPファイル解析結果:', zipResult);
                
                if (!zipResult.success) {
                    alert(`ZIPファイルの解析に失敗しました: ${zipResult.error}`);
                    return;
                }
                
                if (!zipResult.files || zipResult.files.length === 0) {
                    alert(`${zipFileName} にはUnitypackageファイルが見つかりませんでした。`);
                    return;
                }
                
                // Unitypackageファイルが1つの場合は自動で抽出・登録
                if (zipResult.files.length === 1) {
                    const unityFile = zipResult.files[0];
                    console.log('単一ファイル処理:', unityFile);
                    if (!unityFile) {
                        console.error('unityFileがundefinedです');
                        alert('ZIPファイル内のUnitypackageファイル情報の取得に失敗しました');
                        return;
                    }
                    await extractAndRegisterUnitypackage(zipFilePath, unityFile, zipFileName);
                    return;
                }
                
                // 複数のUnitypackageファイルがある場合の処理
                // 設定から自動登録モードを確認（強制的にtrue）
                let autoRegisterAll = true; // 常に自動登録
                
                // 全てのUnitypackageを自動で抽出・登録（フォルダグループ化対応）
                await autoExtractAndRegisterAllFiles(zipFilePath, zipResult.files, zipFileName);
                
            } catch (error) {
                console.error('ZIPファイル処理エラー:', error);
                alert(`ZIPファイル処理エラー: ${error.message}`);
            }
        }
        
        // ファイルをフォルダ別にグループ化（階層構造を考慮）
        function groupFilesByFolder(files) {
            const groups = {};
            
            for (const file of files) {
                // ファイルのパス情報を取得（file.path または file.fullPath または file.name）
                const filePath = file.path || file.fullPath || file.name || '';
                
                if (!filePath) {
                    console.warn('ファイルパスが取得できません:', file);
                    continue;
                }
                
                // パス区切り文字を正規化
                const normalizedPath = filePath.replace(/\\/g, '/');
                const pathParts = normalizedPath.split('/');
                
                // ルートフォルダ（最上位フォルダ）を基準にグループ化
                let groupKey;
                if (pathParts.length > 1) {
                    // フォルダ構造がある場合は最上位フォルダを使用
                    groupKey = pathParts[0];
                } else {
                    // フォルダ構造がない場合は'root'
                    groupKey = 'root';
                }
                
                if (!groups[groupKey]) {
                    groups[groupKey] = [];
                }
                groups[groupKey].push(file);
            }
            
            return groups;
        }
        
        // 同じフォルダのUnitypackageファイルを結合登録
        async function extractAndRegisterGroupedUnitypackages(zipFilePath, unityFiles, zipFileName, folderPath) {
            // 並行処理数チェック
            if (activeZipProcessingCount >= MAX_CONCURRENT_ZIP_PROCESSING) {
                console.warn(`最大並行処理数(${MAX_CONCURRENT_ZIP_PROCESSING})に達したため`, folderPath, 'を待機します');
                while (activeZipProcessingCount >= MAX_CONCURRENT_ZIP_PROCESSING) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            activeZipProcessingCount++;
            
            
            try {
                // 設定からアーカイブディレクトリを取得
                const archiveDir = await window.electronAPI.fs.getArchiveDir();
                
                // 各ファイルを抽出
                const extractedFilePaths = [];
                const displayNames = [];
                
                for (const unityFile of unityFiles) {
                    const unitypackageEntry = {
                        path: unityFile.fullPath || unityFile.fileName,
                        name: unityFile.fileName || unityFile.name
                    };
                    
                    const extractResult = await window.electronAPI.zip.extractUnitypackage(
                        zipFilePath, 
                        unitypackageEntry, 
                        archiveDir
                    );
                    
                    if (extractResult.success) {
                        extractedFilePaths.push(extractResult.extractedPath);
                        displayNames.push(unityFile.fileName || unityFile.name || 'Unknown');
                    } else {
                        console.error('グループ内ファイル抽出失敗:', extractResult.error);
                        alert(`グループ内ファイル抽出に失敗: ${unityFile.fileName || unityFile.name || 'Unknown'}\nエラー: ${extractResult.error}`);
                    }
                }
                
                if (extractedFilePaths.length === 0) {
                    console.error('グループ内で抽出できたファイルがありません');
                    return;
                }
                
                // フォルダ名から商品名を作成
                const folderName = folderPath === 'root' ? zipFileName.replace(/\.zip$/i, '') : folderPath;
                
                // グループ化された商品データを作成
                const productData = {
                    name: folderName,
                    category: '',
                    tags: '',
                    description: `${folderName}`,
                    booth_url: '',
                    thumbnail_url: '',
                    file_path: extractedFilePaths[0], // メインファイル
                    file_paths: extractedFilePaths.join('|'), // 全ファイルパス（区切り文字|）
                    display_names: displayNames.join('|'), // 表示名（区切り文字|）
                    author: '',
                    avatar_ids: ''
                };
                
                // 購入履歴から商品情報を取得（優先）
                const purchaseHistoryData = JSON.parse(localStorage.getItem('boothPurchaseHistory') || '[]');
                let foundFromPurchaseHistory = false;
                
                if (purchaseHistoryData.length > 0) {
                    // ZIPファイル名で候補検索
                    const zipCandidates = findCandidatesForFile(zipFileName);
                    // 最初のUnitypackageファイル名でも検索  
                    const firstUnityFile = unityFiles && unityFiles[0] ? unityFiles[0] : null;
                    const unityCandidates = firstUnityFile ? findCandidatesForFile(firstUnityFile.fileName || firstUnityFile.name || '') : [];
                    
                    // 重複除去して候補をマージ
                    const allCandidates = [...zipCandidates];
                    unityCandidates.forEach(candidate => {
                        if (!allCandidates.some(existing => existing.boothUrl === candidate.boothUrl)) {
                            allCandidates.push(candidate);
                        }
                    });
                    
                    if (allCandidates.length > 0) {
                        const topCandidate = allCandidates[0];
                        const matchPercentage = Math.round(topCandidate.matchScore * 100);
                        
                        // 70%以上の場合のみ購入履歴データを適用
                        if (topCandidate.matchScore >= 0.7) {
                            // 購入履歴データで商品情報を更新
                            productData.name = topCandidate.title;
                            productData.booth_url = topCandidate.boothUrl;
                            productData.thumbnail_url = topCandidate.thumbnailUrl;
                            productData.author = topCandidate.author;
                            productData.description = `${folderName} (購入履歴マッチ ${matchPercentage}%: ${topCandidate.bestMatch})`;
                            
                            foundFromPurchaseHistory = true;
                        }
                    }
                }
                
                // 購入履歴で見つからない場合は従来の学習データ検索
                if (!foundFromPurchaseHistory) {
                    try {
                        // まずZIPファイル名で検索
                        let boothSearchResult = await window.electronAPI.booth.searchByFilename(zipFileName);
                        
                        // ZIPファイル名で見つからない場合は、最初のUnitypackageファイル名で検索
                        if (!boothSearchResult.success || !boothSearchResult.results || boothSearchResult.results.length === 0 || 
                            !boothSearchResult.results[0].url) {
                            boothSearchResult = await window.electronAPI.booth.searchByFilename(unityFiles[0].fileName);
                        }
                        
                        if (boothSearchResult.success && boothSearchResult.results && boothSearchResult.results.length > 0) {
                            const firstResult = boothSearchResult.results[0];
                            if (firstResult.url && firstResult.url.includes('booth.pm') && firstResult.url.includes('/items/')) {
                                productData.booth_url = firstResult.url;
                                
                                if (boothSearchResult.highConfidence !== false) {
                                    try {
                                        const thumbnailResult = await window.electronAPI.fetch.thumbnail(firstResult.url);
                                        if (thumbnailResult.success && thumbnailResult.thumbnailUrl) {
                                            productData.thumbnail_url = thumbnailResult.thumbnailUrl;
                                        }
                                    } catch (thumbnailError) {
                                        console.warn('サムネイル取得失敗:', thumbnailError);
                                    }
                                }
                            }
                        }
                    } catch (boothError) {
                        console.warn('Booth検索に失敗:', boothError);
                    }
                }
                
                // 商品を追加
                try {
                    const addResult = await window.electronAPI.database.addProduct(productData);
                } catch (dbError) {
                    console.error('グループ商品データベース追加エラー:', dbError);
                    alert(`データベース追加エラー: ${dbError.message}`);
                    return;
                }
                
                // ZIPファイルのアーカイブ処理
                await handleZipFileArchive(zipFilePath);
                
                // 学習データを更新（最初のファイルで）
                if (productData.booth_url) {
                    try {
                        await window.electronAPI.booth.learnMapping(unityFiles[0].fileName, productData.booth_url);
                    } catch (learningError) {
                        console.error('学習データ更新エラー:', learningError);
                    }
                }
                
                try {
                    await loadProducts();
                } catch (loadError) {
                    console.error('商品リスト更新エラー:', loadError);
                }
                
            } catch (error) {
                console.error('グループ抽出・登録エラー:', error);
                alert(`グループ抽出・登録エラー: ${error.message}`);
            } finally {
                activeZipProcessingCount--;
            }
        }
        
        // 自動登録時の全ファイル処理（フォルダグループ化対応）
        async function autoExtractAndRegisterAllFiles(zipFilePath, unityFiles, zipFileName) {
            // ファイルをフォルダ別にグループ化
            const folderGroups = groupFilesByFolder(unityFiles);
            
            // フォルダごとに処理
            for (const [folderPath, files] of Object.entries(folderGroups)) {
                if (files.length === 1) {
                    // 単一ファイルの場合は個別登録
                    await extractAndRegisterUnitypackage(zipFilePath, files[0], zipFileName);
                } else {
                    // 複数ファイルの場合は結合登録
                    await extractAndRegisterGroupedUnitypackages(zipFilePath, files, zipFileName, folderPath);
                }
            }
        }
        
        // グローバル処理フラグ（並行処理数を管理）
        let activeZipProcessingCount = 0;
        const MAX_CONCURRENT_ZIP_PROCESSING = 3;
        
        // ドロップされたフォルダのルートパス情報を保持
        let currentDroppedFolderPaths = new Map(); // folderName -> rootPath
        
        // ルートフォルダパスを特定する関数
        function findRootFolderPath(filePath, folderName) {
            try {
                // フォルダ名が含まれる最上位のパスを探す
                const normalizedPath = filePath.replace(/\//g, '\\');
                const pathParts = normalizedPath.split('\\');
                
                // folderNameが含まれるインデックスを探す
                const folderIndex = pathParts.findIndex(part => part === folderName);
                
                if (folderIndex !== -1) {
                    // folderNameまでのパスを結合してルートフォルダパスとする
                    const rootParts = pathParts.slice(0, folderIndex + 1);
                    const rootPath = rootParts.join('\\');
                    console.log('ルートフォルダパス特定:', {
                        filePath,
                        folderName,
                        pathParts,
                        folderIndex,
                        rootPath
                    });
                    return rootPath;
                } else {
                    // folderNameが見つからない場合は、直接の親フォルダを返す
                    console.warn('フォルダ名がパスに見つかりません:', { filePath, folderName });
                    return filePath.substring(0, filePath.lastIndexOf('\\'));
                }
            } catch (error) {
                console.error('ルートフォルダパス特定エラー:', error);
                // エラー時は従来の方法にフォールバック
                return filePath.substring(0, filePath.lastIndexOf('\\'));
            }
        }
        
        // Unitypackageを抽出・登録
        async function extractAndRegisterUnitypackage(zipFilePath, unityFile, zipFileName) {
            console.log('extractAndRegisterUnitypackage呼び出し:', {
                zipFilePath,
                unityFile,
                zipFileName
            });
            
            // 並行処理数チェック
            if (activeZipProcessingCount >= MAX_CONCURRENT_ZIP_PROCESSING) {
                console.warn(`最大並行処理数(${MAX_CONCURRENT_ZIP_PROCESSING})に達したため`, unityFile.fileName || unityFile.name || 'Unknown', 'を待機します');
                // 処理数が減るまで待機
                while (activeZipProcessingCount >= MAX_CONCURRENT_ZIP_PROCESSING) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            activeZipProcessingCount++;
            
            
            try {
                // 設定からアーカイブディレクトリを取得
                const archiveDir = await window.electronAPI.fs.getArchiveDir();
                
                // ZIPファイルからUnitypackageを抽出
                // fullPathがある場合は優先して使用、なければfileNameを使用
                const unitypackageEntry = {
                    path: unityFile.fullPath || unityFile.fileName,
                    name: unityFile.fileName || unityFile.name
                };
                
                const extractResult = await window.electronAPI.zip.extractUnitypackage(
                    zipFilePath, 
                    unitypackageEntry, 
                    archiveDir
                );
                
                console.log('抽出結果:', extractResult);
                
                if (!extractResult || !extractResult.success) {
                    console.error('詳細な抽出エラー:', extractResult);
                    alert(`抽出に失敗しました: ${extractResult?.error || 'Unknown error'}\n\n詳細情報:\n- ZIPファイル: ${zipFilePath}\n- 対象ファイル: ${unityFile.fileName || unityFile.name || 'Unknown'}\n- フルパス: ${unityFile.fullPath || unityFile.path || 'N/A'}`);
                    return;
                }
                
                // 抽出したUnitypackageファイルを商品として登録
                const fileName = unityFile.fileName || unityFile.name || 'Unknown';
                const productData = {
                    name: fileName.replace(/\.unitypackage$/i, ''),
                    category: '',
                    tags: '',
                    description: `${fileName}`,
                    booth_url: '',
                    thumbnail_url: '',
                    file_path: extractResult.extractedPath,
                    author: '',
                    avatar_ids: ''
                };
                
                // 購入履歴から候補商品を検索して表示
                const purchaseHistoryData = JSON.parse(localStorage.getItem('boothPurchaseHistory') || '[]');
                
                if (purchaseHistoryData.length > 0) {
                    // ZIPファイル名とUnitypackageファイル名で候補を検索
                    const zipCandidates = findCandidatesForFile(zipFileName);
                    const unityCandidates = findCandidatesForFile(unityFile.fileName || unityFile.name || '');
                    
                    // 重複除去して候補をマージ
                    const allCandidates = [...zipCandidates];
                    unityCandidates.forEach(candidate => {
                        if (!allCandidates.some(existing => existing.boothUrl === candidate.boothUrl)) {
                            allCandidates.push(candidate);
                        }
                    });
                    
                    if (allCandidates.length > 0) {
                        // 最高スコアの候補をチェック
                        const topCandidate = allCandidates[0];
                        const isHighConfidenceMatch = topCandidate.matchScore >= 0.7; // 70%以上で自動登録
                        
                        if (isHighConfidenceMatch) {
                            // 70%以上マッチの場合は確認なしで自動登録
                            const matchPercentage = Math.round(topCandidate.matchScore * 100);
                            
                            // 商品データを更新
                            productData.name = topCandidate.title;
                            productData.booth_url = topCandidate.boothUrl;
                            productData.thumbnail_url = topCandidate.thumbnailUrl;
                            productData.author = topCandidate.author;
                            productData.description = `${fileName} (自動マッチ ${matchPercentage}%: ${topCandidate.bestMatch})`;
                            
                            // 商品を登録
                            console.log('自動マッチで商品を登録します:', productData);
                            await registerProduct(productData);
                            
                            // ZIPファイルのアーカイブ処理
                            await handleZipFileArchive(zipFilePath);
                            
                            return;
                        } else {
                            // 70%未満の場合は候補選択モーダル表示
                            const matchPercentage = Math.round(topCandidate.matchScore * 100);
                            
                            // キューに追加して順次処理
                            modalQueue.push({
                                fileName: zipFileName,
                                candidates: allCandidates,
                                productData: productData
                            });
                            
                            // キュー処理を開始
                            await processModalQueue();
                            
                            // 候補選択待ちなので、ここで処理を終了
                            return;
                        }
                    }
                }
                
                // 候補が見つからない場合は通常の処理を継続
                console.log('商品を登録します:', productData);
                await registerProduct(productData);
                
                // ZIPファイルのアーカイブ処理
                await handleZipFileArchive(zipFilePath);
                
            } catch (error) {
                console.error('抽出・登録エラー:', error);
                alert(`抽出・登録エラー: ${error.message}`);
            } finally {
                // 処理カウントを減少
                activeZipProcessingCount--;
            }
        }
        
        // ZIPファイルのアーカイブ処理
        async function handleZipFileArchive(zipFilePath) {
            try {
                const settings = await window.electronAPI.settings.get();
                if (settings.autoArchive === true) {
                    console.log('ZIPファイルアーカイブ処理開始:', zipFilePath);
                    
                    const archiveResult = await window.electronAPI.fs.moveToArchive(zipFilePath);
                    console.log('ZIPファイルアーカイブ結果:', archiveResult);
                    
                    if (archiveResult.success) {
                        console.log('ZIPファイルをアーカイブに移動しました:', archiveResult.newPath);
                    } else {
                        console.error('ZIPファイルアーカイブ失敗:', archiveResult.error);
                    }
                }
            } catch (error) {
                console.error('ZIPファイルアーカイブエラー:', error);
            }
        }
        
        // 混在ドロップ処理: フォルダ内ファイル（結合）と単体ファイル（個別）を分類処理
        async function processedMixedDrop(files, dataTransferItems) {
            
            // unitypackageファイルを抽出
            const unityPackageFiles = files.filter(file => 
                file.name.toLowerCase().endsWith('.unitypackage')
            );
            
            // ZIPファイルを検出
            const zipFiles = files.filter(file => 
                file.name.toLowerCase().endsWith('.zip')
            );
            
            // フォルダを検出
            const folderItems = [];
            if (dataTransferItems) {
                for (let item of dataTransferItems) {
                    if (item.kind === 'file') {
                        const entry = item.webkitGetAsEntry();
                        if (entry && entry.isDirectory) {
                            folderItems.push(entry);
                        }
                    }
                }
            }
            
            
            // フォルダが含まれている場合は、フォルダからファイルを抽出して処理
            if (folderItems.length > 0) {
                
                // 各フォルダからunitypackageファイルを抽出
                for (let i = 0; i < folderItems.length; i++) {
                    const folderEntry = folderItems[i];
                    
                    try {
                        const folderFiles = await extractFilesFromFolder(folderEntry);
                        
                        if (folderFiles.length > 0) {
                            await processFilesAsOneProduct(folderFiles, folderEntry.name);
                        } else {
                        }
                    } catch (error) {
                        console.error(`❌ フォルダ処理エラー (${folderEntry.name}):`, error);
                        // エラーが発生してもループは継続
                    }
                }
                
                // ZIPファイルの処理
                if (zipFiles.length > 0) {
                    for (const zipFile of zipFiles) {
                        try {
                            await processZipFile(zipFile.path || zipFile.name);
                        } catch (error) {
                            console.error('ZIPファイル処理エラー:', error);
                            alert(`ZIPファイル処理エラー: ${zipFile.name} - ${error.message}`);
                        }
                    }
                }
                
                // 単体unitypackageファイルも処理
                if (unityPackageFiles.length > 0) {
                    const standaloneFilePaths = unityPackageFiles.map(f => f.path || f.name);
                    await processFilesAsSeparateProducts(standaloneFilePaths);
                }
                
                let message = `${folderItems.length}個のフォルダを統合商品として追加`;
                if (zipFiles.length > 0) {
                    message += `、${zipFiles.length}個のZIPファイルを処理`;
                }
                if (unityPackageFiles.length > 0) {
                    message += `、${unityPackageFiles.length}個の単体ファイルを個別商品として追加`;
                }
                
                loadProducts();
                return;
            }
            
            // ZIPファイルのみがドロップされた場合の処理
            if (zipFiles.length > 0 && folderItems.length === 0) {
                for (const zipFile of zipFiles) {
                    try {
                        await processZipFile(zipFile.path || zipFile.name);
                    } catch (error) {
                        console.error('ZIPファイル処理エラー:', error);
                        alert(`ZIPファイル処理エラー: ${zipFile.name} - ${error.message}`);
                    }
                }
                loadProducts();
                return;
            }
            
            // フォルダ内ファイルと単体ファイルを分類
            const folderGroups = new Map(); // フォルダパス -> ファイル配列
            const standaloneFiles = []; // 単体ファイル
            
            for (const file of unityPackageFiles) {
                const filePath = file.path || file.name;
                
                // webkitRelativePathがある場合は確実にフォルダから
                if (file.webkitRelativePath && file.webkitRelativePath !== '') {
                    const pathParts = file.webkitRelativePath.split('/');
                    const folderName = pathParts[0];
                    
                    if (!folderGroups.has(folderName)) {
                        folderGroups.set(folderName, {
                            folderName: folderName,
                            files: []
                        });
                    }
                    folderGroups.get(folderName).files.push(filePath);
                    continue;
                }
                
                // パスがある場合、フォルダから来たファイルかチェック
                if (filePath && filePath !== file.name && (filePath.includes('/') || filePath.includes('\\'))) {
                    const separator = filePath.includes('/') ? '/' : '\\';
                    const folderPath = filePath.substring(0, filePath.lastIndexOf(separator));
                    const folderName = folderPath.substring(folderPath.lastIndexOf(separator) + 1);
                    
                    if (folderName && folderName !== '') {
                        if (!folderGroups.has(folderPath)) {
                            folderGroups.set(folderPath, {
                                folderName: folderName,
                                files: []
                            });
                        }
                        folderGroups.get(folderPath).files.push(filePath);
                    } else {
                        standaloneFiles.push(filePath);
                    }
                } else {
                    standaloneFiles.push(filePath);
                }
            }
            
            
            // 単体ファイル複数の場合は常に個別登録
            if (folderGroups.size > 0 && standaloneFiles.length === 0) {
                // 全てがフォルダグループの場合、個別商品として処理
                const allFiles = [];
                for (const [folderPath, groupData] of folderGroups) {
                    allFiles.push(...groupData.files);
                }
                await processFilesAsSeparateProducts(allFiles);
            } else {
                // 混在している場合は元の処理
                
                // フォルダグループ処理
                for (const [folderPath, groupData] of folderGroups) {
                    if (groupData.files.length > 0) {
                        try {
                            await processFilesAsOneProduct(groupData.files, groupData.folderName);
                        } catch (error) {
                            // エラー処理は内部で行う
                        }
                    }
                }
                
                // 単体ファイル処理
                if (standaloneFiles.length > 0) {
                    try {
                        await processFilesAsSeparateProducts(standaloneFiles);
                    } catch (error) {
                        // エラー処理は内部で行う
                    }
                }
                
            }
            
            loadProducts();
        }
        
        // ドロップされたファイルを処理
        async function processDroppedFiles(files) {
            
            for (let i = 0; i < files.length; i++) {
                const filePath = files[i];
                // ファイルパスから拡張子を除いたファイル名を取得
                const rawFileName = typeof filePath === 'string' 
                    ? filePath.split('\\').pop().split('/').pop()
                    : filePath.name;
                    
                const { normalizedName } = extractSearchKeywords(rawFileName);
                
                // ファイル名から商品名を推測（各単語の先頭を大文字に）
                const productName = normalizedName
                    .replace(/\b\w/g, l => l.toUpperCase());
                
                // 自動でカテゴリを推測
                let category = 'その他';
                const lowerName = normalizedName.toLowerCase();
                if (lowerName.includes('avatar') || lowerName.includes('アバター')) {
                    category = 'アバター本体';
                } else if (lowerName.includes('costume') || lowerName.includes('cloth') || lowerName.includes('衣装')) {
                    category = '衣装';
                } else if (lowerName.includes('accessory') || lowerName.includes('アクセサリー')) {
                    category = 'アクセサリー';
                } else if (lowerName.includes('hair') || lowerName.includes('髪')) {
                    category = '髪型';
                } else if (lowerName.includes('tool') || lowerName.includes('ツール') || lowerName.includes('editor') || lowerName.includes('utility')) {
                    category = 'ツール';
                } else if (lowerName.includes('pose') || lowerName.includes('ポーズ') || lowerName.includes('motion') || lowerName.includes('anim')) {
                    category = 'ポーズ';
                } else if (lowerName.includes('world') || lowerName.includes('ワールド') || lowerName.includes('scene')) {
                    category = 'ワールド';
                }
                
                const productData = {
                    name: productName,
                    category: category,
                    booth_url: '',
                    thumbnail_url: '',
                    file_path: typeof filePath === 'string' ? filePath : filePath.path,
                    description: `ファイル: ${fileName}.unitypackage`,
                    author: '',
                    avatar_ids: '',
                    tags: ''
                };
                
                try {
                    if (window.electronAPI) {
                        await window.electronAPI.database.addProduct(productData);
                        
                        // 学習データから自動でBooth URL取得とサムネイル設定
                        const actualFileName = typeof filePath === 'string' 
                            ? filePath.split('\\').pop().split('/').pop() 
                            : filePath.name;
                        
                        try {
                            const boothSearchResult = await window.electronAPI.booth.searchByFilename(actualFileName);
                            if (boothSearchResult.success && boothSearchResult.results && boothSearchResult.results.length > 0) {
                                const firstResult = boothSearchResult.results[0];
                                if (firstResult.url && firstResult.url.includes('booth.pm') && firstResult.url.includes('/items/')) {
                                    // Booth URLを更新
                                    productData.booth_url = firstResult.url;
                                    
                                    if (boothSearchResult.highConfidence !== false) {
                                        try {
                                            const thumbnailResult = await window.electronAPI.fetch.thumbnail(firstResult.url);
                                            if (thumbnailResult.success && thumbnailResult.thumbnailUrl) {
                                                productData.thumbnail_url = thumbnailResult.thumbnailUrl;
                                            }
                                        } catch (thumbnailError) {
                                            // サムネイル取得失敗は致命的ではない
                                        }
                                    } else {
                                        // 低信頼度の場合はサムネイルを取得せず警告表示
                                        console.warn('信頼度が低いマッチのためサムネイルを取得しませんでした:', firstResult.title);
                                    }
                                    
                                    // 更新された商品データを保存
                                    const products = await window.electronAPI.database.getProducts();
                                    const addedProduct = products[products.length - 1];
                                    if (addedProduct) {
                                        await window.electronAPI.database.updateProduct(addedProduct.id, {
                                            ...addedProduct,
                                            booth_url: productData.booth_url,
                                            thumbnail_url: productData.thumbnail_url
                                        });
                                    }
                                }
                            }
                        } catch (boothError) {
                            // Booth検索失敗は致命的ではない
                        }
                        
                        // 設定確認後、ファイルをアーカイブに移動
                        const settings = await window.electronAPI.settings.get();
                        if (settings.autoArchive === true) {
                            const archiveResult = await window.electronAPI.fs.moveToArchive(productData.file_path);
                            if (archiveResult.success) {
                                // データベース内のファイルパスを更新
                                const products = await window.electronAPI.database.getProducts();
                                const addedProduct = products[products.length - 1]; // 最後に追加された商品
                                if (addedProduct) {
                                    await window.electronAPI.database.updateProduct(addedProduct.id, {
                                        ...addedProduct,
                                        file_path: archiveResult.newPath
                                    });
                                }
                            } else {
                                console.warn('ファイルのアーカイブ移動に失敗:', archiveResult.error);
                            }
                        } else {
                        }
                    }
                } catch (error) {
                    console.error('商品追加エラー:', error);
                }
            }
            
            // データを再読み込み
            await loadProducts();
            
            const successCount = files.length;
            
            // 設定を確認してメッセージを変更
            const settings = await window.electronAPI.settings.get();
            if (settings.autoArchive === true) {
                alert(`${successCount}個の商品を追加しました！\nファイルはアーカイブフォルダに移動されました。`);
            } else {
                alert(`${successCount}個の商品を追加しました！`);
            }
        }
        
        // 表示切り替え関数
        function switchToGridView() {
            isListView = false;
            selectedProducts.clear();
            updateViewButtons();
            filterProducts(); // フィルタと並び順を適用して再描画
            updateSelectionBlock();
        }
        
        function switchToListView() {
            isListView = true;
            updateViewButtons();
            filterProducts(); // フィルタと並び順を適用して再描画
        }
        
        function updateViewButtons() {
            const gridBtn = document.getElementById('gridViewBtn');
            const listBtn = document.getElementById('listViewBtn');
            
            if (isListView) {
                gridBtn.style.backgroundColor = '#6b7280';
                gridBtn.style.border = 'none';
                listBtn.style.backgroundColor = '#4b5563';
                listBtn.style.border = '1px solid #6b7280';
            } else {
                gridBtn.style.backgroundColor = '#4b5563';
                gridBtn.style.border = '1px solid #6b7280';
                listBtn.style.backgroundColor = '#6b7280';
                listBtn.style.border = 'none';
            }
        }
        
        // 選択機能
        function toggleProductSelection(productId) {
            if (selectedProducts.has(productId)) {
                selectedProducts.delete(productId);
            } else {
                selectedProducts.add(productId);
            }
            
            // チェックボックスの状態だけを更新（再レンダリングしない）
            updateCheckboxStates();
            updateSelectionBlock();
        }
        
        function updateCheckboxStates() {
            // 現在表示されているすべてのチェックボックスの状態を更新
            const checkboxes = document.querySelectorAll('.item-checkbox');
            checkboxes.forEach(checkbox => {
                const productId = parseInt(checkbox.parentElement.querySelector('[onclick*="toggleProductSelection"]').getAttribute('onclick').match(/\d+/)[0]);
                checkbox.checked = selectedProducts.has(productId);
            });
        }
        
        function updateSelectionBlock() {
            const selectionBlock = document.getElementById('selectionBlock');
            const selectedCount = document.getElementById('selectedCount');
            const productsContainer = document.getElementById('products');
            
            if (selectedProducts.size > 0) {
                selectedCount.textContent = selectedProducts.size;
                
                // 選択された商品の共通タグを取得してプリセット
                prefillCommonTags();
                
                // フェードイン：下からスライドアップしながら表示
                selectionBlock.style.visibility = 'visible';
                selectionBlock.style.opacity = '1';
                selectionBlock.style.transform = 'translateY(0)';
                
                // タグ編集ボックスが表示されている時は十分な余白を確保
                productsContainer.style.paddingBottom = '200px';
            } else {
                // フェードアウト：下にスライドダウンしながら非表示
                selectionBlock.style.opacity = '0';
                selectionBlock.style.transform = 'translateY(100%)';
                
                // アニメーション完了後にvisibilityを変更
                setTimeout(() => {
                    if (selectedProducts.size === 0) {
                        selectionBlock.style.visibility = 'hidden';
                    }
                }, 300); // トランジション時間と同じ
                
                // タグ編集ボックスが非表示の時は通常の余白
                productsContainer.style.paddingBottom = '20px';
            }
        }
        
        // 選択された商品の共通タグをプリフィル
        function prefillCommonTags() {
            if (selectedProducts.size === 0) return;
            
            const selectedProductsList = Array.from(selectedProducts).map(id => 
                products.find(p => p.id === id)
            ).filter(p => p);
            
            if (selectedProductsList.length === 0) return;
            
            // 各商品のタグを配列として取得
            const productTagArrays = selectedProductsList.map(product => {
                return product.tags ? product.tags.split(',').map(tag => tag.trim()).filter(tag => tag) : [];
            });
            
            let commonTags = [];
            
            if (selectedProducts.size === 1) {
                // 1個選択の場合：そのアイテムのすべてのタグを表示
                commonTags = productTagArrays[0] || [];
            } else {
                // 複数選択の場合：すべての商品に共通するタグのみ表示
                if (productTagArrays.length > 0) {
                    commonTags = productTagArrays[0].filter(tag => 
                        productTagArrays.every(tagArray => tagArray.includes(tag))
                    );
                }
            }
            
            // 共通タグを selectedTagsForEditing に追加
            selectedTagsForEditing.clear();
            commonTags.forEach(tag => selectedTagsForEditing.add(tag));
            
            // タグ表示を更新
            updateTagsDisplay();
        }
        
        function clearSelection() {
            selectedProducts.clear();
            selectedTagsForEditing.clear();
            updateCheckboxStates();
            updateSelectionBlock();
            updateTagsDisplay();
        }
        
        // YouTube風タグ編集機能
        let selectedTagsForEditing = new Set();
        let allAvailableTags = new Set();
        
        function updateTagsDisplay() {
            const selectedTagsArea = document.getElementById('selectedTagsArea');
            selectedTagsArea.innerHTML = '';
            
            selectedTagsForEditing.forEach(tag => {
                const tagChip = document.createElement('div');
                tagChip.style.cssText = `
                    display: inline-flex;
                    align-items: center;
                    background-color: #059669;
                    color: white;
                    padding: 4px 10px;
                    border-radius: 12px;
                    font-size: 13px;
                    gap: 5px;
                    font-weight: 500;
                `;
                
                tagChip.innerHTML = `
                    <span>${tag}</span>
                    <button onclick="removeTagFromSelection('${tag}')" style="
                        background: none;
                        border: none;
                        color: white;
                        cursor: pointer;
                        padding: 0;
                        width: 16px;
                        height: 16px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        border-radius: 50%;
                        font-size: 11px;
                        line-height: 1;
                    " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.2)'" onmouseout="this.style.backgroundColor='transparent'">×</button>
                `;
                
                selectedTagsArea.appendChild(tagChip);
            });
        }
        
        // 非モーダル通知システム
        function showNotification(message, type = 'info') {
            // 既存の通知があれば削除
            const existingNotification = document.getElementById('notification-toast');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            // 新しい通知を作成
            const notification = document.createElement('div');
            notification.id = 'notification-toast';
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? '#10b981' : '#3b82f6'};
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                z-index: 10000;
                animation: slideIn 0.3s ease-out;
            `;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // 3秒後に自動的に削除
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.animation = 'slideOut 0.3s ease-out';
                    setTimeout(() => notification.remove(), 300);
                }
            }, 3000);
        }
        
        function getAllTagsFromProducts() {
            const tags = new Set();
            products.forEach(product => {
                if (product.tags) {
                    product.tags.split(',').forEach(tag => {
                        const trimmed = tag.trim();
                        if (trimmed) tags.add(trimmed);
                    });
                }
            });
            return Array.from(tags).sort();
        }
        
        function showTagSuggestions(query) {
            const suggestionsDiv = document.getElementById('tagSuggestions');
            const allTags = getAllTagsFromProducts();
            
            if (!query.trim()) {
                // 空の場合は既存のタグを表示
                const filteredTags = allTags.filter(tag => !selectedTagsForEditing.has(tag));
                displayTagSuggestions(filteredTags.slice(0, 10));
                return;
            }
            
            const filteredTags = allTags.filter(tag => 
                tag.toLowerCase().includes(query.toLowerCase()) && 
                !selectedTagsForEditing.has(tag)
            );
            
            displayTagSuggestions(filteredTags.slice(0, 10));
        }
        
        function displayTagSuggestions(tags) {
            const suggestionsDiv = document.getElementById('tagSuggestions');
            
            if (tags.length === 0) {
                suggestionsDiv.style.display = 'none';
                return;
            }
            
            suggestionsDiv.innerHTML = '';
            tags.forEach(tag => {
                const suggestion = document.createElement('div');
                suggestion.style.cssText = `
                    padding: 3px 4px;
                    cursor: pointer;
                    color: white;
                    font-size: 11px;
                    border-bottom: 1px solid #6b7280;
                `;
                suggestion.textContent = tag;
                suggestion.onmouseover = () => suggestion.style.backgroundColor = '#6b7280';
                suggestion.onmouseout = () => suggestion.style.backgroundColor = 'transparent';
                suggestion.onmousedown = (e) => {
                    e.preventDefault(); // blurイベントをキャンセル
                    addTagToSelection(tag);
                };
                
                suggestionsDiv.appendChild(suggestion);
            });
            
            suggestionsDiv.style.display = 'block';
        }
        
        function hideTagSuggestions() {
            setTimeout(() => {
                document.getElementById('tagSuggestions').style.display = 'none';
            }, 200);
        }
        
        function handleTagInput(event) {
            
            // Enterキーの処理のみ
            if (event.key === 'Enter') {
                event.preventDefault();
                event.stopPropagation();
                
                const input = event.target;
                const tag = input.value.trim();
                
                if (tag && !selectedTagsForEditing.has(tag)) {
                    addTagToSelection(tag);
                }
                
                input.value = '';
                hideTagSuggestions();
                return;
            }
            
            // バックスペース処理
            if (event.key === 'Backspace' && event.target.value === '') {
                // 入力が空でバックスペースを押した場合、最後のタグを削除
                const tagsArray = Array.from(selectedTagsForEditing);
                if (tagsArray.length > 0) {
                    removeTagFromSelection(tagsArray[tagsArray.length - 1]);
                }
                return;
            }
        }
        
        // Store the last seen input value globally
        window.lastTagInputValue = '';
        
        function addTagFromInput() {
            const input = document.getElementById('tagInput');
            
            if (!input) {
                alert('入力フィールドが見つかりません');
                return;
            }
            
            // Try multiple methods to get the input value
            let tag = input.value ? input.value.trim() : '';
            
            // Fallback: try using getAttribute
            if (!tag) {
                const attrValue = input.getAttribute('value');
                tag = attrValue ? attrValue.trim() : '';
            }
            
            // Fallback: use last known value from global storage
            if (!tag && window.lastTagInputValue) {
                tag = window.lastTagInputValue.trim();
            }
            
            // Final fallback: try to get value through different property access
            if (!tag) {
                try {
                    const currentValue = input['value'] || '';
                    tag = currentValue.trim();
                } catch (e) {
                    // エラーは無視
                }
            }
            
            if (!tag) {
                alert('タグを入力してください');
                return;
            }
            
            if (selectedTagsForEditing.has(tag)) {
                alert('このタグは既に追加されています');
                return;
            }
            
            addTagToSelection(tag);
            
            // Clear the stored value
            window.lastTagInputValue = '';
            
            // フォーカスを入力フィールドに戻す
            setTimeout(() => {
                const tagInput = document.getElementById('tagInput');
                if (tagInput) {
                    tagInput.focus();
                }
            }, 50);
        }
        
        function addTagToSelection(tag) {
            // 無効な入力を防ぐ
            if (!tag || typeof tag !== 'string' || tag.trim().length === 0) {
                return;
            }
            
            const trimmedTag = tag.trim();
            
            selectedTagsForEditing.add(trimmedTag);
            updateTagsDisplay();
            
            // Clear input field ONLY if called from addTagFromInput
            const currentStack = new Error().stack;
            if (currentStack.includes('addTagFromInput')) {
                const tagInputElement = document.getElementById('tagInput');
                if (tagInputElement) {
                    tagInputElement.value = '';
                }
            }
            
            hideTagSuggestions();
        }
        
        function removeTagFromSelection(tag) {
            selectedTagsForEditing.delete(tag);
            updateTagsDisplay();
        }
        
        async function applyTagsToSelected() {
            if (selectedProducts.size === 0) {
                alert('商品が選択されていません');
                return;
            }
            
            const tagsArray = Array.from(selectedTagsForEditing);
            const tagsString = tagsArray.join(', ');
            
            let successful = 0;
            let failed = 0;
            
            // 各選択商品のタグを更新
            for (const productId of selectedProducts) {
                try {
                    const product = products.find(p => p.id === productId);
                    if (product) {
                        // データベースを更新
                        const updatedProduct = {
                            ...product,
                            tags: tagsString
                        };
                        
                        if (window.electronAPI && window.electronAPI.database) {
                            await window.electronAPI.database.updateProduct(productId, updatedProduct);
                            successful++;
                            
                            // ローカルのproducts配列も更新
                            const productIndex = products.findIndex(p => p.id === productId);
                            if (productIndex !== -1) {
                                products[productIndex] = updatedProduct;
                            }
                        }
                    }
                } catch (error) {
                    console.error('Failed to update product tags:', error);
                    failed++;
                }
            }
            
            // UI更新
            if (successful > 0) {
                // 商品一覧を再描画
                await loadProducts();
                
                // タグフィルターの選択肢を更新
                updateTagFilterSelect();
                
                // タグ一覧はクリアしない（ユーザーが手動でクリアする）
                // selectedTagsForEditing.clear();
                // updateTagsDisplay();
                
                // alert前に入力フィールドの状態を保存
                const tagInputBeforeAlert = document.getElementById('tagInput');
                const tagInputValue = tagInputBeforeAlert ? tagInputBeforeAlert.value : '';
                
                // alertの代わりに非モーダルな通知を表示（入力フィールドがブロックされない）
                showNotification(`${successful}個の商品にタグを適用しました`, 'success');
                // フォールバック：showNotificationが定義されていない場合はalertを使用
                if (typeof showNotification === 'undefined') {
                    alert(`${successful}個の商品にタグを適用しました`);
                }
                
                // alertの後、すぐに入力フィールドを復元
                const tagInput = document.getElementById('tagInput');
                if (tagInput) {
                    // 入力フィールドのプロパティをリセット
                    tagInput.disabled = false;
                    tagInput.readOnly = false;
                    tagInput.style.pointerEvents = 'auto';
                    tagInput.style.userSelect = 'text';
                    tagInput.style.cursor = 'text';
                    tagInput.tabIndex = 0;
                    tagInput.value = tagInputValue;
                    
                    // 即座にフォーカスを設定
                    tagInput.focus();
                    
                    // 追加の遅延フォーカス（保険）
                    setTimeout(() => {
                        tagInput.focus();
                        tagInput.click();
                    }, 100);
                }
                
                // データベース更新は既に行われているため、ここでの重複更新は削除
            }
            
            if (failed > 0) {
                alert(`${failed}個の商品でエラーが発生しました`);
            }
        }
        
        function deleteSelectedProducts() {
            if (selectedProducts.size === 0) return;
            
            const selectedProductsList = Array.from(selectedProducts).map(id => {
                const product = products.find(p => p.id === id);
                return product ? product.name : `ID: ${id}`;
            }).join('\n・');
            
            if (confirm(`以下の${selectedProducts.size}個の商品を削除しますか？\n\n・${selectedProductsList}`)) {
                const deletePromises = Array.from(selectedProducts).map(async (productId) => {
                    try {
                        await window.electronAPI.database.deleteProduct(productId);
                        return { success: true, id: productId };
                    } catch (error) {
                        console.error(`Failed to delete product ${productId}:`, error);
                        return { success: false, id: productId, error };
                    }
                });
                
                Promise.all(deletePromises).then(results => {
                    const successful = results.filter(r => r.success);
                    const failed = results.filter(r => !r.success);
                    
                    if (successful.length > 0) {
                        alert(`${successful.length}個の商品を削除しました。`);
                        selectedProducts.clear();
                        loadProducts(); // データを再読み込み
                    }
                    
                    if (failed.length > 0) {
                        alert(`${failed.length}個の商品の削除に失敗しました。`);
                    }
                });
            }
        }
        
        // 商品追加モーダルを開く
        function openProductModal() {
            currentEditingProductId = null;
            document.getElementById('modalTitle').textContent = '商品を追加';
            document.getElementById('productForm').reset();
            document.getElementById('thumbnailPreview').style.display = 'none';
            document.getElementById('multipleFilesArea').style.display = 'none';
            document.getElementById('selectedFileInfo').textContent = '';
            window.multipleFileData = null; // 複数ファイルデータをクリア
            selectedTagsForEditing.clear();
            updateTagsDisplay();
            document.getElementById('productModal').style.display = 'block';
            
            // モーダル内のすべての入力フィールドを完全に修正
            setTimeout(() => {
                const modalInputs = document.querySelectorAll('#productModal input[type="text"], #productModal input[type="url"], #productModal textarea');
                
                modalInputs.forEach((field, index) => {
                    // 基本プロパティを設定
                    field.disabled = false;
                    field.readOnly = false;
                    field.tabIndex = 0;
                    
                    // CSSを完全にリセット
                    field.style.cssText = field.style.cssText + '; pointer-events: auto !important; user-select: text !important; cursor: text !important;';
                    
                    // 既存のイベントリスナーをクリア
                    field.onclick = null;
                    field.onmousedown = null;
                    field.onfocus = null;
                    field.onblur = null;
                    
                    // 新しいイベントリスナーを追加
                    field.addEventListener('click', function(e) {
                        e.stopPropagation();
                        this.focus();
                    }, true);
                    
                    field.addEventListener('mousedown', function(e) {
                        e.stopPropagation();
                    }, true);
                });
            }, 100);
            
            // モーダル表示後に最初の入力欄にフォーカス
            setTimeout(() => {
                document.getElementById('productName').focus();
            }, 100);
        }
        
        // WebKit Entry APIを使ったフォルダ処理（選択肢付き）
        async function processFolderDropEntryWithOptions(entry) {
            if (!entry.isDirectory) return;
            
            
            // Entry APIから取得したファイルパスは仮想パスで実際のファイルシステムパスと異なるため、
            // ディレクトリ選択ダイアログを開いて正確なパスを取得する
            alert('フォルダが検出されました。正確なフォルダを選択してください。');
            selectDirectoryForDrop();
        }
        
        // Entry APIでディレクトリを処理（改良版）
        async function processDirectoryEntry(entry) {
            if (!entry.isDirectory) return;
            
            
            try {
                const unityPackageFiles = [];
                const reader = entry.createReader();
                
                const readEntries = () => {
                    return new Promise((resolve, reject) => {
                        reader.readEntries((entries) => {
                            resolve(entries);
                        }, reject);
                    });
                };
                
                const entries = await readEntries();
                
                // .unitypackageファイルを検索
                for (const fileEntry of entries) {
                    if (!fileEntry.isDirectory && fileEntry.name.toLowerCase().endsWith('.unitypackage')) {
                        
                        // Fileオブジェクトを取得してパスを得る
                        const file = await new Promise((resolve, reject) => {
                            fileEntry.file(resolve, reject);
                        });
                        
                        // ファイルパスを構築（file.pathが利用できない場合の代替手段）
                        const filePath = file.path || `${entry.name}/${fileEntry.name}`;
                        unityPackageFiles.push(filePath);
                    }
                }
                
                if (unityPackageFiles.length > 0) {
                    
                    if (unityPackageFiles.length > 1) {
                        // 複数ファイルの場合は選択肢を提供
                        showFolderOptionDialog(unityPackageFiles, entry.name);
                    } else {
                        // 単一ファイルの場合
                        processFilesAsSeparateProducts(unityPackageFiles, entry.name);
                    }
                } else {
                    // フォルダが見つかったが、Unity packageファイルがない場合は
                    // main processのディレクトリ選択を使用
                    alert('フォルダ内に.unitypackageファイルが見つかりませんでした。正確なフォルダを選択してください。');
                    selectDirectoryForDrop();
                }
                
            } catch (error) {
                console.error('Entry API処理エラー:', error);
                // Entry APIでエラーが発生した場合はフォールバック
                alert('フォルダの処理に失敗しました。正確なフォルダを選択してください。');
                selectDirectoryForDrop();
            }
        }

        // ドロップ用のディレクトリ選択
        async function selectDirectoryForDrop() {
            try {
                if (window.electronAPI) {
                    const result = await window.electronAPI.dialog.selectDirectory();
                    if (result && result.files && result.files.length > 0) {
                        
                        if (result.files.length > 1) {
                            // 複数ファイルの場合は選択肢を提供
                            showFolderOptionDialog(result.files, result.folderName);
                        } else if (result.files.length === 1) {
                            // 単一ファイルの場合
                            processFilesAsSeparateProducts(result.files, result.folderName);
                        } else {
                            alert('選択されたフォルダ内に.unitypackageファイルが見つかりませんでした。');
                        }
                    }
                }
            } catch (error) {
                console.error('ディレクトリ選択エラー:', error);
                alert('フォルダの選択に失敗しました。');
            }
        }
        
        // ファイル名からカテゴリを推測
        function detectCategoryFromFileName(fileName) {
            if (!fileName) return 'その他';
            
            const lowerName = fileName.toLowerCase();
            
            // 衣装関連のキーワード
            if (lowerName.includes('cloth') || lowerName.includes('wear') || lowerName.includes('outfit') || 
                lowerName.includes('dress') || lowerName.includes('shirt') || lowerName.includes('pants') ||
                lowerName.includes('skirt') || lowerName.includes('jacket') || lowerName.includes('coat') ||
                lowerName.includes('衣装') || lowerName.includes('服') || lowerName.includes('ドレス') ||
                lowerName.includes('シャツ') || lowerName.includes('パンツ') || lowerName.includes('スカート')) {
                return '衣装';
            }
            
            // アクセサリー関連のキーワード
            if (lowerName.includes('accessory') || lowerName.includes('hat') || lowerName.includes('glasses') ||
                lowerName.includes('bag') || lowerName.includes('jewelry') || lowerName.includes('earring') ||
                lowerName.includes('necklace') || lowerName.includes('bracelet') || lowerName.includes('ring') ||
                lowerName.includes('アクセサリー') || lowerName.includes('帽子') || lowerName.includes('眼鏡') ||
                lowerName.includes('バッグ') || lowerName.includes('ピアス') || lowerName.includes('ネックレス')) {
                return 'アクセサリー';
            }
            
            // アバター本体関連のキーワード
            if (lowerName.includes('avatar') || lowerName.includes('body') || lowerName.includes('base') ||
                lowerName.includes('character') || lowerName.includes('model') ||
                lowerName.includes('アバター') || lowerName.includes('本体') || lowerName.includes('ベース') ||
                lowerName.includes('キャラクター') || lowerName.includes('モデル')) {
                return 'アバター本体';
            }
            
            // デフォルトは「その他」
            return 'その他';
        }

        // ファイルを1つの商品として統合処理
        async function processFilesAsOneProduct(filePaths, folderName) {
            
            if (filePaths.length === 0) return;
            
            // 商品名は元のフォルダ名を使用
            const productName = folderName || 'Unity Package Bundle';
            
            // メインファイルは最初のファイル
            const mainFilePath = filePaths[0];
            
            // 各ファイルの表示名を生成
            const displayNames = filePaths.map(filePath => {
                const fileName = filePath.split(/[/\\]/).pop().replace('.unitypackage', '');
                return fileName;
            });
            
            let productData = {
                name: productName,
                category: '',
                booth_url: '',
                thumbnail_url: '',
                file_path: mainFilePath,
                description: `${folderName}`,
                author: '',
                avatar_ids: '',
                tags: '',
                file_paths: filePaths.join('|'),
                display_names: displayNames.join('|')
            };
            
            // 購入履歴から候補を検索（フォルダ名をZIP名として扱う）
            const purchaseHistoryData = JSON.parse(localStorage.getItem('boothPurchaseHistory') || '[]');
            let foundFromPurchaseHistory = false;
            
            if (purchaseHistoryData.length > 0) {
                // フォルダ名をZIP名として検索
                const folderAsZip = folderName + '.zip';
                const candidates = findCandidatesForFile(folderAsZip);
                
                if (candidates.length > 0) {
                    const topCandidate = candidates[0];
                    const matchPercentage = Math.round(topCandidate.matchScore * 100);
                    
                    // 70%以上なら自動適用
                    if (topCandidate.matchScore >= 0.7) {
                        
                        // 購入履歴データで更新
                        productData.name = topCandidate.title;
                        productData.booth_url = topCandidate.boothUrl;
                        productData.thumbnail_url = topCandidate.thumbnailUrl;
                        productData.author = topCandidate.author;
                        productData.description = `${folderName} (フォルダ一括マッチ ${matchPercentage}%: ${topCandidate.bestMatch})`;
                        
                        foundFromPurchaseHistory = true;
                    }
                }
            }
            
            try {
                if (window.electronAPI) {
                    await window.electronAPI.database.addProduct(productData);
                    
                    if (foundFromPurchaseHistory) {
                    } else {
                        // 学習データから自動でBooth URL取得とサムネイル設定（全ファイルで検索を試行）
                        let foundResult = null;
                        let foundSearchResult = null;
                    
                    for (let i = 0; i < filePaths.length && !foundResult; i++) {
                        const fileName = filePaths[i].split(/[/\\]/).pop();
                        
                        try {
                            const boothSearchResult = await window.electronAPI.booth.searchByFilename(fileName);
                            
                            if (boothSearchResult.success && boothSearchResult.results && boothSearchResult.results.length > 0) {
                                const firstResult = boothSearchResult.results[0];
                                if (firstResult.url && firstResult.url.includes('booth.pm') && firstResult.url.includes('/items/')) {
                                    foundResult = firstResult;
                                    foundSearchResult = boothSearchResult;
                                    break;
                                }
                            }
                        } catch (boothError) {
                            // 検索失敗は無視
                        }
                    }
                    
                    if (foundResult) {
                        // Booth URLを更新
                        productData.booth_url = foundResult.url;
                        
                        if (foundSearchResult.highConfidence !== false) {
                            try {
                                const thumbnailResult = await window.electronAPI.fetch.thumbnail(foundResult.url);
                                if (thumbnailResult.success && thumbnailResult.thumbnailUrl) {
                                    productData.thumbnail_url = thumbnailResult.thumbnailUrl;
                                } else {
                                }
                            } catch (thumbnailError) {
                                console.error('🖼️ サムネイル取得エラー:', thumbnailError);
                                // サムネイル取得失敗は無視
                            }
                        } else {
                            // 低信頼度の場合はサムネイルを取得せず警告表示
                            console.warn('🖼️ 信頼度が低いマッチのためサムネイルを取得しませんでした:', foundResult.title);
                        }
                        
                        // 更新された商品データを保存
                        const products = await window.electronAPI.database.getProducts();
                        const addedProduct = products[products.length - 1];
                        if (addedProduct) {
                            await window.electronAPI.database.updateProduct(addedProduct.id, {
                                ...addedProduct,
                                booth_url: productData.booth_url,
                                thumbnail_url: productData.thumbnail_url
                            });
                        }
                    }
                    }
                    
                    // 設定確認後、フォルダごとアーカイブに移動
                    const settings = await window.electronAPI.settings.get();
                    if (settings.autoArchive === true) {
                        const products = await window.electronAPI.database.getProducts();
                        const addedProduct = products[products.length - 1]; // 最後に追加された商品
                        
                        // ルートフォルダパスを取得（階層の最上位を特定）
                        const firstFilePath = filePaths[0];
                        const folderPath = findRootFolderPath(firstFilePath, folderName);
                        console.log('統合商品用ルートフォルダパス:', folderPath, 'from:', firstFilePath);
                        
                        console.log('統合商品フォルダアーカイブ処理開始:', folderPath);
                        
                        try {
                            // フォルダごとアーカイブに移動
                            const archiveResult = await window.electronAPI.fs.moveFolderToArchive(folderPath);
                            console.log('統合商品フォルダアーカイブ結果:', archiveResult);
                            
                            if (archiveResult.success) {
                                // アーカイブ後のファイルパスを計算
                                const archivedFiles = filePaths.map(filePath => {
                                    const relativePath = filePath.substring(folderPath.length);
                                    return archiveResult.newPath + relativePath;
                                });
                                
                                console.log('統合商品ファイルパス更新:', archivedFiles);
                                
                                // データベースのファイルパスを更新
                                if (addedProduct) {
                                    await window.electronAPI.database.updateProduct(addedProduct.id, {
                                        ...addedProduct,
                                        file_path: archivedFiles[0], // メインファイルパス
                                        file_paths: archivedFiles.join('|') // 全ファイルパス
                                    });
                                }
                            } else {
                                console.error('統合商品フォルダアーカイブ失敗:', archiveResult.error);
                                // エラーの場合は個別ファイルを移動（フォールバック）
                                const archivedFiles = [];
                                let archiveSuccessCount = 0;
                                
                                for (const filePath of filePaths) {
                                    try {
                                        const fileArchiveResult = await window.electronAPI.fs.moveToArchive(filePath);
                                        if (fileArchiveResult.success) {
                                            archivedFiles.push(fileArchiveResult.newPath);
                                            archiveSuccessCount++;
                                        } else {
                                            archivedFiles.push(filePath);
                                        }
                                    } catch (error) {
                                        archivedFiles.push(filePath);
                                    }
                                }
                                
                                // データベースのファイルパスを更新
                                if (addedProduct && archiveSuccessCount > 0) {
                                    await window.electronAPI.database.updateProduct(addedProduct.id, {
                                        ...addedProduct,
                                        file_path: archivedFiles[0],
                                        file_paths: archivedFiles.join('|')
                                    });
                                }
                            }
                        } catch (error) {
                            console.error('統合商品フォルダアーカイブエラー:', error);
                        }
                        
                        // 統合商品追加完了
                    } else {
                        // 統合商品追加完了
                    }
                    loadProducts(); // 商品リストを再読み込み
                }
            } catch (error) {
                console.error('統合商品追加エラー:', error);
                alert('統合商品の追加に失敗しました: ' + error.message);
            }
        }

        // ファイルを個別の商品として処理
        async function processFilesAsSeparateProducts(filePaths, folderName = '') {
            
            let successCount = 0;
            
            for (const filePath of filePaths) {
                const fileName = filePath.split(/[/\\]/).pop().replace('.unitypackage', '');
                const actualFileName = filePath.split(/[/\\]/).pop();
                
                const productName = folderName ? `${folderName} - ${fileName}` : fileName;
                
                let productData = {
                    name: productName,
                    category: '',
                    booth_url: '',
                    thumbnail_url: '',
                    file_path: filePath,
                    description: `${fileName}`,
                    author: '',
                    avatar_ids: '',
                    tags: '',
                    file_paths: '',
                    display_names: ''
                };
                
                // 購入履歴から候補を検索
                const purchaseHistoryData = JSON.parse(localStorage.getItem('boothPurchaseHistory') || '[]');
                let foundFromPurchaseHistory = false;
                
                if (purchaseHistoryData.length > 0) {
                    const candidates = findCandidatesForFile(actualFileName);
                    
                    if (candidates.length > 0) {
                        const topCandidate = candidates[0];
                        const matchPercentage = Math.round(topCandidate.matchScore * 100);
                        
                        // 70%以上なら自動適用
                        if (topCandidate.matchScore >= 0.7) {
                            
                            // 購入履歴データで更新
                            productData.name = topCandidate.title;
                            productData.booth_url = topCandidate.boothUrl;
                            productData.thumbnail_url = topCandidate.thumbnailUrl;
                            productData.author = topCandidate.author;
                            productData.description = `${fileName} (unitypackageマッチ ${matchPercentage}%: ${topCandidate.bestMatch})`;
                            
                            foundFromPurchaseHistory = true;
                        }
                    }
                }
                
                try {
                    if (window.electronAPI) {
                        await window.electronAPI.database.addProduct(productData);
                        successCount++;
                        
                        if (foundFromPurchaseHistory) {
                        } else {
                                // 学習データから自動でBooth URL取得とサムネイル設定
                            try {
                                const boothSearchResult = await window.electronAPI.booth.searchByFilename(actualFileName);
                            
                            if (boothSearchResult.success && boothSearchResult.results && boothSearchResult.results.length > 0) {
                                const firstResult = boothSearchResult.results[0];
                                if (firstResult.url && firstResult.url.includes('booth.pm') && firstResult.url.includes('/items/')) {
                                    // Booth URLを更新
                                    productData.booth_url = firstResult.url;
                                    
                                    if (boothSearchResult.highConfidence !== false) {
                                        try {
                                            const thumbnailResult = await window.electronAPI.fetch.thumbnail(firstResult.url);
                                            if (thumbnailResult.success && thumbnailResult.thumbnailUrl) {
                                                productData.thumbnail_url = thumbnailResult.thumbnailUrl;
                                            }
                                        } catch (thumbnailError) {
                                            // サムネイル取得失敗は無視
                                        }
                                    } else {
                                        // 低信頼度の場合はサムネイルを取得せず警告表示
                                        console.warn('信頼度が低いマッチのためサムネイルを取得しませんでした:', firstResult.title);
                                    }
                                    
                                    // 更新された商品データを保存
                                    const products = await window.electronAPI.database.getProducts();
                                    const addedProduct = products[products.length - 1];
                                    if (addedProduct) {
                                        await window.electronAPI.database.updateProduct(addedProduct.id, {
                                            ...addedProduct,
                                            booth_url: productData.booth_url,
                                            thumbnail_url: productData.thumbnail_url
                                        });
                                    }
                                }
                            }
                        } catch (boothError) {
                                // Booth検索失敗は無視
                            }
                        }
                    }
                } catch (error) {
                    console.error('商品追加エラー:', error);
                }
            }
            
            if (successCount > 0) {
                // 設定を確認してアーカイブ処理と成功メッセージを変更
                const settings = await window.electronAPI.settings.get();
                if (settings.autoArchive === true) {
                    // フォルダごとアーカイブに移動
                    let archiveSuccessCount = 0;
                    const products = await window.electronAPI.database.getProducts();
                    
                    const processedFolders = new Set(); // 処理済みフォルダを記録
                    
                    for (let i = 0; i < successCount; i++) {
                        const addedProduct = products[products.length - successCount + i]; // 追加された商品を順番に取得
                        if (addedProduct && addedProduct.file_path) {
                            const originalFilePath = addedProduct.file_path;
                            
                            // ルートフォルダパスを取得（階層の最上位を特定）
                            const folderPath = findRootFolderPath(originalFilePath, folderName);
                            console.log('特定されたルートフォルダパス:', folderPath, 'from:', originalFilePath);
                            
                            if (folderPath && !processedFolders.has(folderPath)) {
                                processedFolders.add(folderPath);
                                
                                try {
                                    console.log('フォルダアーカイブ処理開始:', folderPath);
                                    // フォルダごとアーカイブに移動
                                    const archiveResult = await window.electronAPI.fs.moveFolderToArchive(folderPath);
                                    console.log('フォルダアーカイブ結果:', archiveResult);
                                    
                                    if (archiveResult.success) {
                                        archiveSuccessCount++;
                                        console.log('フォルダアーカイブ成功。ファイルパス更新中...');
                                        
                                        // このフォルダ内のすべての商品のファイルパスを更新
                                        for (let j = 0; j < successCount; j++) {
                                            const productToUpdate = products[products.length - successCount + j];
                                            if (productToUpdate && productToUpdate.file_path && 
                                                productToUpdate.file_path.startsWith(folderPath)) {
                                                
                                                console.log('更新対象商品:', productToUpdate.name, 'パス:', productToUpdate.file_path);
                                                
                                                // 新しいパスを計算
                                                const relativePath = productToUpdate.file_path.substring(folderPath.length);
                                                const newFilePath = archiveResult.newPath + relativePath;
                                                
                                                console.log('新しいファイルパス:', newFilePath);
                                                
                                                // データベース内のファイルパスを更新
                                                await window.electronAPI.database.updateProduct(productToUpdate.id, {
                                                    ...productToUpdate,
                                                    file_path: newFilePath
                                                });
                                            }
                                        }
                                    } else {
                                        console.error('フォルダアーカイブ失敗:', archiveResult.error);
                                    }
                                } catch (error) {
                                    console.error('フォルダアーカイブエラー:', error);
                                    // エラーの場合は個別ファイルを移動
                                    try {
                                        const fileArchiveResult = await window.electronAPI.fs.moveToArchive(originalFilePath);
                                        if (fileArchiveResult.success) {
                                            await window.electronAPI.database.updateProduct(addedProduct.id, {
                                                ...addedProduct,
                                                file_path: fileArchiveResult.newPath
                                            });
                                            archiveSuccessCount++;
                                        }
                                    } catch (fileError) {
                                        console.error('ファイルアーカイブエラー:', fileError);
                                    }
                                }
                            }
                        }
                    }
                    
                    alert(`${successCount}個の商品を追加しました！\nファイルはアーカイブフォルダに移動されました。`);
                } else {
                    alert(`${successCount}個の商品を追加しました。`);
                }
                loadProducts(); // 商品リストを再読み込み
            }
        }
        
        // フォルダファイルリストから処理（webkitRelativePathを使用）
        async function processFolderFilesWithOptions(folderFiles) {
            
            // .unitypackageファイルのみを抽出
            const unityPackageFiles = folderFiles.filter(file => 
                file.name.toLowerCase().endsWith('.unitypackage')
            );
            
            if (unityPackageFiles.length === 0) {
                alert('フォルダ内に.unitypackageファイルが見つかりませんでした。');
                return;
            }
            
            
            // フォルダ名を取得（最初のファイルのwebkitRelativePathから）
            const firstFilePath = unityPackageFiles[0].webkitRelativePath;
            const folderName = firstFilePath.split('/')[0];
            
            // 実際のファイルパスを取得するため、一時的にファイルを保存
            const realFilePaths = [];
            for (const file of unityPackageFiles) {
                // ファイルの実際のパスは直接取得できないため、
                // main processでファイルダイアログの結果と照合する方法を使用
                // 仮のパスとして、ファイル名を使用（後で修正が必要）
                realFilePaths.push(file.name);
            }
            
            if (unityPackageFiles.length > 1) {
                // 複数ファイルの場合は選択肢を提供
                // 常に統合処理を行う
                processFilesAsOneProduct(unityPackageFiles, folderName);
            } else {
                // 単一ファイルの場合
                processFilesAsSeparateProducts(unityPackageFiles, folderName);
            }
        }

        // main processでフォルダをスキャンする
        async function processFolderDropWithMainProcess(folder) {
            
            try {
                // main processのselectDirectoryを使って、ドロップされたフォルダの内容を取得
                // ただし、実際にはユーザーに選択してもらう必要がある
                alert('フォルダが検出されました。正確なフォルダを選択してください。');
                selectDirectoryForDrop();
            } catch (error) {
                console.error('フォルダ処理エラー:', error);
                alert('フォルダの処理に失敗しました。');
            }
        }
        
        // WebKit Entry APIを使ったフォルダ処理
        async function processFolderDropEntry(entry) {
            if (!entry.isDirectory) return;
            
            
            try {
                const unityPackageFiles = [];
                
                // フォルダ内のファイルを再帰的に読み取り
                const reader = entry.createReader();
                
                const readEntries = () => {
                    return new Promise((resolve, reject) => {
                        reader.readEntries((entries) => {
                            resolve(entries);
                        }, reject);
                    });
                };
                
                const entries = await readEntries();
                
                // ファイルを実際に読み取って、パスを取得
                const filePromises = [];
                
                for (const fileEntry of entries) {
                    if (!fileEntry.isDirectory && fileEntry.name.toLowerCase().endsWith('.unitypackage')) {
                        filePromises.push(
                            new Promise((resolve) => {
                                fileEntry.file((file) => {
                                    // Fileオブジェクトからパスを取得
                                    resolve({
                                        name: file.name,
                                        path: file.path || file.webkitRelativePath || fileEntry.fullPath
                                    });
                                }, (error) => {
                                    console.error('ファイル読み取りエラー:', error);
                                    resolve(null);
                                });
                            })
                        );
                    }
                }
                
                const fileResults = await Promise.all(filePromises);
                const validFiles = fileResults.filter(f => f !== null);
                
                for (const fileInfo of validFiles) {
                    unityPackageFiles.push(fileInfo);
                }
                
                if (unityPackageFiles.length > 0) {
                    
                    // 商品追加フォームを開く
                    openProductModal();
                    
                    // ファイル名の配列を作成
                    const fileNames = unityPackageFiles.map(f => f.name);
                    
                    // 複数ファイルの表示（ファイル名のみ表示）
                    displayMultipleFiles(fileNames);
                    
                    // 最初のファイルをメインとして設定（ファイル名のみ）
                    document.getElementById('productFilePath').value = fileNames[0];
                    
                    // フォルダ名から商品名を推測
                    document.getElementById('productName').value = entry.name;
                    
                    alert(`フォルダ内に${unityPackageFiles.length}個の.unitypackageファイルが見つかりました。商品情報を入力してください。`);
                } else {
                    alert('フォルダ内に.unitypackageファイルが見つかりませんでした。');
                }
            } catch (error) {
                console.error('フォルダ処理エラー:', error);
                alert('フォルダの処理に失敗しました。');
            }
        }
        
        // フォルダがドロップされた時の処理
        async function processFolderDrop(folder) {
            try {
                // フォルダのパスを取得
                const folderPath = folder.path;
                
                // Node.jsのfsモジュールを使ってフォルダ内のファイルを取得
                if (window.electronAPI && window.electronAPI.shell) {
                    // Electronのmain processにフォルダスキャンを依頼
                    const fs = require('fs');
                    const path = require('path');
                    
                    if (fs && fs.readdirSync) {
                        try {
                            const files = fs.readdirSync(folderPath);
                            const unityPackageFiles = files
                                .filter(file => file.toLowerCase().endsWith('.unitypackage'))
                                .map(file => path.join(folderPath, file));
                            
                            if (unityPackageFiles.length > 0) {
                                const folderName = path.basename(folderPath);
                                
                                // 購入履歴から候補を検索（フォルダ名をZIPファイル名として扱う）
                                const purchaseHistoryData = JSON.parse(localStorage.getItem('boothPurchaseHistory') || '[]');
                                
                                let foundFromPurchaseHistory = false;
                                let productData = {
                                    name: folderName,
                                    category: '',
                                    tags: '',
                                    description: folderName,
                                    booth_url: '',
                                    thumbnail_url: '',
                                    file_path: unityPackageFiles[0],
                                    file_paths: unityPackageFiles.join('|'),
                                    display_names: unityPackageFiles.map(f => path.basename(f)).join('|'),
                                    author: '',
                                    avatar_ids: ''
                                };
                                
                                if (purchaseHistoryData.length > 0) {
                                    // フォルダ名をZIP名として検索
                                    const folderAsZip = folderName + '.zip';
                                    const candidates = findCandidatesForFile(folderAsZip);
                                    
                                    if (candidates.length > 0) {
                                        const topCandidate = candidates[0];
                                        const matchPercentage = Math.round(topCandidate.matchScore * 100);
                                        
                                        // 70%以上なら自動適用
                                        if (topCandidate.matchScore >= 0.7) {
                                            
                                            // 購入履歴データで更新
                                            productData.name = topCandidate.title;
                                            productData.booth_url = topCandidate.boothUrl;
                                            productData.thumbnail_url = topCandidate.thumbnailUrl;
                                            productData.author = topCandidate.author;
                                            productData.description = `${folderName} (フォルダマッチ ${matchPercentage}%: ${topCandidate.bestMatch})`;
                                            
                                            foundFromPurchaseHistory = true;
                                        }
                                    }
                                }
                                
                                if (foundFromPurchaseHistory) {
                                    // 70%以上マッチの場合は自動登録
                                    try {
                                        const addResult = await window.electronAPI.database.addProduct(productData);
                                        
                                        // 商品リストを更新
                                        updateProductList();
                                    } catch (error) {
                                        console.error('フォルダ自動登録エラー:', error);
                                        alert(`自動登録に失敗しました: ${error.message}`);
                                    }
                                } else {
                                    // 候補なしまたは低信頼度の場合は手動入力
                                    
                                    // 商品追加フォームを開く
                                    openProductModal();
                                    
                                    // 複数ファイルの表示
                                    displayMultipleFiles(unityPackageFiles);
                                    
                                    // フォルダ情報をフォームに設定
                                    document.getElementById('productFilePath').value = unityPackageFiles[0];
                                    document.getElementById('productName').value = productData.name;
                                    document.getElementById('boothUrl').value = productData.booth_url;
                                    document.getElementById('thumbnailUrl').value = productData.thumbnail_url;
                                    document.getElementById('author').value = productData.author;
                                    
                                    alert(`フォルダ内に${unityPackageFiles.length}個の.unitypackageファイルが見つかりました。商品情報を入力してください。`);
                                }
                            } else {
                                alert('フォルダ内に.unitypackageファイルが見つかりませんでした。');
                            }
                        } catch (error) {
                            console.error('フォルダ読み込みエラー:', error);
                            alert('フォルダの読み込みに失敗しました。');
                        }
                    }
                }
            } catch (error) {
                console.error('フォルダドロップ処理エラー:', error);
                alert('フォルダの処理に失敗しました。');
            }
        }
        
        function getFilteredProducts() {
            // 現在のフィルタ条件に基づいて商品を取得
            let filtered = products.slice();
            
            // カテゴリフィルタ
            const categoryCheckboxes = document.querySelectorAll('[id^="filter_"]:checked');
            const selectedCategories = Array.from(categoryCheckboxes).map(cb => cb.value);
            if (selectedCategories.length > 0) {
                filtered = filtered.filter(product => selectedCategories.includes(product.category));
            }
            
            // 検索フィルタ
            if (searchQuery) {
                const query = searchQuery.toLowerCase();
                filtered = filtered.filter(product => 
                    product.name.toLowerCase().includes(query) ||
                    (product.description && product.description.toLowerCase().includes(query))
                );
            }
            
            return filtered;
        }
        
        // 初期化
        document.addEventListener('DOMContentLoaded', function() {
            loadProducts();
            initDragAndDrop();
            updateViewButtons();
            
            // グローバルイベントリスナーの設定
            setupGlobalEventListeners();
            
            
            // 並び順のデフォルト値を設定
            const orderSelect = document.getElementById('orderSelect');
            if (orderSelect) {
                orderSelect.value = 'created_desc';
                currentSortOrder = 'created_desc';
            }
            
            // サムネイル取得ボタンのイベントリスナー設定
            const thumbnailBtn = document.getElementById('thumbnailFetchBtn');
            if (thumbnailBtn) {
                thumbnailBtn.addEventListener('click', async function(e) {
                    e.preventDefault();
                    // stopPropagationを削除 - これがイベント伝播を妨げている可能性
                    await fetchThumbnail();
                });
            } else {
                console.error('Thumbnail button not found');
            }
        });

        // ヘルプモーダル関数
        function showHelpModal() {
            document.getElementById('helpModal').style.display = 'block';
        }

        function closeHelpModal() {
            document.getElementById('helpModal').style.display = 'none';
        }

        // 設定モーダル関数
        async function showSettingsModal() {
            document.getElementById('settingsModal').style.display = 'block';
            
            // 現在の設定を読み込んでチェックボックスに反映
            try {
                const settings = await window.electronAPI.settings.get();
                document.getElementById('autoArchiveCheckbox').checked = settings.autoArchive === true; // デフォルトは無効
            } catch (error) {
                console.error('設定の読み込みに失敗:', error);
                document.getElementById('autoArchiveCheckbox').checked = false; // デフォルト値
            }
        }

        function closeSettingsModal() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        async function saveSettings() {
            try {
                const autoArchive = document.getElementById('autoArchiveCheckbox').checked;
                await window.electronAPI.settings.update({ 
                    autoArchive
                });
                closeSettingsModal();
            } catch (error) {
                console.error('設定の保存に失敗:', error);
                alert('設定の保存に失敗しました: ' + error.message);
            }
        }


        // モーダル外クリックで閉じる
        window.onclick = function(event) {
            const helpModal = document.getElementById('helpModal');
            const settingsModal = document.getElementById('settingsModal');
            
            if (event.target === helpModal) {
                closeHelpModal();
            } else if (event.target === settingsModal) {
                closeSettingsModal();
            }
        }
    </script>

    <!-- ヘルプモーダル -->
    <div id="helpModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5);">
        <div style="background-color: #374151; margin: 5% auto; padding: 30px; border-radius: 6px; width: 90%; max-width: 800px; color: white; position: relative; max-height: 80vh; overflow-y: auto;">
            <button onclick="closeHelpModal()" style="position: absolute; top: 15px; right: 20px; background: none; border: none; color: #9ca3af; cursor: pointer; font-size: 24px; font-weight: bold;">&times;</button>
            
            <h2 style="margin-top: 0; color: #60a5fa; font-size: 20px;">📘 VRChat Booth商品管理 - 使い方</h2>
            
            <div style="line-height: 1.6; font-size: 14px;">
                <h3 style="color: #34d399; font-size: 16px; margin-top: 25px; margin-bottom: 10px;">🎯 基本操作</h3>
                <ul style="margin-left: 20px;">
                    <li><strong>商品追加:</strong> 「商品を追加」ボタンから新しい商品を登録</li>
                    <li><strong>ドラッグ&ドロップ:</strong> .unitypackageファイルやフォルダを直接ドラッグして一括追加</li>
                    <li><strong>編集:</strong> 各商品の「編集」ボタンから情報を修正</li>
                    <li><strong>削除:</strong> 商品をチェックして「選択したアイテムを削除」で一括削除</li>
                </ul>

                <h3 style="color: #34d399; font-size: 16px; margin-top: 25px; margin-bottom: 10px;">📁 複数ファイル管理</h3>
                <ul style="margin-left: 20px;">
                    <li><strong>複数ファイル登録:</strong> 一つの商品に複数のファイルを関連付け</li>
                    <li><strong>表示名設定:</strong> 各ファイルに分かりやすい名前を設定</li>
                    <li><strong>実行ファイル選択:</strong> Unityボタンクリック時にファイルを選択</li>
                </ul>

                <h3 style="color: #34d399; font-size: 16px; margin-top: 25px; margin-bottom: 10px;">🏷️ タグ機能</h3>
                <ul style="margin-left: 20px;">
                    <li><strong>タグ作成:</strong> 「タグを追加」で新しいタグを作成</li>
                    <li><strong>一括タグ付け:</strong> 複数の商品を選択して一括でタグを適用</li>
                    <li><strong>タグフィルター:</strong> タグで商品を絞り込み表示</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- 設定モーダル -->
    <div id="settingsModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5);">
        <div style="background-color: #374151; margin: 10% auto; padding: 30px; border-radius: 6px; width: 90%; max-width: 500px; color: white; position: relative;">
            <button onclick="closeSettingsModal()" style="position: absolute; top: 15px; right: 20px; background: none; border: none; color: #9ca3af; cursor: pointer; font-size: 24px; font-weight: bold;">&times;</button>
            
            <h2 style="margin-top: 0; color: #60a5fa; font-size: 20px;">⚙️ 設定</h2>
            
            <div style="line-height: 1.6; font-size: 14px;">
                <div style="margin-bottom: 20px;">
                    <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                        <input type="checkbox" id="autoArchiveCheckbox" style="width: 16px; height: 16px;">
                        <div>
                            <div style="font-weight: 600; color: #d1d5db;">自動アーカイブ機能</div>
                            <div style="font-size: 12px; color: #9ca3af; margin-top: 2px;">
                                商品登録時にUnityPackageファイルを自動的にアーカイブフォルダに移動し、<br>
                                ダウンロードフォルダなどから削除します
                            </div>
                        </div>
                    </label>
                </div>
                
                <div style="border-top: 1px solid #4b5563; padding-top: 15px; margin-top: 20px;">
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button onclick="closeSettingsModal()" style="padding: 8px 16px; background-color: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer;">キャンセル</button>
                        <button onclick="saveSettings()" style="padding: 8px 16px; background-color: #059669; color: white; border: none; border-radius: 4px; cursor: pointer;">保存</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 購入履歴候補選択モーダル -->
    <div id="boothCandidatesModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5);">
        <div style="background-color: #374151; margin: 5% auto; padding: 30px; border-radius: 6px; width: 90%; max-width: 700px; color: white; position: relative; max-height: 80vh; overflow-y: auto;">
            <button onclick="closeBoothCandidatesModal()" style="position: absolute; top: 15px; right: 20px; background: none; border: none; color: #9ca3af; cursor: pointer; font-size: 24px; font-weight: bold;">&times;</button>
            
            <h2 style="margin-top: 0; color: #60a5fa; font-size: 20px;">🔍 購入履歴からマッチング候補</h2>
            
            <div id="boothSearchInfo" style="margin-bottom: 20px; padding: 10px; background-color: #4b5563; border-radius: 4px; font-size: 14px;">
                <div><strong>ファイル名:</strong> <span id="searchFilename"></span></div>
                <div><strong>検索キーワード:</strong> <span id="searchKeywords"></span></div>
            </div>
            
            <div style="margin-bottom: 20px;">
                <div style="font-size: 14px; color: #d1d5db; margin-bottom: 10px;">該当する商品を選択してください：</div>
                <div id="boothCandidatesList" style="max-height: 400px; overflow-y: auto;">
                    <!-- 候補がここに動的に追加される -->
                </div>
            </div>
            
            <div style="border-top: 1px solid #4b5563; padding-top: 15px; margin-top: 20px;">
                <div style="display: flex; gap: 10px; justify-content: space-between;">
                    <button onclick="selectManualEntry()" style="padding: 8px 16px; background-color: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer;">手動入力</button>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="closeBoothCandidatesModal()" style="padding: 8px 16px; background-color: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer;">キャンセル</button>
                        <button id="selectBoothCandidate" style="padding: 8px 16px; background-color: #059669; color: white; border: none; border-radius: 4px; cursor: pointer;" disabled>選択</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 購入履歴インポート & 候補選択機能 -->
    <script>
        // 購入履歴データを保存
        let purchaseHistoryData = [];
        
        // 購入履歴インポート機能
        async function importPurchaseHistory() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const data = JSON.parse(text);
                    
                    if (data.data && Array.isArray(data.data)) {
                        purchaseHistoryData = data.data;
                        
                        // LocalStorageに保存
                        localStorage.setItem('boothPurchaseHistory', JSON.stringify(purchaseHistoryData));
                        
                        // クリアボタンを表示
                        const clearBtn = document.getElementById('clearHistoryBtn');
                        if (clearBtn) {
                            clearBtn.style.display = 'inline-block';
                        }
                        
                        alert(`✅ ${data.data.length}件の購入履歴をインポートしました！\n\n今後ZIPファイルをドロップすると、自動的に候補が表示されます。`);
                    } else {
                        throw new Error('無効なJSONファイル形式です');
                    }
                } catch (error) {
                    console.error('購入履歴インポートエラー:', error);
                    alert('❌ 購入履歴の読み込みに失敗しました: ' + error.message);
                }
            };
            input.click();
        }
        
        // 購入履歴をクリアする機能
        function clearPurchaseHistory() {
            if (confirm('購入履歴データをクリアしますか？\nこの操作は取り消せません。')) {
                // LocalStorageから削除
                localStorage.removeItem('boothPurchaseHistory');
                
                // メモリ上のデータもクリア
                purchaseHistoryData = [];
                
                // クリアボタンを非表示
                const clearBtn = document.getElementById('clearHistoryBtn');
                if (clearBtn) {
                    clearBtn.style.display = 'none';
                }
                
                alert('✅ 購入履歴データをクリアしました。\n新しくJSONファイルをインポートして動作確認ができます。');
            }
        }
        
        // Boothライブラリ収集データをクリアする機能
        function clearBoothLibraryData() {
            const stored = localStorage.getItem('boothLibraryData');
            if (!stored) {
                alert('収集データが見つかりません。');
                return;
            }
            
            const data = JSON.parse(stored);
            const itemCount = data ? data.length : 0;
            
            if (confirm(`Boothライブラリ収集データ（${itemCount}件）をクリアしますか？\n\nこれはブックマークレットで収集したデータです。\nこの操作は取り消せません。`)) {
                // LocalStorageから削除
                localStorage.removeItem('boothLibraryData');
                
                // クリアボタンを非表示
                const clearLibraryBtn = document.getElementById('clearLibraryBtn');
                if (clearLibraryBtn) {
                    clearLibraryBtn.style.display = 'none';
                }
                
                alert(`✅ Boothライブラリ収集データ（${itemCount}件）をクリアしました。\n\nブックマークレットを使って新しく収集できます。`);
            }
        }
        
        // アプリ起動時に購入履歴とBoothライブラリデータを読み込み
        document.addEventListener('DOMContentLoaded', () => {
            // 購入履歴データのチェック
            try {
                const stored = localStorage.getItem('boothPurchaseHistory');
                if (stored) {
                    purchaseHistoryData = JSON.parse(stored);
                    
                    // 購入履歴が存在する場合はクリアボタンを表示
                    if (purchaseHistoryData && purchaseHistoryData.length > 0) {
                        const clearBtn = document.getElementById('clearHistoryBtn');
                        if (clearBtn) {
                            clearBtn.style.display = 'inline-block';
                        }
                    }
                }
            } catch (error) {
                console.warn('購入履歴復元エラー:', error);
                localStorage.removeItem('boothPurchaseHistory');
            }
            
            // Boothライブラリ収集データのチェック
            try {
                const libraryData = localStorage.getItem('boothLibraryData');
                if (libraryData) {
                    const data = JSON.parse(libraryData);
                    if (data && data.length > 0) {
                        const clearLibraryBtn = document.getElementById('clearLibraryBtn');
                        if (clearLibraryBtn) {
                            clearLibraryBtn.style.display = 'inline-block';
                        }
                    }
                }
            } catch (error) {
                console.warn('Boothライブラリデータ復元エラー:', error);
            }
        });
        
        // ファイル名から候補を検索する関数（ZIPファイル名最優先検索）- グローバルスコープに移動
        function findCandidatesForFile(fileName) {
            if (!fileName || !purchaseHistoryData || purchaseHistoryData.length === 0) {
                return [];
            }
            
            const cleanFileName = fileName.replace(/\.(zip|unitypackage|rar|7z)$/i, '');
            
            // 1. 最優先: ZIPファイル名での完全一致検索
            for (const item of purchaseHistoryData) {
                if (item.zipFiles && item.zipFiles.length > 0) {
                    for (const zipFile of item.zipFiles) {
                        const cleanZipName = zipFile.replace(/\.(zip|unitypackage|rar|7z)$/i, '');
                        
                        // 完全一致 - 即座に返却
                        if (cleanFileName === cleanZipName) {
                            return [{
                                ...item,
                                matchScore: 1.0,
                                matchType: 'exact_zip_match',
                                bestMatch: zipFile,
                                matchDetails: {
                                    score: 1.0,
                                    type: 'exact_zip_match',
                                    bestMatch: zipFile,
                                    availableZipFiles: item.zipFiles || []
                                }
                            }];
                        }
                    }
                }
            }
            
            
            // 2. フォールバック: 部分一致・類似度検索
            const candidates = [];
            
            for (const item of purchaseHistoryData) {
                let score = 0;
                let matchType = '';
                let bestMatch = '';
                
                // ZIPファイル名での部分一致・類似度チェック
                if (item.zipFiles && item.zipFiles.length > 0) {
                    for (const zipFile of item.zipFiles) {
                        const cleanZipName = zipFile.replace(/\.(zip|unitypackage|rar|7z)$/i, '');
                        
                        // 部分一致（高スコア）
                        if (cleanFileName.includes(cleanZipName) || cleanZipName.includes(cleanFileName)) {
                            const partialScore = Math.min(cleanFileName.length, cleanZipName.length) / Math.max(cleanFileName.length, cleanZipName.length);
                            if (partialScore > 0.7 && partialScore > score) {
                                score = 0.9 * partialScore;
                                matchType = 'partial_zip_match';
                                bestMatch = zipFile;
                            }
                        }
                        
                        // ZIP名との類似度チェック
                        const zipSimilarity = calculateSimilarity(cleanFileName, cleanZipName);
                        if (zipSimilarity > 0.6 && zipSimilarity > score) {
                            score = 0.8 * zipSimilarity;
                            matchType = 'zip_similarity';
                            bestMatch = zipFile;
                        }
                    }
                }
                
                // タイトルとの一致（ZIPマッチがない場合のみ）
                if (score < 0.5) {
                    const keywords = extractKeywords(fileName);
                    const titleKeywords = extractKeywords(item.title);
                    
                    // 共通キーワードをチェック
                    const commonKeywords = keywords.filter(k => 
                        titleKeywords.some(tk => tk.includes(k) || k.includes(tk))
                    );
                    const keywordScore = commonKeywords.length * 0.3;
                    
                    // タイトルとの文字列類似度
                    const titleSimilarity = calculateSimilarity(fileName, item.title);
                    const titleScore = titleSimilarity * 0.6;
                    
                    // 作者名もチェック（ボーナス）
                    let authorScore = 0;
                    if (item.author) {
                        const authorSimilarity = calculateSimilarity(fileName, item.author);
                        authorScore = authorSimilarity * 0.2;
                    }
                    
                    const totalTitleScore = keywordScore + titleScore + authorScore;
                    if (totalTitleScore > score) {
                        score = totalTitleScore;
                        matchType = 'title_match';
                        bestMatch = item.title;
                    }
                }
                
                if (score > 0.2) {
                    candidates.push({
                        ...item,
                        matchScore: score,
                        matchType: matchType,
                        bestMatch: bestMatch,
                        matchDetails: {
                            score: score,
                            type: matchType,
                            bestMatch: bestMatch,
                            availableZipFiles: item.zipFiles || []
                        }
                    });
                }
            }
            
            // スコア順でソート、上位8件
            return candidates.sort((a, b) => b.matchScore - a.matchScore).slice(0, 8);
        }
        
        // 候補選択モーダルを表示
        function showBoothCandidates(fileName, candidates, onSelect) {
            document.getElementById('searchFilename').textContent = fileName;
            document.getElementById('searchKeywords').textContent = extractKeywords(fileName).join(', ');
            
            const candidatesList = document.getElementById('boothCandidatesList');
            candidatesList.innerHTML = '';
            
            if (candidates.length === 0) {
                candidatesList.innerHTML = '<div style="text-align: center; color: #9ca3af; padding: 20px;">候補が見つかりませんでした</div>';
            } else {
                candidates.forEach((candidate, index) => {
                    const candidateDiv = document.createElement('div');
                    candidateDiv.style.cssText = `
                        display: flex; align-items: center; padding: 10px; 
                        border: 2px solid #4b5563; border-radius: 6px; margin-bottom: 10px; 
                        cursor: pointer; transition: all 0.2s;
                    `;
                    candidateDiv.dataset.index = index;
                    
                    candidateDiv.innerHTML = `
                        <div style="width: 60px; height: 60px; margin-right: 15px; flex-shrink: 0;">
                            ${candidate.thumbnailUrl ? 
                                `<img src="${candidate.thumbnailUrl}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 4px;">` : 
                                '<div style="width: 100%; height: 100%; background: #374151; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 24px;">🖼️</div>'
                            }
                        </div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; margin-bottom: 5px;">${candidate.title}</div>
                            <div style="color: #9ca3af; font-size: 14px; margin-bottom: 2px;">${candidate.author}</div>
                            <div style="color: #60a5fa; font-size: 12px; margin-bottom: 2px;">
                                マッチ度: ${Math.round(candidate.matchScore * 100)}% 
                                ${candidate.matchType === 'exact_zip_match' ? '(完全一致)' : 
                                  candidate.matchType === 'partial_zip_match' ? '(部分一致)' :
                                  candidate.matchType === 'zip_similarity' ? '(ZIP類似)' : '(タイトル)'}
                            </div>
                            ${candidate.bestMatch ? `<div style="color: #10b981; font-size: 11px;">一致: ${candidate.bestMatch.length > 40 ? candidate.bestMatch.substring(0, 40) + '...' : candidate.bestMatch}</div>` : ''}
                            ${candidate.zipFiles && candidate.zipFiles.length > 0 ? 
                                `<div style="color: #6b7280; font-size: 11px;">${candidate.zipFiles.length}個のZIPファイル</div>` : ''
                            }
                        </div>
                    `;
                    
                    candidateDiv.addEventListener('click', () => {
                        // 選択状態を更新
                        candidatesList.querySelectorAll('[data-index]').forEach(el => {
                            el.style.borderColor = '#4b5563';
                            el.style.backgroundColor = 'transparent';
                        });
                        candidateDiv.style.borderColor = '#10b981';
                        candidateDiv.style.backgroundColor = '#065f46';
                        
                        // 選択ボタンを有効化
                        const selectBtn = document.getElementById('selectBoothCandidate');
                        selectBtn.disabled = false;
                        selectBtn.dataset.selectedIndex = index;
                    });
                    
                    candidatesList.appendChild(candidateDiv);
                });
            }
            
            // 選択ボタンのイベント設定
            const selectBtn = document.getElementById('selectBoothCandidate');
            selectBtn.disabled = true;
            selectBtn.onclick = () => {
                const selectedIndex = selectBtn.dataset.selectedIndex;
                if (selectedIndex !== undefined) {
                    const selected = candidates[parseInt(selectedIndex)];
                    onSelect(selected);
                    closeBoothCandidatesModal();
                }
            };
            
            // モーダル表示
            document.getElementById('boothCandidatesModal').style.display = 'block';
        }
        
        function closeBoothCandidatesModal() {
            document.getElementById('boothCandidatesModal').style.display = 'none';
        }
        
        function selectManualEntry() {
            closeBoothCandidatesModal();
            // 手動入力の場合は候補選択をスキップして商品登録を継続
            if (window.pendingProductData) {
                registerProduct(window.pendingProductData);
                window.pendingProductData = null;
            }
        }
        
        // モーダル処理キュー
        let modalQueue = [];
        let isModalProcessing = false;
        
        async function processModalQueue() {
            if (isModalProcessing || modalQueue.length === 0) return;
            
            isModalProcessing = true;
            const { fileName, candidates, productData } = modalQueue.shift();
            
            
            return new Promise((resolve) => {
                showBoothCandidates(fileName, candidates, async (selected) => {
                    // 選択された商品情報を設定
                    productData.booth_url = selected.boothUrl;
                    productData.thumbnail_url = selected.thumbnailUrl;
                    productData.author = selected.author;
                    productData.name = selected.title;
                    
                    if (selected.matchDetails) {
                    }
                    
                    // サムネイルが無効な場合はBoothから再取得を試行
                    if (selected.boothUrl && (!selected.thumbnailUrl || selected.thumbnailUrl.includes('placeholder'))) {
                        try {
                            const thumbnailResult = await window.electronAPI.fetch.thumbnail(selected.boothUrl);
                            if (thumbnailResult.success && thumbnailResult.thumbnailUrl) {
                                productData.thumbnail_url = thumbnailResult.thumbnailUrl;
                            } else {
                            }
                        } catch (error) {
                        }
                    }
                    
                    await registerProduct(productData);
                    isModalProcessing = false;
                    resolve();
                    
                    // 次のキューを処理
                    setTimeout(() => processModalQueue(), 100);
                });
                
                // 手動入力の場合の処理も更新
                const originalSelectManualEntry = window.selectManualEntry;
                window.selectManualEntry = () => {
                    closeBoothCandidatesModal();
                    registerProduct(productData);
                    isModalProcessing = false;
                    resolve();
                    
                    // 次のキューを処理
                    setTimeout(() => processModalQueue(), 100);
                    
                    // 元の関数に戻す
                    window.selectManualEntry = originalSelectManualEntry;
                };
            });
        }
        
        // 商品登録処理を共通化
        async function registerProduct(productData) {
            try {
                const addResult = await window.electronAPI.database.addProduct(productData);
            } catch (dbError) {
                console.error('商品データベース追加エラー:', dbError);
                alert(`データベース追加エラー: ${dbError.message}\n\n抽出は完了していますが、商品登録に失敗しました。`);
                return;
            }
            
            // 学習データを更新（booth_urlがある場合のみ）
            if (productData.booth_url) {
                try {
                    const fileName = productData.description.split('\n')[0] || productData.name;
                    await window.electronAPI.booth.learnMapping(fileName, productData.booth_url);
                } catch (learningError) {
                    console.error('学習データ更新エラー:', learningError);
                }
            }
            
            try {
                // 商品リストを更新
                await loadProducts();
            } catch (loadError) {
                console.error('商品リスト更新エラー:', loadError);
            }
        }
    </script>
</body>
</html>